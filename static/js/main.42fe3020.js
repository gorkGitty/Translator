/*! For license information please see main.42fe3020.js.LICENSE.txt */
(()=>{var e={6081:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var s=r(n(39)),a=n(579);t.A=(0,s.default)((0,a.jsx)("path",{d:"M6.99 11 3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z"}),"SwapHoriz")},39:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return r.createSvgIcon}});var r=n(2540)},6803:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(7598).A},8693:(e,t,n)=>{"use strict";n.d(t,{A:()=>oe});var r=n(8168),s=n(5043),a=n(8587);function i(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=i(e[t]))&&(r&&(r+=" "),r+=n)}else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}const o=function(){for(var e,t,n=0,r="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=i(e))&&(r&&(r+=" "),r+=t);return r};var l=n(6803);function u(e,t){const n=(0,r.A)({},t);return Object.keys(e).forEach((s=>{if(s.toString().match(/^(components|slots)$/))n[s]=(0,r.A)({},e[s],n[s]);else if(s.toString().match(/^(componentsProps|slotProps)$/)){const a=e[s]||{},i=t[s];n[s]={},i&&Object.keys(i)?a&&Object.keys(a)?(n[s]=(0,r.A)({},i),Object.keys(a).forEach((e=>{n[s][e]=u(a[e],i[e])}))):n[s]=i:n[s]=a}else void 0===n[s]&&(n[s]=e[s])})),n}var c=n(579);const h=s.createContext(void 0);function d(e){let{props:t,name:n}=e;return function(e){const{theme:t,name:n,props:r}=e;if(!t||!t.components||!t.components[n])return r;const s=t.components[n];return s.defaultProps?u(s.defaultProps,r):s.styleOverrides||s.variants?r:u(s,r)}({props:t,name:n,theme:{components:s.useContext(h)}})}var p=n(8052),f=n(7868),m=n(9172),g=n(7758),y=n(8812),b=n(8280);var v=n(7266);const w={black:"#000",white:"#fff"},x={50:"#fafafa",100:"#f5f5f5",200:"#eeeeee",300:"#e0e0e0",400:"#bdbdbd",500:"#9e9e9e",600:"#757575",700:"#616161",800:"#424242",900:"#212121",A100:"#f5f5f5",A200:"#eeeeee",A400:"#bdbdbd",A700:"#616161"},k={50:"#f3e5f5",100:"#e1bee7",200:"#ce93d8",300:"#ba68c8",400:"#ab47bc",500:"#9c27b0",600:"#8e24aa",700:"#7b1fa2",800:"#6a1b9a",900:"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff"},S={50:"#ffebee",100:"#ffcdd2",200:"#ef9a9a",300:"#e57373",400:"#ef5350",500:"#f44336",600:"#e53935",700:"#d32f2f",800:"#c62828",900:"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000"},I={50:"#fff3e0",100:"#ffe0b2",200:"#ffcc80",300:"#ffb74d",400:"#ffa726",500:"#ff9800",600:"#fb8c00",700:"#f57c00",800:"#ef6c00",900:"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00"},T={50:"#e3f2fd",100:"#bbdefb",200:"#90caf9",300:"#64b5f6",400:"#42a5f5",500:"#2196f3",600:"#1e88e5",700:"#1976d2",800:"#1565c0",900:"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff"},N={50:"#e1f5fe",100:"#b3e5fc",200:"#81d4fa",300:"#4fc3f7",400:"#29b6f6",500:"#03a9f4",600:"#039be5",700:"#0288d1",800:"#0277bd",900:"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea"},E={50:"#e8f5e9",100:"#c8e6c9",200:"#a5d6a7",300:"#81c784",400:"#66bb6a",500:"#4caf50",600:"#43a047",700:"#388e3c",800:"#2e7d32",900:"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853"},C=["mode","contrastThreshold","tonalOffset"],_={text:{primary:"rgba(0, 0, 0, 0.87)",secondary:"rgba(0, 0, 0, 0.6)",disabled:"rgba(0, 0, 0, 0.38)"},divider:"rgba(0, 0, 0, 0.12)",background:{paper:w.white,default:w.white},action:{active:"rgba(0, 0, 0, 0.54)",hover:"rgba(0, 0, 0, 0.04)",hoverOpacity:.04,selected:"rgba(0, 0, 0, 0.08)",selectedOpacity:.08,disabled:"rgba(0, 0, 0, 0.26)",disabledBackground:"rgba(0, 0, 0, 0.12)",disabledOpacity:.38,focus:"rgba(0, 0, 0, 0.12)",focusOpacity:.12,activatedOpacity:.12}},A={text:{primary:w.white,secondary:"rgba(255, 255, 255, 0.7)",disabled:"rgba(255, 255, 255, 0.5)",icon:"rgba(255, 255, 255, 0.5)"},divider:"rgba(255, 255, 255, 0.12)",background:{paper:"#121212",default:"#121212"},action:{active:w.white,hover:"rgba(255, 255, 255, 0.08)",hoverOpacity:.08,selected:"rgba(255, 255, 255, 0.16)",selectedOpacity:.16,disabled:"rgba(255, 255, 255, 0.3)",disabledBackground:"rgba(255, 255, 255, 0.12)",disabledOpacity:.38,focus:"rgba(255, 255, 255, 0.12)",focusOpacity:.12,activatedOpacity:.24}};function R(e,t,n,r){const s=r.light||r,a=r.dark||1.5*r;e[t]||(e.hasOwnProperty(n)?e[t]=e[n]:"light"===t?e.light=(0,v.a)(e.main,s):"dark"===t&&(e.dark=(0,v.e$)(e.main,a)))}function $(e){const{mode:t="light",contrastThreshold:n=3,tonalOffset:s=.2}=e,i=(0,a.A)(e,C),o=e.primary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:T[200],light:T[50],dark:T[400]}:{main:T[700],light:T[400],dark:T[800]}}(t),l=e.secondary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:k[200],light:k[50],dark:k[400]}:{main:k[500],light:k[300],dark:k[700]}}(t),u=e.error||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:S[500],light:S[300],dark:S[700]}:{main:S[700],light:S[400],dark:S[800]}}(t),c=e.info||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:N[400],light:N[300],dark:N[700]}:{main:N[700],light:N[500],dark:N[900]}}(t),h=e.success||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:E[400],light:E[300],dark:E[700]}:{main:E[800],light:E[500],dark:E[900]}}(t),d=e.warning||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:I[400],light:I[300],dark:I[700]}:{main:"#ed6c02",light:I[500],dark:I[900]}}(t);function p(e){return(0,v.eM)(e,A.text.primary)>=n?A.text.primary:_.text.primary}const g=e=>{let{color:t,name:n,mainShade:a=500,lightShade:i=300,darkShade:o=700}=e;if(t=(0,r.A)({},t),!t.main&&t[a]&&(t.main=t[a]),!t.hasOwnProperty("main"))throw new Error((0,f.A)(11,n?` (${n})`:"",a));if("string"!==typeof t.main)throw new Error((0,f.A)(12,n?` (${n})`:"",JSON.stringify(t.main)));return R(t,"light",i,s),R(t,"dark",o,s),t.contrastText||(t.contrastText=p(t.main)),t},y={dark:A,light:_};return(0,m.A)((0,r.A)({common:(0,r.A)({},w),mode:t,primary:g({color:o,name:"primary"}),secondary:g({color:l,name:"secondary",mainShade:"A400",lightShade:"A200",darkShade:"A700"}),error:g({color:u,name:"error"}),warning:g({color:d,name:"warning"}),info:g({color:c,name:"info"}),success:g({color:h,name:"success"}),grey:x,contrastThreshold:n,getContrastText:p,augmentColor:g,tonalOffset:s},y[t]),i)}const O=["fontFamily","fontSize","fontWeightLight","fontWeightRegular","fontWeightMedium","fontWeightBold","htmlFontSize","allVariants","pxToRem"];const D={textTransform:"uppercase"},F='"Roboto", "Helvetica", "Arial", sans-serif';function L(e,t){const n="function"===typeof t?t(e):t,{fontFamily:s=F,fontSize:i=14,fontWeightLight:o=300,fontWeightRegular:l=400,fontWeightMedium:u=500,fontWeightBold:c=700,htmlFontSize:h=16,allVariants:d,pxToRem:p}=n,f=(0,a.A)(n,O);const g=i/14,y=p||(e=>e/h*g+"rem"),b=(e,t,n,a,i)=>{return(0,r.A)({fontFamily:s,fontWeight:e,fontSize:y(t),lineHeight:n},s===F?{letterSpacing:(o=a/t,Math.round(1e5*o)/1e5)+"em"}:{},i,d);var o},v={h1:b(o,96,1.167,-1.5),h2:b(o,60,1.2,-.5),h3:b(l,48,1.167,0),h4:b(l,34,1.235,.25),h5:b(l,24,1.334,0),h6:b(u,20,1.6,.15),subtitle1:b(l,16,1.75,.15),subtitle2:b(u,14,1.57,.1),body1:b(l,16,1.5,.15),body2:b(l,14,1.43,.15),button:b(u,14,1.75,.4,D),caption:b(l,12,1.66,.4),overline:b(l,12,2.66,1,D),inherit:{fontFamily:"inherit",fontWeight:"inherit",fontSize:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}};return(0,m.A)((0,r.A)({htmlFontSize:h,pxToRem:y,fontFamily:s,fontSize:i,fontWeightLight:o,fontWeightRegular:l,fontWeightMedium:u,fontWeightBold:c},v),f,{clone:!1})}function M(){return[`${arguments.length<=0?void 0:arguments[0]}px ${arguments.length<=1?void 0:arguments[1]}px ${arguments.length<=2?void 0:arguments[2]}px ${arguments.length<=3?void 0:arguments[3]}px rgba(0,0,0,0.2)`,`${arguments.length<=4?void 0:arguments[4]}px ${arguments.length<=5?void 0:arguments[5]}px ${arguments.length<=6?void 0:arguments[6]}px ${arguments.length<=7?void 0:arguments[7]}px rgba(0,0,0,0.14)`,`${arguments.length<=8?void 0:arguments[8]}px ${arguments.length<=9?void 0:arguments[9]}px ${arguments.length<=10?void 0:arguments[10]}px ${arguments.length<=11?void 0:arguments[11]}px rgba(0,0,0,0.12)`].join(",")}const P=["none",M(0,2,1,-1,0,1,1,0,0,1,3,0),M(0,3,1,-2,0,2,2,0,0,1,5,0),M(0,3,3,-2,0,3,4,0,0,1,8,0),M(0,2,4,-1,0,4,5,0,0,1,10,0),M(0,3,5,-1,0,5,8,0,0,1,14,0),M(0,3,5,-1,0,6,10,0,0,1,18,0),M(0,4,5,-2,0,7,10,1,0,2,16,1),M(0,5,5,-3,0,8,10,1,0,3,14,2),M(0,5,6,-3,0,9,12,1,0,3,16,2),M(0,6,6,-3,0,10,14,1,0,4,18,3),M(0,6,7,-4,0,11,15,1,0,4,20,3),M(0,7,8,-4,0,12,17,2,0,5,22,4),M(0,7,8,-4,0,13,19,2,0,5,24,4),M(0,7,9,-4,0,14,21,2,0,5,26,4),M(0,8,9,-5,0,15,22,2,0,6,28,5),M(0,8,10,-5,0,16,24,2,0,6,30,5),M(0,8,11,-5,0,17,26,2,0,6,32,5),M(0,9,11,-5,0,18,28,2,0,7,34,6),M(0,9,12,-6,0,19,29,2,0,7,36,6),M(0,10,13,-6,0,20,31,3,0,8,38,7),M(0,10,13,-6,0,21,33,3,0,8,40,7),M(0,10,14,-6,0,22,35,3,0,8,42,7),M(0,11,14,-7,0,23,36,3,0,9,44,8),M(0,11,15,-7,0,24,38,3,0,9,46,8)],z=["duration","easing","delay"],B={easeInOut:"cubic-bezier(0.4, 0, 0.2, 1)",easeOut:"cubic-bezier(0.0, 0, 0.2, 1)",easeIn:"cubic-bezier(0.4, 0, 1, 1)",sharp:"cubic-bezier(0.4, 0, 0.6, 1)"},U={shortest:150,shorter:200,short:250,standard:300,complex:375,enteringScreen:225,leavingScreen:195};function V(e){return`${Math.round(e)}ms`}function W(e){if(!e)return 0;const t=e/36;return Math.round(10*(4+15*t**.25+t/5))}function j(e){const t=(0,r.A)({},B,e.easing),n=(0,r.A)({},U,e.duration);return(0,r.A)({getAutoHeightDuration:W,create:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["all"],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{duration:s=n.standard,easing:i=t.easeInOut,delay:o=0}=r;(0,a.A)(r,z);return(Array.isArray(e)?e:[e]).map((e=>`${e} ${"string"===typeof s?s:V(s)} ${i} ${"string"===typeof o?o:V(o)}`)).join(",")}},e,{easing:t,duration:n})}const G={mobileStepper:1e3,fab:1050,speedDial:1050,appBar:1100,drawer:1200,modal:1300,snackbar:1400,tooltip:1500},H=["breakpoints","mixins","spacing","palette","transitions","typography","shape"];function q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{mixins:t={},palette:n={},transitions:s={},typography:i={}}=e,o=(0,a.A)(e,H);if(e.vars)throw new Error((0,f.A)(18));const l=$(n),u=(0,b.A)(e);let c=(0,m.A)(u,{mixins:(h=u.breakpoints,d=t,(0,r.A)({toolbar:{minHeight:56,[h.up("xs")]:{"@media (orientation: landscape)":{minHeight:48}},[h.up("sm")]:{minHeight:64}}},d)),palette:l,shadows:P.slice(),typography:L(l,i),transitions:j(s),zIndex:(0,r.A)({},G)});var h,d;c=(0,m.A)(c,o);for(var p=arguments.length,v=new Array(p>1?p-1:0),w=1;w<p;w++)v[w-1]=arguments[w];return c=v.reduce(((e,t)=>(0,m.A)(e,t)),c),c.unstable_sxConfig=(0,r.A)({},g.A,null==o?void 0:o.unstable_sxConfig),c.unstable_sx=function(e){return(0,y.A)({sx:e,theme:this})},c}const K=q();const X=function(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e},Y=e=>X(e)&&"classes"!==e,Q=(0,p.Ay)({themeId:"$$material",defaultTheme:K,rootShouldForwardProp:Y});var J=n(9386);const Z={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function ee(e,t){const n=Z[t];return n?`${arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui"}-${n}`:`${J.A.generate(e)}-${t}`}function te(e){return ee("MuiSvgIcon",e)}!function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r={};t.forEach((t=>{r[t]=ee(e,t,n)}))}("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);const ne=["children","className","color","component","fontSize","htmlColor","inheritViewBox","titleAccess","viewBox"],re=e=>{const{color:t,fontSize:n,classes:r}=e;return function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};return Object.keys(e).forEach((s=>{r[s]=e[s].reduce(((e,r)=>{if(r){const s=t(r);""!==s&&e.push(s),n&&n[r]&&e.push(n[r])}return e}),[]).join(" ")})),r}({root:["root","inherit"!==t&&`color${(0,l.A)(t)}`,`fontSize${(0,l.A)(n)}`]},te,r)},se=Q("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"inherit"!==n.color&&t[`color${(0,l.A)(n.color)}`],t[`fontSize${(0,l.A)(n.fontSize)}`]]}})((e=>{let{theme:t,ownerState:n}=e;var r,s,a,i,o,l,u,c,h,d,p,f,m;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",fill:n.hasSvgAsChild?void 0:"currentColor",flexShrink:0,transition:null==(r=t.transitions)||null==(s=r.create)?void 0:s.call(r,"fill",{duration:null==(a=t.transitions)||null==(a=a.duration)?void 0:a.shorter}),fontSize:{inherit:"inherit",small:(null==(i=t.typography)||null==(o=i.pxToRem)?void 0:o.call(i,20))||"1.25rem",medium:(null==(l=t.typography)||null==(u=l.pxToRem)?void 0:u.call(l,24))||"1.5rem",large:(null==(c=t.typography)||null==(h=c.pxToRem)?void 0:h.call(c,35))||"2.1875rem"}[n.fontSize],color:null!=(d=null==(p=(t.vars||t).palette)||null==(p=p[n.color])?void 0:p.main)?d:{action:null==(f=(t.vars||t).palette)||null==(f=f.action)?void 0:f.active,disabled:null==(m=(t.vars||t).palette)||null==(m=m.action)?void 0:m.disabled,inherit:void 0}[n.color]}})),ae=s.forwardRef((function(e,t){const n=d({props:e,name:"MuiSvgIcon"});const{children:i,className:l,color:u="inherit",component:h="svg",fontSize:p="medium",htmlColor:f,inheritViewBox:m=!1,titleAccess:g,viewBox:y="0 0 24 24"}=n,b=(0,a.A)(n,ne),v=s.isValidElement(i)&&"svg"===i.type,w=(0,r.A)({},n,{color:u,component:h,fontSize:p,instanceFontSize:e.fontSize,inheritViewBox:m,viewBox:y,hasSvgAsChild:v}),x={};m||(x.viewBox=y);const k=re(w);return(0,c.jsxs)(se,(0,r.A)({as:h,className:o(k.root,l),focusable:"false",color:f,"aria-hidden":!g||void 0,role:g?"img":void 0,ref:t},x,b,v&&i.props,{ownerState:w,children:[v?i.props.children:i,g?(0,c.jsx)("title",{children:g}):null]}))}));ae.muiName="SvgIcon";const ie=ae;function oe(e,t){function n(n,s){return(0,c.jsx)(ie,(0,r.A)({"data-testid":`${t}Icon`,ref:s},n,{children:e}))}return n.muiName=ie.muiName,s.memo(s.forwardRef(n))}},2540:(e,t,n)=>{"use strict";n.r(t),n.d(t,{capitalize:()=>s.A,createChainedFunction:()=>a,createSvgIcon:()=>i.A,debounce:()=>o,deprecatedPropType:()=>l,isMuiElement:()=>h,ownerDocument:()=>p,ownerWindow:()=>f,requirePropFactory:()=>m,setRef:()=>y,unstable_ClassNameGenerator:()=>M,unstable_useEnhancedEffect:()=>v,unstable_useId:()=>k,unsupportedProp:()=>S,useControlled:()=>I,useEventCallback:()=>T,useForkRef:()=>N,useIsFocusVisible:()=>L});var r=n(9386),s=n(6803);const a=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce(((e,t)=>null==t?e:function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];e.apply(this,r),t.apply(this,r)}),(()=>{}))};var i=n(8693);const o=function(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:166;function r(){for(var r=arguments.length,s=new Array(r),a=0;a<r;a++)s[a]=arguments[a];clearTimeout(t),t=setTimeout((()=>{e.apply(this,s)}),n)}return r.clear=()=>{clearTimeout(t)},r};const l=function(e,t){return()=>null};var u=n(5043),c=n.t(u,2);const h=function(e,t){var n,r;return u.isValidElement(e)&&-1!==t.indexOf(null!=(n=e.type.muiName)?n:null==(r=e.type)||null==(r=r._payload)||null==(r=r.value)?void 0:r.muiName)};function d(e){return e&&e.ownerDocument||document}const p=d;const f=function(e){return d(e).defaultView||window};n(8168);const m=function(e,t){return()=>null};function g(e,t){"function"===typeof e?e(t):e&&(e.current=t)}const y=g,b="undefined"!==typeof window?u.useLayoutEffect:u.useEffect,v=b;let w=0;const x=c["useId".toString()];const k=function(e){if(void 0!==x){const t=x();return null!=e?e:t}return function(e){const[t,n]=u.useState(e),r=e||t;return u.useEffect((()=>{null==t&&(w+=1,n(`mui-${w}`))}),[t]),r}(e)};const S=function(e,t,n,r,s){return null};const I=function(e){let{controlled:t,default:n,name:r,state:s="value"}=e;const{current:a}=u.useRef(void 0!==t),[i,o]=u.useState(n);return[a?t:i,u.useCallback((e=>{a||o(e)}),[])]};const T=function(e){const t=u.useRef(e);return b((()=>{t.current=e})),u.useRef((function(){return(0,t.current)(...arguments)})).current};const N=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return u.useMemo((()=>t.every((e=>null==e))?null:e=>{t.forEach((t=>{g(t,e)}))}),t)};class E{constructor(){this.currentId=null,this.clear=()=>{null!==this.currentId&&(clearTimeout(this.currentId),this.currentId=null)},this.disposeEffect=()=>this.clear}static create(){return new E}start(e,t){this.clear(),this.currentId=setTimeout((()=>{this.currentId=null,t()}),e)}}let C=!0,_=!1;const A=new E,R={text:!0,search:!0,url:!0,tel:!0,email:!0,password:!0,number:!0,date:!0,month:!0,week:!0,time:!0,datetime:!0,"datetime-local":!0};function $(e){e.metaKey||e.altKey||e.ctrlKey||(C=!0)}function O(){C=!1}function D(){"hidden"===this.visibilityState&&_&&(C=!0)}function F(e){const{target:t}=e;try{return t.matches(":focus-visible")}catch(n){}return C||function(e){const{type:t,tagName:n}=e;return!("INPUT"!==n||!R[t]||e.readOnly)||"TEXTAREA"===n&&!e.readOnly||!!e.isContentEditable}(t)}const L=function(){const e=u.useCallback((e=>{var t;null!=e&&((t=e.ownerDocument).addEventListener("keydown",$,!0),t.addEventListener("mousedown",O,!0),t.addEventListener("pointerdown",O,!0),t.addEventListener("touchstart",O,!0),t.addEventListener("visibilitychange",D,!0))}),[]),t=u.useRef(!1);return{isFocusVisibleRef:t,onFocus:function(e){return!!F(e)&&(t.current=!0,!0)},onBlur:function(){return!!t.current&&(_=!0,A.start(100,(()=>{_=!1})),t.current=!1,!0)},ref:e}},M={configure:e=>{r.A.configure(e)}}},1789:(e,t,n)=>{"use strict";n.r(t),n.d(t,{GlobalStyles:()=>Ge,StyledEngineProvider:()=>je,ThemeContext:()=>Ae,css:()=>Be,default:()=>He,internal_processStyles:()=>qe,keyframes:()=>Ue});var r=n(8168),s=n(5043),a=n.t(s,2);function i(e){var t=Object.create(null);return function(n){return void 0===t[n]&&(t[n]=e(n)),t[n]}}var o=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,l=i((function(e){return o.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91}));var u=function(){function e(e){var t=this;this._insertTag=function(e){var n;n=0===t.tags.length?t.insertionPoint?t.insertionPoint.nextSibling:t.prepend?t.container.firstChild:t.before:t.tags[t.tags.length-1].nextSibling,t.container.insertBefore(e,n),t.tags.push(e)},this.isSpeedy=void 0===e.speedy||e.speedy,this.tags=[],this.ctr=0,this.nonce=e.nonce,this.key=e.key,this.container=e.container,this.prepend=e.prepend,this.insertionPoint=e.insertionPoint,this.before=null}var t=e.prototype;return t.hydrate=function(e){e.forEach(this._insertTag)},t.insert=function(e){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(function(e){var t=document.createElement("style");return t.setAttribute("data-emotion",e.key),void 0!==e.nonce&&t.setAttribute("nonce",e.nonce),t.appendChild(document.createTextNode("")),t.setAttribute("data-s",""),t}(this));var t=this.tags[this.tags.length-1];if(this.isSpeedy){var n=function(e){if(e.sheet)return e.sheet;for(var t=0;t<document.styleSheets.length;t++)if(document.styleSheets[t].ownerNode===e)return document.styleSheets[t]}(t);try{n.insertRule(e,n.cssRules.length)}catch(r){}}else t.appendChild(document.createTextNode(e));this.ctr++},t.flush=function(){this.tags.forEach((function(e){var t;return null==(t=e.parentNode)?void 0:t.removeChild(e)})),this.tags=[],this.ctr=0},e}(),c=Math.abs,h=String.fromCharCode,d=Object.assign;function p(e){return e.trim()}function f(e,t,n){return e.replace(t,n)}function m(e,t){return e.indexOf(t)}function g(e,t){return 0|e.charCodeAt(t)}function y(e,t,n){return e.slice(t,n)}function b(e){return e.length}function v(e){return e.length}function w(e,t){return t.push(e),e}var x=1,k=1,S=0,I=0,T=0,N="";function E(e,t,n,r,s,a,i){return{value:e,root:t,parent:n,type:r,props:s,children:a,line:x,column:k,length:i,return:""}}function C(e,t){return d(E("",null,null,"",null,null,0),e,{length:-e.length},t)}function _(){return T=I>0?g(N,--I):0,k--,10===T&&(k=1,x--),T}function A(){return T=I<S?g(N,I++):0,k++,10===T&&(k=1,x++),T}function R(){return g(N,I)}function $(){return I}function O(e,t){return y(N,e,t)}function D(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function F(e){return x=k=1,S=b(N=e),I=0,[]}function L(e){return N="",e}function M(e){return p(O(I-1,B(91===e?e+2:40===e?e+1:e)))}function P(e){for(;(T=R())&&T<33;)A();return D(e)>2||D(T)>3?"":" "}function z(e,t){for(;--t&&A()&&!(T<48||T>102||T>57&&T<65||T>70&&T<97););return O(e,$()+(t<6&&32==R()&&32==A()))}function B(e){for(;A();)switch(T){case e:return I;case 34:case 39:34!==e&&39!==e&&B(T);break;case 40:41===e&&B(e);break;case 92:A()}return I}function U(e,t){for(;A()&&e+T!==57&&(e+T!==84||47!==R()););return"/*"+O(t,I-1)+"*"+h(47===e?e:A())}function V(e){for(;!D(R());)A();return O(e,I)}var W="-ms-",j="-moz-",G="-webkit-",H="comm",q="rule",K="decl",X="@keyframes";function Y(e,t){for(var n="",r=v(e),s=0;s<r;s++)n+=t(e[s],s,e,t)||"";return n}function Q(e,t,n,r){switch(e.type){case"@layer":if(e.children.length)break;case"@import":case K:return e.return=e.return||e.value;case H:return"";case X:return e.return=e.value+"{"+Y(e.children,r)+"}";case q:e.value=e.props.join(",")}return b(n=Y(e.children,r))?e.return=e.value+"{"+n+"}":""}function J(e){return L(Z("",null,null,null,[""],e=F(e),0,[0],e))}function Z(e,t,n,r,s,a,i,o,l){for(var u=0,c=0,d=i,p=0,y=0,v=0,x=1,k=1,S=1,I=0,T="",N=s,E=a,C=r,O=T;k;)switch(v=I,I=A()){case 40:if(108!=v&&58==g(O,d-1)){-1!=m(O+=f(M(I),"&","&\f"),"&\f")&&(S=-1);break}case 34:case 39:case 91:O+=M(I);break;case 9:case 10:case 13:case 32:O+=P(v);break;case 92:O+=z($()-1,7);continue;case 47:switch(R()){case 42:case 47:w(te(U(A(),$()),t,n),l);break;default:O+="/"}break;case 123*x:o[u++]=b(O)*S;case 125*x:case 59:case 0:switch(I){case 0:case 125:k=0;case 59+c:-1==S&&(O=f(O,/\f/g,"")),y>0&&b(O)-d&&w(y>32?ne(O+";",r,n,d-1):ne(f(O," ","")+";",r,n,d-2),l);break;case 59:O+=";";default:if(w(C=ee(O,t,n,u,c,s,o,T,N=[],E=[],d),a),123===I)if(0===c)Z(O,t,C,C,N,a,d,o,E);else switch(99===p&&110===g(O,3)?100:p){case 100:case 108:case 109:case 115:Z(e,C,C,r&&w(ee(e,C,C,0,0,s,o,T,s,N=[],d),E),s,E,d,o,r?N:E);break;default:Z(O,C,C,C,[""],E,0,o,E)}}u=c=y=0,x=S=1,T=O="",d=i;break;case 58:d=1+b(O),y=v;default:if(x<1)if(123==I)--x;else if(125==I&&0==x++&&125==_())continue;switch(O+=h(I),I*x){case 38:S=c>0?1:(O+="\f",-1);break;case 44:o[u++]=(b(O)-1)*S,S=1;break;case 64:45===R()&&(O+=M(A())),p=R(),c=d=b(T=O+=V($())),I++;break;case 45:45===v&&2==b(O)&&(x=0)}}return a}function ee(e,t,n,r,s,a,i,o,l,u,h){for(var d=s-1,m=0===s?a:[""],g=v(m),b=0,w=0,x=0;b<r;++b)for(var k=0,S=y(e,d+1,d=c(w=i[b])),I=e;k<g;++k)(I=p(w>0?m[k]+" "+S:f(S,/&\f/g,m[k])))&&(l[x++]=I);return E(e,t,n,0===s?q:o,l,u,h)}function te(e,t,n){return E(e,t,n,H,h(T),y(e,2,-2),0)}function ne(e,t,n,r){return E(e,t,n,K,y(e,0,r),y(e,r+1,-1),r)}var re=function(e,t,n){for(var r=0,s=0;r=s,s=R(),38===r&&12===s&&(t[n]=1),!D(s);)A();return O(e,I)},se=function(e,t){return L(function(e,t){var n=-1,r=44;do{switch(D(r)){case 0:38===r&&12===R()&&(t[n]=1),e[n]+=re(I-1,t,n);break;case 2:e[n]+=M(r);break;case 4:if(44===r){e[++n]=58===R()?"&\f":"",t[n]=e[n].length;break}default:e[n]+=h(r)}}while(r=A());return e}(F(e),t))},ae=new WeakMap,ie=function(e){if("rule"===e.type&&e.parent&&!(e.length<1)){for(var t=e.value,n=e.parent,r=e.column===n.column&&e.line===n.line;"rule"!==n.type;)if(!(n=n.parent))return;if((1!==e.props.length||58===t.charCodeAt(0)||ae.get(n))&&!r){ae.set(e,!0);for(var s=[],a=se(t,s),i=n.props,o=0,l=0;o<a.length;o++)for(var u=0;u<i.length;u++,l++)e.props[l]=s[o]?a[o].replace(/&\f/g,i[u]):i[u]+" "+a[o]}}},oe=function(e){if("decl"===e.type){var t=e.value;108===t.charCodeAt(0)&&98===t.charCodeAt(2)&&(e.return="",e.value="")}};function le(e,t){switch(function(e,t){return 45^g(e,0)?(((t<<2^g(e,0))<<2^g(e,1))<<2^g(e,2))<<2^g(e,3):0}(e,t)){case 5103:return G+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return G+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return G+e+j+e+W+e+e;case 6828:case 4268:return G+e+W+e+e;case 6165:return G+e+W+"flex-"+e+e;case 5187:return G+e+f(e,/(\w+).+(:[^]+)/,G+"box-$1$2"+W+"flex-$1$2")+e;case 5443:return G+e+W+"flex-item-"+f(e,/flex-|-self/,"")+e;case 4675:return G+e+W+"flex-line-pack"+f(e,/align-content|flex-|-self/,"")+e;case 5548:return G+e+W+f(e,"shrink","negative")+e;case 5292:return G+e+W+f(e,"basis","preferred-size")+e;case 6060:return G+"box-"+f(e,"-grow","")+G+e+W+f(e,"grow","positive")+e;case 4554:return G+f(e,/([^-])(transform)/g,"$1"+G+"$2")+e;case 6187:return f(f(f(e,/(zoom-|grab)/,G+"$1"),/(image-set)/,G+"$1"),e,"")+e;case 5495:case 3959:return f(e,/(image-set\([^]*)/,G+"$1$`$1");case 4968:return f(f(e,/(.+:)(flex-)?(.*)/,G+"box-pack:$3"+W+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+G+e+e;case 4095:case 3583:case 4068:case 2532:return f(e,/(.+)-inline(.+)/,G+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(b(e)-1-t>6)switch(g(e,t+1)){case 109:if(45!==g(e,t+4))break;case 102:return f(e,/(.+:)(.+)-([^]+)/,"$1"+G+"$2-$3$1"+j+(108==g(e,t+3)?"$3":"$2-$3"))+e;case 115:return~m(e,"stretch")?le(f(e,"stretch","fill-available"),t)+e:e}break;case 4949:if(115!==g(e,t+1))break;case 6444:switch(g(e,b(e)-3-(~m(e,"!important")&&10))){case 107:return f(e,":",":"+G)+e;case 101:return f(e,/(.+:)([^;!]+)(;|!.+)?/,"$1"+G+(45===g(e,14)?"inline-":"")+"box$3$1"+G+"$2$3$1"+W+"$2box$3")+e}break;case 5936:switch(g(e,t+11)){case 114:return G+e+W+f(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return G+e+W+f(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return G+e+W+f(e,/[svh]\w+-[tblr]{2}/,"lr")+e}return G+e+W+e+e}return e}var ue=[function(e,t,n,r){if(e.length>-1&&!e.return)switch(e.type){case K:e.return=le(e.value,e.length);break;case X:return Y([C(e,{value:f(e.value,"@","@"+G)})],r);case q:if(e.length)return function(e,t){return e.map(t).join("")}(e.props,(function(t){switch(function(e,t){return(e=t.exec(e))?e[0]:e}(t,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return Y([C(e,{props:[f(t,/:(read-\w+)/,":-moz-$1")]})],r);case"::placeholder":return Y([C(e,{props:[f(t,/:(plac\w+)/,":"+G+"input-$1")]}),C(e,{props:[f(t,/:(plac\w+)/,":-moz-$1")]}),C(e,{props:[f(t,/:(plac\w+)/,W+"input-$1")]})],r)}return""}))}}],ce=function(e){var t=e.key;if("css"===t){var n=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(n,(function(e){-1!==e.getAttribute("data-emotion").indexOf(" ")&&(document.head.appendChild(e),e.setAttribute("data-s",""))}))}var r,s,a=e.stylisPlugins||ue,i={},o=[];r=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+t+' "]'),(function(e){for(var t=e.getAttribute("data-emotion").split(" "),n=1;n<t.length;n++)i[t[n]]=!0;o.push(e)}));var l,c,h=[Q,(c=function(e){l.insert(e)},function(e){e.root||(e=e.return)&&c(e)})],d=function(e){var t=v(e);return function(n,r,s,a){for(var i="",o=0;o<t;o++)i+=e[o](n,r,s,a)||"";return i}}([ie,oe].concat(a,h));s=function(e,t,n,r){l=n,Y(J(e?e+"{"+t.styles+"}":t.styles),d),r&&(p.inserted[t.name]=!0)};var p={key:t,sheet:new u({key:t,container:r,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:i,registered:{},insert:s};return p.sheet.hydrate(o),p};var he={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},de=!1,pe=/[A-Z]|^ms/g,fe=/_EMO_([^_]+?)_([^]*?)_EMO_/g,me=function(e){return 45===e.charCodeAt(1)},ge=function(e){return null!=e&&"boolean"!==typeof e},ye=i((function(e){return me(e)?e:e.replace(pe,"-$&").toLowerCase()})),be=function(e,t){switch(e){case"animation":case"animationName":if("string"===typeof t)return t.replace(fe,(function(e,t,n){return xe={name:t,styles:n,next:xe},t}))}return 1===he[e]||me(e)||"number"!==typeof t||0===t?t:t+"px"},ve="Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";function we(e,t,n){if(null==n)return"";var r=n;if(void 0!==r.__emotion_styles)return r;switch(typeof n){case"boolean":return"";case"object":var s=n;if(1===s.anim)return xe={name:s.name,styles:s.styles,next:xe},s.name;var a=n;if(void 0!==a.styles){var i=a.next;if(void 0!==i)for(;void 0!==i;)xe={name:i.name,styles:i.styles,next:xe},i=i.next;return a.styles+";"}return function(e,t,n){var r="";if(Array.isArray(n))for(var s=0;s<n.length;s++)r+=we(e,t,n[s])+";";else for(var a in n){var i=n[a];if("object"!==typeof i){var o=i;null!=t&&void 0!==t[o]?r+=a+"{"+t[o]+"}":ge(o)&&(r+=ye(a)+":"+be(a,o)+";")}else{if("NO_COMPONENT_SELECTOR"===a&&de)throw new Error(ve);if(!Array.isArray(i)||"string"!==typeof i[0]||null!=t&&void 0!==t[i[0]]){var l=we(e,t,i);switch(a){case"animation":case"animationName":r+=ye(a)+":"+l+";";break;default:r+=a+"{"+l+"}"}}else for(var u=0;u<i.length;u++)ge(i[u])&&(r+=ye(a)+":"+be(a,i[u])+";")}}return r}(e,t,n);case"function":if(void 0!==e){var o=xe,l=n(e);return xe=o,we(e,t,l)}}var u=n;if(null==t)return u;var c=t[u];return void 0!==c?c:u}var xe,ke=/label:\s*([^\s;{]+)\s*(;|$)/g;function Se(e,t,n){if(1===e.length&&"object"===typeof e[0]&&null!==e[0]&&void 0!==e[0].styles)return e[0];var r=!0,s="";xe=void 0;var a=e[0];null==a||void 0===a.raw?(r=!1,s+=we(n,t,a)):s+=a[0];for(var i=1;i<e.length;i++){if(s+=we(n,t,e[i]),r)s+=a[i]}ke.lastIndex=0;for(var o,l="";null!==(o=ke.exec(s));)l+="-"+o[1];var u=function(e){for(var t,n=0,r=0,s=e.length;s>=4;++r,s-=4)t=1540483477*(65535&(t=255&e.charCodeAt(r)|(255&e.charCodeAt(++r))<<8|(255&e.charCodeAt(++r))<<16|(255&e.charCodeAt(++r))<<24))+(59797*(t>>>16)<<16),n=1540483477*(65535&(t^=t>>>24))+(59797*(t>>>16)<<16)^1540483477*(65535&n)+(59797*(n>>>16)<<16);switch(s){case 3:n^=(255&e.charCodeAt(r+2))<<16;case 2:n^=(255&e.charCodeAt(r+1))<<8;case 1:n=1540483477*(65535&(n^=255&e.charCodeAt(r)))+(59797*(n>>>16)<<16)}return(((n=1540483477*(65535&(n^=n>>>13))+(59797*(n>>>16)<<16))^n>>>15)>>>0).toString(36)}(s)+l;return{name:u,styles:s,next:xe}}var Ie=!!a.useInsertionEffect&&a.useInsertionEffect,Te=Ie||function(e){return e()},Ne=Ie||s.useLayoutEffect,Ee=s.createContext("undefined"!==typeof HTMLElement?ce({key:"css"}):null),Ce=Ee.Provider,_e=function(e){return(0,s.forwardRef)((function(t,n){var r=(0,s.useContext)(Ee);return e(t,r,n)}))},Ae=s.createContext({});var Re=function(e,t,n){var r=e.key+"-"+t.name;!1===n&&void 0===e.registered[r]&&(e.registered[r]=t.styles)},$e=function(e,t,n){Re(e,t,n);var r=e.key+"-"+t.name;if(void 0===e.inserted[t.name]){var s=t;do{e.insert(t===s?"."+r:"",s,e.sheet,!0),s=s.next}while(void 0!==s)}},Oe=l,De=function(e){return"theme"!==e},Fe=function(e){return"string"===typeof e&&e.charCodeAt(0)>96?Oe:De},Le=function(e,t,n){var r;if(t){var s=t.shouldForwardProp;r=e.__emotion_forwardProp&&s?function(t){return e.__emotion_forwardProp(t)&&s(t)}:s}return"function"!==typeof r&&n&&(r=e.__emotion_forwardProp),r},Me=function(e){var t=e.cache,n=e.serialized,r=e.isStringTag;return Re(t,n,r),Te((function(){return $e(t,n,r)})),null},Pe=function e(t,n){var a,i,o=t.__emotion_real===t,l=o&&t.__emotion_base||t;void 0!==n&&(a=n.label,i=n.target);var u=Le(t,n,o),c=u||Fe(l),h=!c("as");return function(){var d=arguments,p=o&&void 0!==t.__emotion_styles?t.__emotion_styles.slice(0):[];if(void 0!==a&&p.push("label:"+a+";"),null==d[0]||void 0===d[0].raw)p.push.apply(p,d);else{p.push(d[0][0]);for(var f=d.length,m=1;m<f;m++)p.push(d[m],d[0][m])}var g=_e((function(e,t,n){var r=h&&e.as||l,a="",o=[],d=e;if(null==e.theme){for(var f in d={},e)d[f]=e[f];d.theme=s.useContext(Ae)}"string"===typeof e.className?a=function(e,t,n){var r="";return n.split(" ").forEach((function(n){void 0!==e[n]?t.push(e[n]+";"):n&&(r+=n+" ")})),r}(t.registered,o,e.className):null!=e.className&&(a=e.className+" ");var m=Se(p.concat(o),t.registered,d);a+=t.key+"-"+m.name,void 0!==i&&(a+=" "+i);var g=h&&void 0===u?Fe(r):c,y={};for(var b in e)h&&"as"===b||g(b)&&(y[b]=e[b]);return y.className=a,n&&(y.ref=n),s.createElement(s.Fragment,null,s.createElement(Me,{cache:t,serialized:m,isStringTag:"string"===typeof r}),s.createElement(r,y))}));return g.displayName=void 0!==a?a:"Styled("+("string"===typeof l?l:l.displayName||l.name||"Component")+")",g.defaultProps=t.defaultProps,g.__emotion_real=g,g.__emotion_base=l,g.__emotion_styles=p,g.__emotion_forwardProp=u,Object.defineProperty(g,"toString",{value:function(){return"."+i}}),g.withComponent=function(t,s){return e(t,(0,r.A)({},n,s,{shouldForwardProp:Le(g,s,!0)})).apply(void 0,p)},g}}.bind();["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"].forEach((function(e){Pe[e]=Pe(e)}));n(219);var ze=_e((function(e,t){var n=Se([e.styles],void 0,s.useContext(Ae)),r=s.useRef();return Ne((function(){var e=t.key+"-global",s=new t.sheet.constructor({key:e,nonce:t.sheet.nonce,container:t.sheet.container,speedy:t.sheet.isSpeedy}),a=!1,i=document.querySelector('style[data-emotion="'+e+" "+n.name+'"]');return t.sheet.tags.length&&(s.before=t.sheet.tags[0]),null!==i&&(a=!0,i.setAttribute("data-emotion",e),s.hydrate([i])),r.current=[s,a],function(){s.flush()}}),[t]),Ne((function(){var e=r.current,s=e[0];if(e[1])e[1]=!1;else{if(void 0!==n.next&&$e(t,n.next,!0),s.tags.length){var a=s.tags[s.tags.length-1].nextElementSibling;s.before=a,s.flush()}t.insert("",n,s,!1)}}),[t,n.name]),null}));function Be(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return Se(t)}var Ue=function(){var e=Be.apply(void 0,arguments),t="animation-"+e.name;return{name:t,styles:"@keyframes "+t+"{"+e.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}};var Ve=n(579);let We;function je(e){const{injectFirst:t,children:n}=e;return t&&We?(0,Ve.jsx)(Ce,{value:We,children:n}):n}function Ge(e){const{styles:t,defaultTheme:n={}}=e,r="function"===typeof t?e=>{return t(void 0===(r=e)||null===r||0===Object.keys(r).length?n:e);var r}:t;return(0,Ve.jsx)(ze,{styles:r})}function He(e,t){return Pe(e,t)}"object"===typeof document&&(We=ce({key:"css",prepend:!0}));const qe=(e,t)=>{Array.isArray(e.__emotion_styles)&&(e.__emotion_styles=t(e.__emotion_styles))}},7266:(e,t,n)=>{"use strict";var r=n(4994);t.e$=f,t.eM=function(e,t){const n=d(e),r=d(t);return(Math.max(n,r)+.05)/(Math.min(n,r)+.05)},t.a=m;var s=r(n(457)),a=r(n(9214));function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return(0,a.default)(e,t,n)}function o(e){e=e.slice(1);const t=new RegExp(`.{1,${e.length>=6?2:1}}`,"g");let n=e.match(t);return n&&1===n[0].length&&(n=n.map((e=>e+e))),n?`rgb${4===n.length?"a":""}(${n.map(((e,t)=>t<3?parseInt(e,16):Math.round(parseInt(e,16)/255*1e3)/1e3)).join(", ")})`:""}function l(e){if(e.type)return e;if("#"===e.charAt(0))return l(o(e));const t=e.indexOf("("),n=e.substring(0,t);if(-1===["rgb","rgba","hsl","hsla","color"].indexOf(n))throw new Error((0,s.default)(9,e));let r,a=e.substring(t+1,e.length-1);if("color"===n){if(a=a.split(" "),r=a.shift(),4===a.length&&"/"===a[3].charAt(0)&&(a[3]=a[3].slice(1)),-1===["srgb","display-p3","a98-rgb","prophoto-rgb","rec-2020"].indexOf(r))throw new Error((0,s.default)(10,r))}else a=a.split(",");return a=a.map((e=>parseFloat(e))),{type:n,values:a,colorSpace:r}}const u=e=>{const t=l(e);return t.values.slice(0,3).map(((e,n)=>-1!==t.type.indexOf("hsl")&&0!==n?`${e}%`:e)).join(" ")};function c(e){const{type:t,colorSpace:n}=e;let{values:r}=e;return-1!==t.indexOf("rgb")?r=r.map(((e,t)=>t<3?parseInt(e,10):e)):-1!==t.indexOf("hsl")&&(r[1]=`${r[1]}%`,r[2]=`${r[2]}%`),r=-1!==t.indexOf("color")?`${n} ${r.join(" ")}`:`${r.join(", ")}`,`${t}(${r})`}function h(e){e=l(e);const{values:t}=e,n=t[0],r=t[1]/100,s=t[2]/100,a=r*Math.min(s,1-s),i=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(e+n/30)%12;return s-a*Math.max(Math.min(t-3,9-t,1),-1)};let o="rgb";const u=[Math.round(255*i(0)),Math.round(255*i(8)),Math.round(255*i(4))];return"hsla"===e.type&&(o+="a",u.push(t[3])),c({type:o,values:u})}function d(e){let t="hsl"===(e=l(e)).type||"hsla"===e.type?l(h(e)).values:e.values;return t=t.map((t=>("color"!==e.type&&(t/=255),t<=.03928?t/12.92:((t+.055)/1.055)**2.4))),Number((.2126*t[0]+.7152*t[1]+.0722*t[2]).toFixed(3))}function p(e,t){return e=l(e),t=i(t),"rgb"!==e.type&&"hsl"!==e.type||(e.type+="a"),"color"===e.type?e.values[3]=`/${t}`:e.values[3]=t,c(e)}function f(e,t){if(e=l(e),t=i(t),-1!==e.type.indexOf("hsl"))e.values[2]*=1-t;else if(-1!==e.type.indexOf("rgb")||-1!==e.type.indexOf("color"))for(let n=0;n<3;n+=1)e.values[n]*=1-t;return c(e)}function m(e,t){if(e=l(e),t=i(t),-1!==e.type.indexOf("hsl"))e.values[2]+=(100-e.values[2])*t;else if(-1!==e.type.indexOf("rgb"))for(let n=0;n<3;n+=1)e.values[n]+=(255-e.values[n])*t;else if(-1!==e.type.indexOf("color"))for(let n=0;n<3;n+=1)e.values[n]+=(1-e.values[n])*t;return c(e)}function g(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.15;return d(e)>.5?f(e,t):m(e,t)}},8052:(e,t,n)=>{"use strict";var r=n(4994);t.Ay=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:t,defaultTheme:n=m,rootShouldForwardProp:r=f,slotShouldForwardProp:l=f}=e,c=e=>(0,u.default)((0,s.default)({},e,{theme:y((0,s.default)({},e,{defaultTheme:n,themeId:t}))}));return c.__mui_systemSx=!0,function(e){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,i.internal_processStyles)(e,(e=>e.filter((e=>!(null!=e&&e.__mui_systemSx)))));const{name:h,slot:p,skipVariantsResolver:m,skipSx:w,overridesResolver:x=b(g(p))}=u,k=(0,a.default)(u,d),S=void 0!==m?m:p&&"Root"!==p&&"root"!==p||!1,I=w||!1;let T=f;"Root"===p||"root"===p?T=r:p?T=l:function(e){return"string"===typeof e&&e.charCodeAt(0)>96}(e)&&(T=void 0);const N=(0,i.default)(e,(0,s.default)({shouldForwardProp:T,label:undefined},k)),E=e=>"function"===typeof e&&e.__emotion_real!==e||(0,o.isPlainObject)(e)?r=>v(e,(0,s.default)({},r,{theme:y({theme:r.theme,defaultTheme:n,themeId:t})})):e,C=function(r){let a=E(r);for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];const u=o?o.map(E):[];h&&x&&u.push((e=>{const r=y((0,s.default)({},e,{defaultTheme:n,themeId:t}));if(!r.components||!r.components[h]||!r.components[h].styleOverrides)return null;const a=r.components[h].styleOverrides,i={};return Object.entries(a).forEach((t=>{let[n,a]=t;i[n]=v(a,(0,s.default)({},e,{theme:r}))})),x(e,i)})),h&&!S&&u.push((e=>{var r;const a=y((0,s.default)({},e,{defaultTheme:n,themeId:t}));return v({variants:null==a||null==(r=a.components)||null==(r=r[h])?void 0:r.variants},(0,s.default)({},e,{theme:a}))})),I||u.push(c);const d=u.length-o.length;if(Array.isArray(r)&&d>0){const e=new Array(d).fill("");a=[...r,...e],a.raw=[...r.raw,...e]}const p=N(a,...u);return e.muiName&&(p.muiName=e.muiName),p};return N.withConfig&&(C.withConfig=N.withConfig),C}};var s=r(n(4634)),a=r(n(4893)),i=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=p(t);if(n&&n.has(e))return n.get(e);var r={__proto__:null},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var i=s?Object.getOwnPropertyDescriptor(e,a):null;i&&(i.get||i.set)?Object.defineProperty(r,a,i):r[a]=e[a]}return r.default=e,n&&n.set(e,r),r}(n(1789)),o=n(9482),l=(r(n(7918)),r(n(3382)),r(n(4989))),u=r(n(9265));const c=["ownerState"],h=["variants"],d=["name","slot","skipVariantsResolver","skipSx","overridesResolver"];function p(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(p=function(e){return e?n:t})(e)}function f(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}const m=(0,l.default)(),g=e=>e?e.charAt(0).toLowerCase()+e.slice(1):e;function y(e){let{defaultTheme:t,theme:n,themeId:r}=e;return s=n,0===Object.keys(s).length?t:n[r]||n;var s}function b(e){return e?(t,n)=>n[e]:null}function v(e,t){let{ownerState:n}=t,r=(0,a.default)(t,c);const i="function"===typeof e?e((0,s.default)({ownerState:n},r)):e;if(Array.isArray(i))return i.flatMap((e=>v(e,(0,s.default)({ownerState:n},r))));if(i&&"object"===typeof i&&Array.isArray(i.variants)){const{variants:e=[]}=i;let t=(0,a.default)(i,h);return e.forEach((e=>{let a=!0;"function"===typeof e.props?a=e.props((0,s.default)({ownerState:n},r,n)):Object.keys(e.props).forEach((t=>{(null==n?void 0:n[t])!==e.props[t]&&r[t]!==e.props[t]&&(a=!1)})),a&&(Array.isArray(t)||(t=[t]),t.push("function"===typeof e.style?e.style((0,s.default)({ownerState:n},r,n)):e.style))})),t}return i}},9751:(e,t,n)=>{"use strict";n.d(t,{EU:()=>i,NI:()=>a,vf:()=>o,zu:()=>r});const r={xs:0,sm:600,md:900,lg:1200,xl:1536},s={keys:["xs","sm","md","lg","xl"],up:e=>`@media (min-width:${r[e]}px)`};function a(e,t,n){const a=e.theme||{};if(Array.isArray(t)){const e=a.breakpoints||s;return t.reduce(((r,s,a)=>(r[e.up(e.keys[a])]=n(t[a]),r)),{})}if("object"===typeof t){const e=a.breakpoints||s;return Object.keys(t).reduce(((s,a)=>{if(-1!==Object.keys(e.values||r).indexOf(a)){s[e.up(a)]=n(t[a],a)}else{const e=a;s[e]=t[e]}return s}),{})}return n(t)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};var t;return(null==(t=e.keys)?void 0:t.reduce(((t,n)=>(t[e.up(n)]={},t)),{}))||{}}function o(e,t){return e.reduce(((e,t)=>{const n=e[t];return(!n||0===Object.keys(n).length)&&delete e[t],e}),t)}},9703:(e,t,n)=>{"use strict";function r(e,t){const n=this;if(n.vars&&"function"===typeof n.getColorSchemeSelector){const r=n.getColorSchemeSelector(e).replace(/(\[[^\]]+\])/,"*:where($1)");return{[r]:t}}return n.palette.mode===e?t:{}}n.d(t,{A:()=>r})},4853:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});var r=n(8587),s=n(8168);const a=["values","unit","step"],i=e=>{const t=Object.keys(e).map((t=>({key:t,val:e[t]})))||[];return t.sort(((e,t)=>e.val-t.val)),t.reduce(((e,t)=>(0,s.A)({},e,{[t.key]:t.val})),{})};function o(e){const{values:t={xs:0,sm:600,md:900,lg:1200,xl:1536},unit:n="px",step:o=5}=e,l=(0,r.A)(e,a),u=i(t),c=Object.keys(u);function h(e){return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n})`}function d(e){return`@media (max-width:${("number"===typeof t[e]?t[e]:e)-o/100}${n})`}function p(e,r){const s=c.indexOf(r);return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n}) and (max-width:${(-1!==s&&"number"===typeof t[c[s]]?t[c[s]]:r)-o/100}${n})`}return(0,s.A)({keys:c,values:u,up:h,down:d,between:p,only:function(e){return c.indexOf(e)+1<c.length?p(e,c[c.indexOf(e)+1]):h(e)},not:function(e){const t=c.indexOf(e);return 0===t?h(c[1]):t===c.length-1?d(c[t]):p(e,c[c.indexOf(e)+1]).replace("@media","@media not all and")},unit:n},l)}},8280:(e,t,n)=>{"use strict";n.d(t,{A:()=>p});var r=n(8168),s=n(8587),a=n(9172),i=n(4853);const o={borderRadius:4};var l=n(8604);var u=n(8812),c=n(7758),h=n(9703);const d=["breakpoints","palette","spacing","shape"];const p=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t={},palette:n={},spacing:p,shape:f={}}=e,m=(0,s.A)(e,d),g=(0,i.A)(t),y=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8;if(e.mui)return e;const t=(0,l.LX)({spacing:e}),n=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return(0===n.length?[1]:n).map((e=>{const n=t(e);return"number"===typeof n?`${n}px`:n})).join(" ")};return n.mui=!0,n}(p);let b=(0,a.A)({breakpoints:g,direction:"ltr",components:{},palette:(0,r.A)({mode:"light"},n),spacing:y,shape:(0,r.A)({},o,f)},m);b.applyStyles=h.A;for(var v=arguments.length,w=new Array(v>1?v-1:0),x=1;x<v;x++)w[x-1]=arguments[x];return b=w.reduce(((e,t)=>(0,a.A)(e,t)),b),b.unstable_sxConfig=(0,r.A)({},c.A,null==m?void 0:m.unstable_sxConfig),b.unstable_sx=function(e){return(0,u.A)({sx:e,theme:this})},b}},4989:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r.A,private_createBreakpoints:()=>s.A,unstable_applyStyles:()=>a.A});var r=n(8280),s=n(4853),a=n(9703)},3815:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(9172);const s=function(e,t){return t?(0,r.A)(e,t,{clone:!1}):e}},8604:(e,t,n)=>{"use strict";n.d(t,{LX:()=>f,MA:()=>p,_W:()=>m,Lc:()=>b,Ms:()=>v});var r=n(9751),s=n(7162),a=n(3815);const i={m:"margin",p:"padding"},o={t:"Top",r:"Right",b:"Bottom",l:"Left",x:["Left","Right"],y:["Top","Bottom"]},l={marginX:"mx",marginY:"my",paddingX:"px",paddingY:"py"},u=function(e){const t={};return n=>(void 0===t[n]&&(t[n]=e(n)),t[n])}((e=>{if(e.length>2){if(!l[e])return[e];e=l[e]}const[t,n]=e.split(""),r=i[t],s=o[n]||"";return Array.isArray(s)?s.map((e=>r+e)):[r+s]})),c=["m","mt","mr","mb","ml","mx","my","margin","marginTop","marginRight","marginBottom","marginLeft","marginX","marginY","marginInline","marginInlineStart","marginInlineEnd","marginBlock","marginBlockStart","marginBlockEnd"],h=["p","pt","pr","pb","pl","px","py","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingX","paddingY","paddingInline","paddingInlineStart","paddingInlineEnd","paddingBlock","paddingBlockStart","paddingBlockEnd"],d=[...c,...h];function p(e,t,n,r){var a;const i=null!=(a=(0,s.Yn)(e,t,!1))?a:n;return"number"===typeof i?e=>"string"===typeof e?e:i*e:Array.isArray(i)?e=>"string"===typeof e?e:i[e]:"function"===typeof i?i:()=>{}}function f(e){return p(e,"spacing",8)}function m(e,t){if("string"===typeof t||null==t)return t;const n=e(Math.abs(t));return t>=0?n:"number"===typeof n?-n:`-${n}`}function g(e,t,n,s){if(-1===t.indexOf(n))return null;const a=function(e,t){return n=>e.reduce(((e,r)=>(e[r]=m(t,n),e)),{})}(u(n),s),i=e[n];return(0,r.NI)(e,i,a)}function y(e,t){const n=f(e.theme);return Object.keys(e).map((r=>g(e,t,r,n))).reduce(a.A,{})}function b(e){return y(e,c)}function v(e){return y(e,h)}function w(e){return y(e,d)}b.propTypes={},b.filterProps=c,v.propTypes={},v.filterProps=h,w.propTypes={},w.filterProps=d},7162:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o,BO:()=>i,Yn:()=>a});var r=n(7598),s=n(9751);function a(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!t||"string"!==typeof t)return null;if(e&&e.vars&&n){const n=`vars.${t}`.split(".").reduce(((e,t)=>e&&e[t]?e[t]:null),e);if(null!=n)return n}return t.split(".").reduce(((e,t)=>e&&null!=e[t]?e[t]:null),e)}function i(e,t,n){let r,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;return r="function"===typeof e?e(n):Array.isArray(e)?e[n]||s:a(e,n)||s,t&&(r=t(r,s,e)),r}const o=function(e){const{prop:t,cssProperty:n=e.prop,themeKey:o,transform:l}=e,u=e=>{if(null==e[t])return null;const u=e[t],c=a(e.theme,o)||{};return(0,s.NI)(e,u,(e=>{let s=i(c,l,e);return e===s&&"string"===typeof e&&(s=i(c,l,`${t}${"default"===e?"":(0,r.A)(e)}`,e)),!1===n?s:{[n]:s}}))};return u.propTypes={},u.filterProps=[t],u}},7758:(e,t,n)=>{"use strict";n.d(t,{A:()=>D});var r=n(8604),s=n(7162),a=n(3815);const i=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>(t.filterProps.forEach((n=>{e[n]=t})),e)),{}),s=e=>Object.keys(e).reduce(((t,n)=>r[n]?(0,a.A)(t,r[n](e)):t),{});return s.propTypes={},s.filterProps=t.reduce(((e,t)=>e.concat(t.filterProps)),[]),s};var o=n(9751);function l(e){return"number"!==typeof e?e:`${e}px solid`}function u(e,t){return(0,s.Ay)({prop:e,themeKey:"borders",transform:t})}const c=u("border",l),h=u("borderTop",l),d=u("borderRight",l),p=u("borderBottom",l),f=u("borderLeft",l),m=u("borderColor"),g=u("borderTopColor"),y=u("borderRightColor"),b=u("borderBottomColor"),v=u("borderLeftColor"),w=u("outline",l),x=u("outlineColor"),k=e=>{if(void 0!==e.borderRadius&&null!==e.borderRadius){const t=(0,r.MA)(e.theme,"shape.borderRadius",4,"borderRadius"),n=e=>({borderRadius:(0,r._W)(t,e)});return(0,o.NI)(e,e.borderRadius,n)}return null};k.propTypes={},k.filterProps=["borderRadius"];i(c,h,d,p,f,m,g,y,b,v,k,w,x);const S=e=>{if(void 0!==e.gap&&null!==e.gap){const t=(0,r.MA)(e.theme,"spacing",8,"gap"),n=e=>({gap:(0,r._W)(t,e)});return(0,o.NI)(e,e.gap,n)}return null};S.propTypes={},S.filterProps=["gap"];const I=e=>{if(void 0!==e.columnGap&&null!==e.columnGap){const t=(0,r.MA)(e.theme,"spacing",8,"columnGap"),n=e=>({columnGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.columnGap,n)}return null};I.propTypes={},I.filterProps=["columnGap"];const T=e=>{if(void 0!==e.rowGap&&null!==e.rowGap){const t=(0,r.MA)(e.theme,"spacing",8,"rowGap"),n=e=>({rowGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.rowGap,n)}return null};T.propTypes={},T.filterProps=["rowGap"];i(S,I,T,(0,s.Ay)({prop:"gridColumn"}),(0,s.Ay)({prop:"gridRow"}),(0,s.Ay)({prop:"gridAutoFlow"}),(0,s.Ay)({prop:"gridAutoColumns"}),(0,s.Ay)({prop:"gridAutoRows"}),(0,s.Ay)({prop:"gridTemplateColumns"}),(0,s.Ay)({prop:"gridTemplateRows"}),(0,s.Ay)({prop:"gridTemplateAreas"}),(0,s.Ay)({prop:"gridArea"}));function N(e,t){return"grey"===t?t:e}i((0,s.Ay)({prop:"color",themeKey:"palette",transform:N}),(0,s.Ay)({prop:"bgcolor",cssProperty:"backgroundColor",themeKey:"palette",transform:N}),(0,s.Ay)({prop:"backgroundColor",themeKey:"palette",transform:N}));function E(e){return e<=1&&0!==e?100*e+"%":e}const C=(0,s.Ay)({prop:"width",transform:E}),_=e=>{if(void 0!==e.maxWidth&&null!==e.maxWidth){const t=t=>{var n,r;const s=(null==(n=e.theme)||null==(n=n.breakpoints)||null==(n=n.values)?void 0:n[t])||o.zu[t];return s?"px"!==(null==(r=e.theme)||null==(r=r.breakpoints)?void 0:r.unit)?{maxWidth:`${s}${e.theme.breakpoints.unit}`}:{maxWidth:s}:{maxWidth:E(t)}};return(0,o.NI)(e,e.maxWidth,t)}return null};_.filterProps=["maxWidth"];const A=(0,s.Ay)({prop:"minWidth",transform:E}),R=(0,s.Ay)({prop:"height",transform:E}),$=(0,s.Ay)({prop:"maxHeight",transform:E}),O=(0,s.Ay)({prop:"minHeight",transform:E}),D=((0,s.Ay)({prop:"size",cssProperty:"width",transform:E}),(0,s.Ay)({prop:"size",cssProperty:"height",transform:E}),i(C,_,A,R,$,O,(0,s.Ay)({prop:"boxSizing"})),{border:{themeKey:"borders",transform:l},borderTop:{themeKey:"borders",transform:l},borderRight:{themeKey:"borders",transform:l},borderBottom:{themeKey:"borders",transform:l},borderLeft:{themeKey:"borders",transform:l},borderColor:{themeKey:"palette"},borderTopColor:{themeKey:"palette"},borderRightColor:{themeKey:"palette"},borderBottomColor:{themeKey:"palette"},borderLeftColor:{themeKey:"palette"},outline:{themeKey:"borders",transform:l},outlineColor:{themeKey:"palette"},borderRadius:{themeKey:"shape.borderRadius",style:k},color:{themeKey:"palette",transform:N},bgcolor:{themeKey:"palette",cssProperty:"backgroundColor",transform:N},backgroundColor:{themeKey:"palette",transform:N},p:{style:r.Ms},pt:{style:r.Ms},pr:{style:r.Ms},pb:{style:r.Ms},pl:{style:r.Ms},px:{style:r.Ms},py:{style:r.Ms},padding:{style:r.Ms},paddingTop:{style:r.Ms},paddingRight:{style:r.Ms},paddingBottom:{style:r.Ms},paddingLeft:{style:r.Ms},paddingX:{style:r.Ms},paddingY:{style:r.Ms},paddingInline:{style:r.Ms},paddingInlineStart:{style:r.Ms},paddingInlineEnd:{style:r.Ms},paddingBlock:{style:r.Ms},paddingBlockStart:{style:r.Ms},paddingBlockEnd:{style:r.Ms},m:{style:r.Lc},mt:{style:r.Lc},mr:{style:r.Lc},mb:{style:r.Lc},ml:{style:r.Lc},mx:{style:r.Lc},my:{style:r.Lc},margin:{style:r.Lc},marginTop:{style:r.Lc},marginRight:{style:r.Lc},marginBottom:{style:r.Lc},marginLeft:{style:r.Lc},marginX:{style:r.Lc},marginY:{style:r.Lc},marginInline:{style:r.Lc},marginInlineStart:{style:r.Lc},marginInlineEnd:{style:r.Lc},marginBlock:{style:r.Lc},marginBlockStart:{style:r.Lc},marginBlockEnd:{style:r.Lc},displayPrint:{cssProperty:!1,transform:e=>({"@media print":{display:e}})},display:{},overflow:{},textOverflow:{},visibility:{},whiteSpace:{},flexBasis:{},flexDirection:{},flexWrap:{},justifyContent:{},alignItems:{},alignContent:{},order:{},flex:{},flexGrow:{},flexShrink:{},alignSelf:{},justifyItems:{},justifySelf:{},gap:{style:S},rowGap:{style:T},columnGap:{style:I},gridColumn:{},gridRow:{},gridAutoFlow:{},gridAutoColumns:{},gridAutoRows:{},gridTemplateColumns:{},gridTemplateRows:{},gridTemplateAreas:{},gridArea:{},position:{},zIndex:{themeKey:"zIndex"},top:{},right:{},bottom:{},left:{},boxShadow:{themeKey:"shadows"},width:{transform:E},maxWidth:{style:_},minWidth:{transform:E},height:{transform:E},maxHeight:{transform:E},minHeight:{transform:E},boxSizing:{},fontFamily:{themeKey:"typography"},fontSize:{themeKey:"typography"},fontStyle:{themeKey:"typography"},fontWeight:{themeKey:"typography"},letterSpacing:{},textTransform:{},lineHeight:{},textAlign:{},typography:{cssProperty:!1,themeKey:"typography"}})},9265:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r.A,extendSxProp:()=>c,unstable_createStyleFunctionSx:()=>r.k,unstable_defaultSxConfig:()=>o.A});var r=n(8812),s=n(8168),a=n(8587),i=n(9172),o=n(7758);const l=["sx"],u=e=>{var t,n;const r={systemProps:{},otherProps:{}},s=null!=(t=null==e||null==(n=e.theme)?void 0:n.unstable_sxConfig)?t:o.A;return Object.keys(e).forEach((t=>{s[t]?r.systemProps[t]=e[t]:r.otherProps[t]=e[t]})),r};function c(e){const{sx:t}=e,n=(0,a.A)(e,l),{systemProps:r,otherProps:o}=u(n);let c;return c=Array.isArray(t)?[r,...t]:"function"===typeof t?function(){const e=t(...arguments);return(0,i.Q)(e)?(0,s.A)({},r,e):r}:(0,s.A)({},r,t),(0,s.A)({},o,{sx:c})}},8812:(e,t,n)=>{"use strict";n.d(t,{A:()=>c,k:()=>l});var r=n(7598),s=n(3815),a=n(7162),i=n(9751),o=n(7758);function l(){function e(e,t,n,s){const o={[e]:t,theme:n},l=s[e];if(!l)return{[e]:t};const{cssProperty:u=e,themeKey:c,transform:h,style:d}=l;if(null==t)return null;if("typography"===c&&"inherit"===t)return{[e]:t};const p=(0,a.Yn)(n,c)||{};if(d)return d(o);return(0,i.NI)(o,t,(t=>{let n=(0,a.BO)(p,h,t);return t===n&&"string"===typeof t&&(n=(0,a.BO)(p,h,`${e}${"default"===t?"":(0,r.A)(t)}`,t)),!1===u?n:{[u]:n}}))}return function t(n){var r;const{sx:a,theme:l={}}=n||{};if(!a)return null;const u=null!=(r=l.unstable_sxConfig)?r:o.A;function c(n){let r=n;if("function"===typeof n)r=n(l);else if("object"!==typeof n)return n;if(!r)return null;const a=(0,i.EU)(l.breakpoints),o=Object.keys(a);let c=a;return Object.keys(r).forEach((n=>{const a=(o=r[n],h=l,"function"===typeof o?o(h):o);var o,h;if(null!==a&&void 0!==a)if("object"===typeof a)if(u[n])c=(0,s.A)(c,e(n,a,l,u));else{const e=(0,i.NI)({theme:l},a,(e=>({[n]:e})));!function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>e.concat(Object.keys(t))),[]),s=new Set(r);return t.every((e=>s.size===Object.keys(e).length))}(e,a)?c=(0,s.A)(c,e):c[n]=t({sx:a,theme:l})}else c=(0,s.A)(c,e(n,a,l,u))})),(0,i.vf)(o,c)}return Array.isArray(a)?a.map(c):c(a)}}const u=l();u.filterProps=["sx"];const c=u},9386:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});const r=e=>e,s=(()=>{let e=r;return{configure(t){e=t},generate:t=>e(t),reset(){e=r}}})()},7598:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(7868);function s(e){if("string"!==typeof e)throw new Error((0,r.A)(7));return e.charAt(0).toUpperCase()+e.slice(1)}},7918:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r.A});var r=n(7598)},9214:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r});const r=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MIN_SAFE_INTEGER,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Number.MAX_SAFE_INTEGER;return Math.max(t,Math.min(e,n))}},9172:(e,t,n)=>{"use strict";n.d(t,{A:()=>i,Q:()=>s});var r=n(8168);function s(e){if("object"!==typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}function a(e){if(!s(e))return e;const t={};return Object.keys(e).forEach((n=>{t[n]=a(e[n])})),t}function i(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{clone:!0};const o=n.clone?(0,r.A)({},e):e;return s(e)&&s(t)&&Object.keys(t).forEach((r=>{s(t[r])&&Object.prototype.hasOwnProperty.call(e,r)&&s(e[r])?o[r]=i(e[r],t[r],n):n.clone?o[r]=s(t[r])?a(t[r]):t[r]:o[r]=t[r]})),o}},9482:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r.A,isPlainObject:()=>r.Q});var r=n(9172)},7868:(e,t,n)=>{"use strict";function r(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}n.d(t,{A:()=>r})},457:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r.A});var r=n(7868)},3382:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>l,getFunctionName:()=>a});var r=n(9565);const s=/^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;function a(e){const t=`${e}`.match(s);return t&&t[1]||""}function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return e.displayName||e.name||a(e)||t}function o(e,t,n){const r=i(t);return e.displayName||(""!==r?`${n}(${r})`:n)}function l(e){if(null!=e){if("string"===typeof e)return e;if("function"===typeof e)return i(e,"Component");if("object"===typeof e)switch(e.$$typeof){case r.ForwardRef:return o(e,e.render,"ForwardRef");case r.Memo:return o(e,e.type,"memo");default:return}}}},8609:(e,t)=>{"use strict";var n,r=Symbol.for("react.element"),s=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),l=Symbol.for("react.provider"),u=Symbol.for("react.context"),c=Symbol.for("react.server_context"),h=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),p=Symbol.for("react.suspense_list"),f=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen");function y(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case a:case o:case i:case d:case p:return e;default:switch(e=e&&e.$$typeof){case c:case u:case h:case m:case f:case l:return e;default:return t}}case s:return t}}}n=Symbol.for("react.module.reference"),t.ForwardRef=h,t.Memo=f},9565:(e,t,n)=>{"use strict";e.exports=n(8609)},8818:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(T){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return x}return e<0?o(-e,t).neg():l(e%d|0,e/d|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+l),n);if(l<8){var d=o(u(n,l));a=a.mul(d).add(o(h))}else a=(a=a.mul(s)).add(o(h))}return a.unsigned=t,a}function h(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var w=i(-1);n.NEG_ONE=w;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,d+=(p+=s+u)>>>16,c+=(d+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=a*p)>>>16,b&=65535,y+=(b+=i*d)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=a*d)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+s*d+a*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;a=y}else{if(this.eq(S))return e.eq(b)||e.eq(w)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:w:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=b),a=a.add(d),s=s.sub(p)}return a},I.div=I.divide,I.modulo=function(e){return r(e)||(e=h(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},219:(e,t,n)=>{"use strict";var r=n(3763),s={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},a={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},i={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};function l(e){return r.isMemo(e)?i:o[e.$$typeof]||s}o[r.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},o[r.Memo]=i;var u=Object.defineProperty,c=Object.getOwnPropertyNames,h=Object.getOwnPropertySymbols,d=Object.getOwnPropertyDescriptor,p=Object.getPrototypeOf,f=Object.prototype;e.exports=function e(t,n,r){if("string"!==typeof n){if(f){var s=p(n);s&&s!==f&&e(t,s,r)}var i=c(n);h&&(i=i.concat(h(n)));for(var o=l(t),m=l(n),g=0;g<i.length;++g){var y=i[g];if(!a[y]&&(!r||!r[y])&&(!m||!m[y])&&(!o||!o[y])){var b=d(n,y);try{u(t,y,b)}catch(v){}}}}return t}},4983:(e,t)=>{"use strict";var n="function"===typeof Symbol&&Symbol.for,r=n?Symbol.for("react.element"):60103,s=n?Symbol.for("react.portal"):60106,a=n?Symbol.for("react.fragment"):60107,i=n?Symbol.for("react.strict_mode"):60108,o=n?Symbol.for("react.profiler"):60114,l=n?Symbol.for("react.provider"):60109,u=n?Symbol.for("react.context"):60110,c=n?Symbol.for("react.async_mode"):60111,h=n?Symbol.for("react.concurrent_mode"):60111,d=n?Symbol.for("react.forward_ref"):60112,p=n?Symbol.for("react.suspense"):60113,f=n?Symbol.for("react.suspense_list"):60120,m=n?Symbol.for("react.memo"):60115,g=n?Symbol.for("react.lazy"):60116,y=n?Symbol.for("react.block"):60121,b=n?Symbol.for("react.fundamental"):60117,v=n?Symbol.for("react.responder"):60118,w=n?Symbol.for("react.scope"):60119;function x(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case c:case h:case a:case o:case i:case p:return e;default:switch(e=e&&e.$$typeof){case u:case d:case g:case m:case l:return e;default:return t}}case s:return t}}}function k(e){return x(e)===h}t.AsyncMode=c,t.ConcurrentMode=h,t.ContextConsumer=u,t.ContextProvider=l,t.Element=r,t.ForwardRef=d,t.Fragment=a,t.Lazy=g,t.Memo=m,t.Portal=s,t.Profiler=o,t.StrictMode=i,t.Suspense=p,t.isAsyncMode=function(e){return k(e)||x(e)===c},t.isConcurrentMode=k,t.isContextConsumer=function(e){return x(e)===u},t.isContextProvider=function(e){return x(e)===l},t.isElement=function(e){return"object"===typeof e&&null!==e&&e.$$typeof===r},t.isForwardRef=function(e){return x(e)===d},t.isFragment=function(e){return x(e)===a},t.isLazy=function(e){return x(e)===g},t.isMemo=function(e){return x(e)===m},t.isPortal=function(e){return x(e)===s},t.isProfiler=function(e){return x(e)===o},t.isStrictMode=function(e){return x(e)===i},t.isSuspense=function(e){return x(e)===p},t.isValidElementType=function(e){return"string"===typeof e||"function"===typeof e||e===a||e===h||e===o||e===i||e===p||e===f||"object"===typeof e&&null!==e&&(e.$$typeof===g||e.$$typeof===m||e.$$typeof===l||e.$$typeof===u||e.$$typeof===d||e.$$typeof===b||e.$$typeof===v||e.$$typeof===w||e.$$typeof===y)},t.typeOf=x},3763:(e,t,n)=>{"use strict";e.exports=n(4983)},4053:e=>{e.exports=function(){return"undefined"!==typeof window&&"object"===typeof window.process&&"renderer"===window.process.type||(!("undefined"===typeof process||"object"!==typeof process.versions||!process.versions.electron)||"object"===typeof navigator&&"string"===typeof navigator.userAgent&&navigator.userAgent.indexOf("Electron")>=0)}},2730:(e,t,n)=>{"use strict";var r=n(5043),s=n(8853);function a(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var c=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,r,s,a,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=a,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,r){var s=g.hasOwnProperty(t)?g[t]:null;(null!==s?0!==s.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null===t||"undefined"===typeof t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,s,r)&&(n=null),r||null===s?function(e){return!!h.call(f,e)||!h.call(p,e)&&(d.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=null===n?3!==s.type&&"":n:(t=s.attributeName,r=s.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(s=s.type)||4===s&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var w=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),T=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),E=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),_=Symbol.for("react.suspense"),A=Symbol.for("react.suspense_list"),R=Symbol.for("react.memo"),$=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var O=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function F(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var L,M=Object.assign;function P(e){if(void 0===L)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);L=t&&t[1]||""}return"\n"+L+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&"string"===typeof u.stack){for(var s=u.stack.split("\n"),a=r.stack.split("\n"),i=s.length-1,o=a.length-1;1<=i&&0<=o&&s[i]!==a[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==a[o]){if(1!==i||1!==o)do{if(i--,0>--o||s[i]!==a[o]){var l="\n"+s[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=i&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?P(e):""}function U(e){switch(e.tag){case 5:return P(e.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case T:return"Profiler";case I:return"StrictMode";case _:return"Suspense";case A:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case E:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case C:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case R:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case $:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function W(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function j(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function H(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function K(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function X(e,t){var n=t.checked;return M({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=j(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function J(e,t){Q(e,t);var n=j(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,j(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Z(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&K(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+j(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(a(91));return M({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function se(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(a(92));if(te(n)){if(1<n.length)throw Error(a(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:j(n)}}function ae(e,t){var n=j(t.value),r=j(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,he=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function de(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),s=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ye=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(a(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(a(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(a(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var we=null;function xe(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Te(e){if(e=vs(e)){if("function"!==typeof ke)throw Error(a(280));var t=e.stateNode;t&&(t=xs(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Ee(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Te(e),t)for(e=0;e<t.length;e++)Te(t[e])}}function Ce(e,t){return e(t)}function _e(){}var Ae=!1;function Re(e,t,n){if(Ae)return e(t,n);Ae=!0;try{return Ce(e,t,n)}finally{Ae=!1,(null!==Se||null!==Ie)&&(_e(),Ee())}}function $e(e,t){var n=e.stateNode;if(null===n)return null;var r=xs(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(a(231,t,typeof n));return n}var Oe=!1;if(c)try{var De={};Object.defineProperty(De,"passive",{get:function(){Oe=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ce){Oe=!1}function Fe(e,t,n,r,s,a,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Le=!1,Me=null,Pe=!1,ze=null,Be={onError:function(e){Le=!0,Me=e}};function Ue(e,t,n,r,s,a,i,o,l){Le=!1,Me=null,Fe.apply(Be,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function We(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function je(e){if(Ve(e)!==e)throw Error(a(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(a(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(null===s)break;var i=s.alternate;if(null===i){if(null!==(r=s.return)){n=r;continue}break}if(s.child===i.child){for(i=s.child;i;){if(i===n)return je(s),e;if(i===r)return je(s),t;i=i.sibling}throw Error(a(188))}if(n.return!==r.return)n=s,r=i;else{for(var o=!1,l=s.child;l;){if(l===n){o=!0,n=s,r=i;break}if(l===r){o=!0,r=s,n=i;break}l=l.sibling}if(!o){for(l=i.child;l;){if(l===n){o=!0,n=i,r=s;break}if(l===r){o=!0,r=i,n=s;break}l=l.sibling}if(!o)throw Error(a(189))}}if(n.alternate!==r)throw Error(a(190))}if(3!==n.tag)throw Error(a(188));return n.stateNode.current===n?e:t}(e))?He(e):null}function He(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=He(e);if(null!==t)return t;e=e.sibling}return null}var qe=s.unstable_scheduleCallback,Ke=s.unstable_cancelCallback,Xe=s.unstable_shouldYield,Ye=s.unstable_requestPaint,Qe=s.unstable_now,Je=s.unstable_getCurrentPriorityLevel,Ze=s.unstable_ImmediatePriority,et=s.unstable_UserBlockingPriority,tt=s.unstable_NormalPriority,nt=s.unstable_LowPriority,rt=s.unstable_IdlePriority,st=null,at=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,ct=4194304;function ht(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function dt(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,s=e.suspendedLanes,a=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~s;0!==o?r=ht(o):0!==(a&=i)&&(r=ht(a))}else 0!==(i=n&~s)?r=ht(i):0!==a&&(r=ht(a));if(0===r)return 0;if(0!==t&&t!==r&&0===(t&s)&&((s=r&-r)>=(a=t&-t)||16===s&&0!==(4194240&a)))return t;if(0!==(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)s=1<<(n=31-it(t)),r|=e[n],t&=~s;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return 0===(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var vt=0;function wt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var xt,kt,St,It,Tt,Nt=!1,Et=[],Ct=null,_t=null,At=null,Rt=new Map,$t=new Map,Ot=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ft(e,t){switch(e){case"focusin":case"focusout":Ct=null;break;case"dragenter":case"dragleave":_t=null;break;case"mouseover":case"mouseout":At=null;break;case"pointerover":case"pointerout":Rt.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":$t.delete(t.pointerId)}}function Lt(e,t,n,r,s,a){return null===e||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},null!==t&&(null!==(t=vs(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function Mt(e){var t=bs(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=We(n)))return e.blockedOn=t,void Tt(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Pt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=vs(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);we=r,n.target.dispatchEvent(r),we=null,t.shift()}return!0}function zt(e,t,n){Pt(e)&&n.delete(t)}function Bt(){Nt=!1,null!==Ct&&Pt(Ct)&&(Ct=null),null!==_t&&Pt(_t)&&(_t=null),null!==At&&Pt(At)&&(At=null),Rt.forEach(zt),$t.forEach(zt)}function Ut(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,Bt)))}function Vt(e){function t(t){return Ut(t,e)}if(0<Et.length){Ut(Et[0],e);for(var n=1;n<Et.length;n++){var r=Et[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==Ct&&Ut(Ct,e),null!==_t&&Ut(_t,e),null!==At&&Ut(At,e),Rt.forEach(t),$t.forEach(t),n=0;n<Ot.length;n++)(r=Ot[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Ot.length&&null===(n=Ot[0]).blockedOn;)Mt(n),null===n.blockedOn&&Ot.shift()}var Wt=w.ReactCurrentBatchConfig,jt=!0;function Gt(e,t,n,r){var s=vt,a=Wt.transition;Wt.transition=null;try{vt=1,qt(e,t,n,r)}finally{vt=s,Wt.transition=a}}function Ht(e,t,n,r){var s=vt,a=Wt.transition;Wt.transition=null;try{vt=4,qt(e,t,n,r)}finally{vt=s,Wt.transition=a}}function qt(e,t,n,r){if(jt){var s=Xt(e,t,n,r);if(null===s)jr(e,t,r,Kt,n),Ft(e,r);else if(function(e,t,n,r,s){switch(t){case"focusin":return Ct=Lt(Ct,e,t,n,r,s),!0;case"dragenter":return _t=Lt(_t,e,t,n,r,s),!0;case"mouseover":return At=Lt(At,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return Rt.set(a,Lt(Rt.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,$t.set(a,Lt($t.get(a)||null,e,t,n,r,s)),!0}return!1}(s,e,t,n,r))r.stopPropagation();else if(Ft(e,r),4&t&&-1<Dt.indexOf(e)){for(;null!==s;){var a=vs(s);if(null!==a&&xt(a),null===(a=Xt(e,t,n,r))&&jr(e,t,r,Kt,n),a===s)break;s=a}null!==s&&r.stopPropagation()}else jr(e,t,r,null,n)}}var Kt=null;function Xt(e,t,n,r){if(Kt=null,null!==(e=bs(e=xe(r))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=We(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case Ze:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Jt=null,Zt=null;function en(){if(Zt)return Zt;var e,t,n=Jt,r=n.length,s="value"in Qt?Qt.value:Qt.textContent,a=s.length;for(e=0;e<r&&n[e]===s[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===s[a-t];t++);return Zt=s.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function sn(e){function t(t,n,r,s,a){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return M(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var an,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=sn(un),hn=M({},un,{view:0,detail:0}),dn=sn(hn),pn=M({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Tn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(an=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=an=0,ln=e),an)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=sn(pn),mn=sn(M({},pn,{dataTransfer:0})),gn=sn(M({},hn,{relatedTarget:0})),yn=sn(M({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=M({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=sn(bn),wn=sn(M({},un,{data:0})),xn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Tn(){return In}var Nn=M({},hn,{key:function(e){if(e.key){var t=xn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Tn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),En=sn(Nn),Cn=sn(M({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),_n=sn(M({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Tn})),An=sn(M({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),Rn=M({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),$n=sn(Rn),On=[9,13,27,32],Dn=c&&"CompositionEvent"in window,Fn=null;c&&"documentMode"in document&&(Fn=document.documentMode);var Ln=c&&"TextEvent"in window&&!Fn,Mn=c&&(!Dn||Fn&&8<Fn&&11>=Fn),Pn=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==On.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Un(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var Wn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Wn[e.type]:"textarea"===t}function Gn(e,t,n,r){Ne(r),0<(t=Hr(t,"onChange")).length&&(n=new cn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hn=null,qn=null;function Kn(e){Pr(e,0)}function Xn(e){if(q(ws(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(c){var Jn;if(c){var Zn="oninput"in document;if(!Zn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Zn="function"===typeof er.oninput}Jn=Zn}else Jn=!1;Qn=Jn&&(!document.documentMode||9<document.documentMode)}function tr(){Hn&&(Hn.detachEvent("onpropertychange",nr),qn=Hn=null)}function nr(e){if("value"===e.propertyName&&Xn(qn)){var t=[];Gn(t,qn,e,xe(e)),Re(Kn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(Hn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function sr(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Xn(qn)}function ar(e,t){if("click"===e)return Xn(t)}function ir(e,t){if("input"===e||"change"===e)return Xn(t)}var or="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function lr(e,t){if(or(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!h.call(t,s)||!or(e[s],t[s]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function hr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?hr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function dr(){for(var e=window,t=K();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=K((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=dr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&hr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var s=n.textContent.length,a=Math.min(r.start,s);r=void 0===r.end?a:Math.min(r.end,s),!e.extend&&a>r&&(s=r,r=a,a=s),s=cr(n,a);var i=cr(n,r);s&&i&&(1!==e.rangeCount||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(s.node,s.offset),e.removeAllRanges(),a>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=c&&"documentMode"in document&&11>=document.documentMode,gr=null,yr=null,br=null,vr=!1;function wr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==gr||gr!==K(r)||("selectionStart"in(r=gr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&lr(br,r)||(br=r,0<(r=Hr(yr,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function xr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:xr("Animation","AnimationEnd"),animationiteration:xr("Animation","AnimationIteration"),animationstart:xr("Animation","AnimationStart"),transitionend:xr("Transition","TransitionEnd")},Sr={},Ir={};function Tr(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ir)return Sr[e]=n[t];return e}c&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Nr=Tr("animationend"),Er=Tr("animationiteration"),Cr=Tr("animationstart"),_r=Tr("transitionend"),Ar=new Map,Rr="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function $r(e,t){Ar.set(e,t),l(t,[e])}for(var Or=0;Or<Rr.length;Or++){var Dr=Rr[Or];$r(Dr.toLowerCase(),"on"+(Dr[0].toUpperCase()+Dr.slice(1)))}$r(Nr,"onAnimationEnd"),$r(Er,"onAnimationIteration"),$r(Cr,"onAnimationStart"),$r("dblclick","onDoubleClick"),$r("focusin","onFocus"),$r("focusout","onBlur"),$r(_r,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Lr=new Set("cancel close invalid load scroll toggle".split(" ").concat(Fr));function Mr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,s,i,o,l,u){if(Ue.apply(this,arguments),Le){if(!Le)throw Error(a(198));var c=Me;Le=!1,Me=null,Pe||(Pe=!0,ze=c)}}(r,t,void 0,e),e.currentTarget=null}function Pr(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;Mr(s,o,u),a=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;Mr(s,o,u),a=l}}}if(Pe)throw e=ze,Pe=!1,ze=null,e}function zr(e,t){var n=t[ms];void 0===n&&(n=t[ms]=new Set);var r=e+"__bubble";n.has(r)||(Wr(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),Wr(n,e,r,t)}var Ur="_reactListening"+Math.random().toString(36).slice(2);function Vr(e){if(!e[Ur]){e[Ur]=!0,i.forEach((function(t){"selectionchange"!==t&&(Lr.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Ur]||(t[Ur]=!0,Br("selectionchange",!1,t))}}function Wr(e,t,n,r){switch(Yt(t)){case 1:var s=Gt;break;case 4:s=Ht;break;default:s=qt}n=s.bind(null,t,n,e),s=void 0,!Oe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function jr(e,t,n,r,s){var a=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===s||8===o.nodeType&&o.parentNode===s)break;if(4===i)for(i=r.return;null!==i;){var l=i.tag;if((3===l||4===l)&&((l=i.stateNode.containerInfo)===s||8===l.nodeType&&l.parentNode===s))return;i=i.return}for(;null!==o;){if(null===(i=bs(o)))return;if(5===(l=i.tag)||6===l){r=a=i;continue e}o=o.parentNode}}r=r.return}Re((function(){var r=a,s=xe(n),i=[];e:{var o=Ar.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=En;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=_n;break;case Nr:case Er:case Cr:l=yn;break;case _r:l=An;break;case"scroll":l=dn;break;case"wheel":l=$n;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Cn}var c=0!==(4&t),h=!c&&"scroll"===e,d=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=r;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==d&&(null!=(m=$e(f,d))&&c.push(Gr(f,m,p)))),h)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,s),i.push({event:o,listeners:c}))}}if(0===(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===we||!(u=n.relatedTarget||n.fromElement)||!bs(u)&&!u[fs])&&(l||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?bs(u):null)&&(u!==(h=Ve(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(c=fn,m="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=Cn,m="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==l?o:ws(l),p=null==u?o:ws(u),(o=new c(m,f+"leave",l,n,s)).target=h,o.relatedTarget=p,m=null,bs(s)===r&&((c=new c(d,f+"enter",u,n,s)).target=p,c.relatedTarget=h,m=c),h=m,l&&u)e:{for(d=u,f=0,p=c=l;p;p=qr(p))f++;for(p=0,m=d;m;m=qr(m))p++;for(;0<f-p;)c=qr(c),f--;for(;0<p-f;)d=qr(d),p--;for(;f--;){if(c===d||null!==d&&c===d.alternate)break e;c=qr(c),d=qr(d)}c=null}else c=null;null!==l&&Kr(i,o,l,c,!1),null!==u&&null!==h&&Kr(i,h,u,c,!0)}if("select"===(l=(o=r?ws(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Yn;else if(jn(o))if(Qn)g=ir;else{g=sr;var y=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=ar);switch(g&&(g=g(e,r))?Gn(i,g,n,s):(y&&y(e,o,r),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=r?ws(r):window,e){case"focusin":(jn(y)||"true"===y.contentEditable)&&(gr=y,yr=r,br=null);break;case"focusout":br=yr=gr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,wr(i,n,s);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":wr(i,n,s)}var b;if(Dn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Vn?Bn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Mn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Vn&&(b=en()):(Jt="value"in(Qt=s)?Qt.value:Qt.textContent,Vn=!0)),0<(y=Hr(r,v)).length&&(v=new wn(v,e,null,n,s),i.push({event:v,listeners:y}),b?v.data=b:null!==(b=Un(n))&&(v.data=b))),(b=Ln?function(e,t){switch(e){case"compositionend":return Un(t);case"keypress":return 32!==t.which?null:(zn=!0,Pn);case"textInput":return(e=t.data)===Pn&&zn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Dn&&Bn(e,t)?(e=en(),Zt=Jt=Qt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Mn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=Hr(r,"onBeforeInput")).length&&(s=new wn("onBeforeInput","beforeinput",null,n,s),i.push({event:s,listeners:r}),s.data=b))}Pr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Hr(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,a=s.stateNode;5===s.tag&&null!==a&&(s=a,null!=(a=$e(e,n))&&r.unshift(Gr(e,a,s)),null!=(a=$e(e,t))&&r.push(Gr(e,a,s))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Kr(e,t,n,r,s){for(var a=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,s?null!=(l=$e(n,a))&&i.unshift(Gr(n,l,o)):s||null!=(l=$e(n,a))&&i.push(Gr(n,l,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Xr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Qr(e){return("string"===typeof e?e:""+e).replace(Xr,"\n").replace(Yr,"")}function Jr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(a(425))}function Zr(){}var es=null,ts=null;function ns(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var rs="function"===typeof setTimeout?setTimeout:void 0,ss="function"===typeof clearTimeout?clearTimeout:void 0,as="function"===typeof Promise?Promise:void 0,is="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof as?function(e){return as.resolve(null).then(e).catch(os)}:rs;function os(e){setTimeout((function(){throw e}))}function ls(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&8===s.nodeType)if("/$"===(n=s.data)){if(0===r)return e.removeChild(s),void Vt(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=s}while(n);Vt(t)}function us(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function cs(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var hs=Math.random().toString(36).slice(2),ds="__reactFiber$"+hs,ps="__reactProps$"+hs,fs="__reactContainer$"+hs,ms="__reactEvents$"+hs,gs="__reactListeners$"+hs,ys="__reactHandles$"+hs;function bs(e){var t=e[ds];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fs]||n[ds]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=cs(e);null!==e;){if(n=e[ds])return n;e=cs(e)}return t}n=(e=n).parentNode}return null}function vs(e){return!(e=e[ds]||e[fs])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function ws(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(a(33))}function xs(e){return e[ps]||null}var ks=[],Ss=-1;function Is(e){return{current:e}}function Ts(e){0>Ss||(e.current=ks[Ss],ks[Ss]=null,Ss--)}function Ns(e,t){Ss++,ks[Ss]=e.current,e.current=t}var Es={},Cs=Is(Es),_s=Is(!1),As=Es;function Rs(e,t){var n=e.type.contextTypes;if(!n)return Es;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s,a={};for(s in n)a[s]=t[s];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function $s(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Os(){Ts(_s),Ts(Cs)}function Ds(e,t,n){if(Cs.current!==Es)throw Error(a(168));Ns(Cs,t),Ns(_s,n)}function Fs(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var s in r=r.getChildContext())if(!(s in t))throw Error(a(108,W(e)||"Unknown",s));return M({},n,r)}function Ls(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Es,As=Cs.current,Ns(Cs,e),Ns(_s,_s.current),!0}function Ms(e,t,n){var r=e.stateNode;if(!r)throw Error(a(169));n?(e=Fs(e,t,As),r.__reactInternalMemoizedMergedChildContext=e,Ts(_s),Ts(Cs),Ns(Cs,e)):Ts(_s),Ns(_s,n)}var Ps=null,zs=!1,Bs=!1;function Us(e){null===Ps?Ps=[e]:Ps.push(e)}function Vs(){if(!Bs&&null!==Ps){Bs=!0;var e=0,t=vt;try{var n=Ps;for(vt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}Ps=null,zs=!1}catch(s){throw null!==Ps&&(Ps=Ps.slice(e+1)),qe(Ze,Vs),s}finally{vt=t,Bs=!1}}return null}var Ws=[],js=0,Gs=null,Hs=0,qs=[],Ks=0,Xs=null,Ys=1,Qs="";function Js(e,t){Ws[js++]=Hs,Ws[js++]=Gs,Gs=e,Hs=t}function Zs(e,t,n){qs[Ks++]=Ys,qs[Ks++]=Qs,qs[Ks++]=Xs,Xs=e;var r=Ys;e=Qs;var s=32-it(r)-1;r&=~(1<<s),n+=1;var a=32-it(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,Ys=1<<32-it(t)+s|n<<s|r,Qs=a+e}else Ys=1<<a|n<<s|r,Qs=e}function ea(e){null!==e.return&&(Js(e,1),Zs(e,1,0))}function ta(e){for(;e===Gs;)Gs=Ws[--js],Ws[js]=null,Hs=Ws[--js],Ws[js]=null;for(;e===Xs;)Xs=qs[--Ks],qs[Ks]=null,Qs=qs[--Ks],qs[Ks]=null,Ys=qs[--Ks],qs[Ks]=null}var na=null,ra=null,sa=!1,aa=null;function ia(e,t){var n=Ru(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function oa(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,na=e,ra=us(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,na=e,ra=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Xs?{id:Ys,overflow:Qs}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Ru(18,null,null,0)).stateNode=t,n.return=e,e.child=n,na=e,ra=null,!0);default:return!1}}function la(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function ua(e){if(sa){var t=ra;if(t){var n=t;if(!oa(e,t)){if(la(e))throw Error(a(418));t=us(n.nextSibling);var r=na;t&&oa(e,t)?ia(r,n):(e.flags=-4097&e.flags|2,sa=!1,na=e)}}else{if(la(e))throw Error(a(418));e.flags=-4097&e.flags|2,sa=!1,na=e}}}function ca(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;na=e}function ha(e){if(e!==na)return!1;if(!sa)return ca(e),sa=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!ns(e.type,e.memoizedProps)),t&&(t=ra)){if(la(e))throw da(),Error(a(418));for(;t;)ia(e,t),t=us(t.nextSibling)}if(ca(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(a(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ra=us(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ra=null}}else ra=na?us(e.stateNode.nextSibling):null;return!0}function da(){for(var e=ra;e;)e=us(e.nextSibling)}function pa(){ra=na=null,sa=!1}function fa(e){null===aa?aa=[e]:aa.push(e)}var ma=w.ReactCurrentBatchConfig;function ga(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(a(309));var r=n.stateNode}if(!r)throw Error(a(147,e));var s=r,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=s.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(a(284));if(!n._owner)throw Error(a(290,e))}return e}function ya(e,t){throw e=Object.prototype.toString.call(t),Error(a(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function ba(e){return(0,e._init)(e._payload)}function va(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function s(e,t){return(e=Ou(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Mu(n,e.mode,r)).return=e,t):((t=s(t,n)).return=e,t)}function u(e,t,n,r){var a=n.type;return a===S?h(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===$&&ba(a)===t.type)?((r=s(t,n.props)).ref=ga(e,t,n),r.return=e,r):((r=Du(n.type,n.key,n.props,null,e.mode,r)).ref=ga(e,t,n),r.return=e,r)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Pu(n,e.mode,r)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function h(e,t,n,r,a){return null===t||7!==t.tag?((t=Fu(n,e.mode,r,a)).return=e,t):((t=s(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Mu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case x:return(n=Du(t.type,t.key,t.props,null,e.mode,n)).ref=ga(e,null,t),n.return=e,n;case k:return(t=Pu(t,e.mode,n)).return=e,t;case $:return d(e,(0,t._init)(t._payload),n)}if(te(t)||F(t))return(t=Fu(t,e.mode,n,null)).return=e,t;ya(e,t)}return null}function p(e,t,n,r){var s=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==s?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case x:return n.key===s?u(e,t,n,r):null;case k:return n.key===s?c(e,t,n,r):null;case $:return p(e,t,(s=n._init)(n._payload),r)}if(te(n)||F(n))return null!==s?null:h(e,t,n,r,null);ya(e,n)}return null}function f(e,t,n,r,s){if("string"===typeof r&&""!==r||"number"===typeof r)return l(t,e=e.get(n)||null,""+r,s);if("object"===typeof r&&null!==r){switch(r.$$typeof){case x:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s);case k:return c(t,e=e.get(null===r.key?n:r.key)||null,r,s);case $:return f(e,t,n,(0,r._init)(r._payload),s)}if(te(r)||F(r))return h(t,e=e.get(n)||null,r,s,null);ya(t,r)}return null}function m(s,a,o,l){for(var u=null,c=null,h=a,m=a=0,g=null;null!==h&&m<o.length;m++){h.index>m?(g=h,h=null):g=h.sibling;var y=p(s,h,o[m],l);if(null===y){null===h&&(h=g);break}e&&h&&null===y.alternate&&t(s,h),a=i(y,a,m),null===c?u=y:c.sibling=y,c=y,h=g}if(m===o.length)return n(s,h),sa&&Js(s,m),u;if(null===h){for(;m<o.length;m++)null!==(h=d(s,o[m],l))&&(a=i(h,a,m),null===c?u=h:c.sibling=h,c=h);return sa&&Js(s,m),u}for(h=r(s,h);m<o.length;m++)null!==(g=f(h,s,m,o[m],l))&&(e&&null!==g.alternate&&h.delete(null===g.key?m:g.key),a=i(g,a,m),null===c?u=g:c.sibling=g,c=g);return e&&h.forEach((function(e){return t(s,e)})),sa&&Js(s,m),u}function g(s,o,l,u){var c=F(l);if("function"!==typeof c)throw Error(a(150));if(null==(l=c.call(l)))throw Error(a(151));for(var h=c=null,m=o,g=o=0,y=null,b=l.next();null!==m&&!b.done;g++,b=l.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(s,m,b.value,u);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(s,m),o=i(v,o,g),null===h?c=v:h.sibling=v,h=v,m=y}if(b.done)return n(s,m),sa&&Js(s,g),c;if(null===m){for(;!b.done;g++,b=l.next())null!==(b=d(s,b.value,u))&&(o=i(b,o,g),null===h?c=b:h.sibling=b,h=b);return sa&&Js(s,g),c}for(m=r(s,m);!b.done;g++,b=l.next())null!==(b=f(m,s,g,b.value,u))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===h?c=b:h.sibling=b,h=b);return e&&m.forEach((function(e){return t(s,e)})),sa&&Js(s,g),c}return function e(r,a,i,l){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case x:e:{for(var u=i.key,c=a;null!==c;){if(c.key===u){if((u=i.type)===S){if(7===c.tag){n(r,c.sibling),(a=s(c,i.props.children)).return=r,r=a;break e}}else if(c.elementType===u||"object"===typeof u&&null!==u&&u.$$typeof===$&&ba(u)===c.type){n(r,c.sibling),(a=s(c,i.props)).ref=ga(r,c,i),a.return=r,r=a;break e}n(r,c);break}t(r,c),c=c.sibling}i.type===S?((a=Fu(i.props.children,r.mode,l,i.key)).return=r,r=a):((l=Du(i.type,i.key,i.props,null,r.mode,l)).ref=ga(r,a,i),l.return=r,r=l)}return o(r);case k:e:{for(c=i.key;null!==a;){if(a.key===c){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){n(r,a.sibling),(a=s(a,i.children||[])).return=r,r=a;break e}n(r,a);break}t(r,a),a=a.sibling}(a=Pu(i,r.mode,l)).return=r,r=a}return o(r);case $:return e(r,a,(c=i._init)(i._payload),l)}if(te(i))return m(r,a,i,l);if(F(i))return g(r,a,i,l);ya(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(n(r,a.sibling),(a=s(a,i)).return=r,r=a):(n(r,a),(a=Mu(i,r.mode,l)).return=r,r=a),o(r)):n(r,a)}}var wa=va(!0),xa=va(!1),ka=Is(null),Sa=null,Ia=null,Ta=null;function Na(){Ta=Ia=Sa=null}function Ea(e){var t=ka.current;Ts(ka),e._currentValue=t}function Ca(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function _a(e,t){Sa=e,Ta=Ia=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(vo=!0),e.firstContext=null)}function Aa(e){var t=e._currentValue;if(Ta!==e)if(e={context:e,memoizedValue:t,next:null},null===Ia){if(null===Sa)throw Error(a(308));Ia=e,Sa.dependencies={lanes:0,firstContext:e}}else Ia=Ia.next=e;return t}var Ra=null;function $a(e){null===Ra?Ra=[e]:Ra.push(e)}function Oa(e,t,n,r){var s=t.interleaved;return null===s?(n.next=n,$a(t)):(n.next=s.next,s.next=n),t.interleaved=n,Da(e,r)}function Da(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Fa=!1;function La(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Ma(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Pa(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function za(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Cl)){var s=r.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),r.pending=t,Da(e,n)}return null===(s=r.interleaved)?(t.next=t,$a(r)):(t.next=s.next,s.next=t),r.interleaved=t,Da(e,n)}function Ba(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Ua(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===a?s=a=i:a=a.next=i,n=n.next}while(null!==n);null===a?s=a=t:a=a.next=t}else s=a=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Va(e,t,n,r){var s=e.updateQueue;Fa=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?a=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==a){var h=s.baseState;for(i=0,c=u=l=null,o=a;;){var d=o.lane,p=o.eventTime;if((r&d)===d){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(d=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=m.payload)?f.call(p,h,d):f)||void 0===d)break e;h=M({},h,d);break e;case 2:Fa=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(d=s.effects)?s.effects=[o]:d.push(o))}else p={eventTime:p,lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=h):c=c.next=p,i|=d;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(d=o).next,d.next=null,s.lastBaseUpdate=d,s.shared.pending=null}}if(null===c&&(l=h),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,null!==(t=s.shared.interleaved)){s=t;do{i|=s.lane,s=s.next}while(s!==t)}else null===a&&(s.shared.lanes=0);Ll|=i,e.lanes=i,e.memoizedState=h}}function Wa(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(null!==s){if(r.callback=null,r=n,"function"!==typeof s)throw Error(a(191,s));s.call(r)}}}var ja={},Ga=Is(ja),Ha=Is(ja),qa=Is(ja);function Ka(e){if(e===ja)throw Error(a(174));return e}function Xa(e,t){switch(Ns(qa,t),Ns(Ha,e),Ns(Ga,ja),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ts(Ga),Ns(Ga,t)}function Ya(){Ts(Ga),Ts(Ha),Ts(qa)}function Qa(e){Ka(qa.current);var t=Ka(Ga.current),n=le(t,e.type);t!==n&&(Ns(Ha,e),Ns(Ga,n))}function Ja(e){Ha.current===e&&(Ts(Ga),Ts(Ha))}var Za=Is(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ri=w.ReactCurrentDispatcher,si=w.ReactCurrentBatchConfig,ai=0,ii=null,oi=null,li=null,ui=!1,ci=!1,hi=0,di=0;function pi(){throw Error(a(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function mi(e,t,n,r,s,i){if(ai=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ri.current=null===e||null===e.memoizedState?Ji:Zi,e=n(r,s),ci){i=0;do{if(ci=!1,hi=0,25<=i)throw Error(a(301));i+=1,li=oi=null,t.updateQueue=null,ri.current=eo,e=n(r,s)}while(ci)}if(ri.current=Qi,t=null!==oi&&null!==oi.next,ai=0,li=oi=ii=null,ui=!1,t)throw Error(a(300));return e}function gi(){var e=0!==hi;return hi=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===li?ii.memoizedState=li=e:li=li.next=e,li}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===li?ii.memoizedState:li.next;if(null!==t)li=t,oi=e;else{if(null===e)throw Error(a(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===li?ii.memoizedState=li=e:li=li.next=e}return li}function vi(e,t){return"function"===typeof t?t(e):t}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(a(311));n.lastRenderedReducer=e;var r=oi,s=r.baseQueue,i=n.pending;if(null!==i){if(null!==s){var o=s.next;s.next=i.next,i.next=o}r.baseQueue=s=i,n.pending=null}if(null!==s){i=s.next,r=r.baseState;var l=o=null,u=null,c=i;do{var h=c.lane;if((ai&h)===h)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var d={lane:h,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=d,o=r):u=u.next=d,ii.lanes|=h,Ll|=h}c=c.next}while(null!==c&&c!==i);null===u?o=r:u.next=l,or(r,t.memoizedState)||(vo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){s=e;do{i=s.lane,ii.lanes|=i,Ll|=i,s=s.next}while(s!==e)}else null===s&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function xi(e){var t=bi(),n=t.queue;if(null===n)throw Error(a(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,i=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{i=e(i,o.action),o=o.next}while(o!==s);or(i,t.memoizedState)||(vo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function ki(){}function Si(e,t){var n=ii,r=bi(),s=t(),i=!or(r.memoizedState,s);if(i&&(r.memoizedState=s,vo=!0),r=r.queue,Fi(Ni.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==li&&1&li.memoizedState.tag){if(n.flags|=2048,Ai(9,Ti.bind(null,n,r,s,t),void 0,null),null===_l)throw Error(a(349));0!==(30&ai)||Ii(n,t,s)}return s}function Ii(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ti(e,t,n,r){t.value=n,t.getSnapshot=r,Ei(t)&&Ci(e)}function Ni(e,t,n){return n((function(){Ei(t)&&Ci(e)}))}function Ei(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(r){return!0}}function Ci(e){var t=Da(e,1);null!==t&&nu(t,e,1,-1)}function _i(e){var t=yi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vi,lastRenderedState:e},t.queue=e,e=e.dispatch=qi.bind(null,ii,e),[t.memoizedState,e]}function Ai(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function Ri(){return bi().memoizedState}function $i(e,t,n,r){var s=yi();ii.flags|=e,s.memoizedState=Ai(1|t,n,void 0,void 0===r?null:r)}function Oi(e,t,n,r){var s=bi();r=void 0===r?null:r;var a=void 0;if(null!==oi){var i=oi.memoizedState;if(a=i.destroy,null!==r&&fi(r,i.deps))return void(s.memoizedState=Ai(t,n,a,r))}ii.flags|=e,s.memoizedState=Ai(1|t,n,a,r)}function Di(e,t){return $i(8390656,8,e,t)}function Fi(e,t){return Oi(2048,8,e,t)}function Li(e,t){return Oi(4,2,e,t)}function Mi(e,t){return Oi(4,4,e,t)}function Pi(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function zi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Oi(4,4,Pi.bind(null,t,e),n)}function Bi(){}function Ui(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Vi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Wi(e,t,n){return 0===(21&ai)?(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=n):(or(n,t)||(n=mt(),ii.lanes|=n,Ll|=n,e.baseState=!0),t)}function ji(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var r=si.transition;si.transition={};try{e(!1),t()}finally{vt=n,si.transition=r}}function Gi(){return bi().memoizedState}function Hi(e,t,n){var r=tu(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ki(e))Xi(t,n);else if(null!==(n=Oa(e,t,n,r))){nu(n,e,r,eu()),Yi(n,t,r)}}function qi(e,t,n){var r=tu(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ki(e))Xi(t,s);else{var a=e.alternate;if(0===e.lanes&&(null===a||0===a.lanes)&&null!==(a=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,or(o,i)){var l=t.interleaved;return null===l?(s.next=s,$a(t)):(s.next=l.next,l.next=s),void(t.interleaved=s)}}catch(u){}null!==(n=Oa(e,t,s,r))&&(nu(n,e,r,s=eu()),Yi(n,t,r))}}function Ki(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Xi(e,t){ci=ui=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Yi(e,t,n){if(0!==(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Qi={readContext:Aa,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Ji={readContext:Aa,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:Aa,useEffect:Di,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,$i(4194308,4,Pi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return $i(4194308,4,e,t)},useInsertionEffect:function(e,t){return $i(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=yi();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Hi.bind(null,ii,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:_i,useDebugValue:Bi,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=_i(!1),t=e[0];return e=ji.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=ii,s=yi();if(sa){if(void 0===n)throw Error(a(407));n=n()}else{if(n=t(),null===_l)throw Error(a(349));0!==(30&ai)||Ii(r,t,n)}s.memoizedState=n;var i={value:n,getSnapshot:t};return s.queue=i,Di(Ni.bind(null,r,i,e),[e]),r.flags|=2048,Ai(9,Ti.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=_l.identifierPrefix;if(sa){var n=Qs;t=":"+t+"R"+(n=(Ys&~(1<<32-it(Ys)-1)).toString(32)+n),0<(n=hi++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=di++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Zi={readContext:Aa,useCallback:Ui,useContext:Aa,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Li,useLayoutEffect:Mi,useMemo:Vi,useReducer:wi,useRef:Ri,useState:function(){return wi(vi)},useDebugValue:Bi,useDeferredValue:function(e){return Wi(bi(),oi.memoizedState,e)},useTransition:function(){return[wi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:Aa,useCallback:Ui,useContext:Aa,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Li,useLayoutEffect:Mi,useMemo:Vi,useReducer:xi,useRef:Ri,useState:function(){return xi(vi)},useDebugValue:Bi,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Wi(t,oi.memoizedState,e)},useTransition:function(){return[xi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=M({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:M({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ro={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=eu(),s=tu(e),a=Pa(r,s);a.payload=t,void 0!==n&&null!==n&&(a.callback=n),null!==(t=za(e,a,s))&&(nu(t,e,s,r),Ba(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=eu(),s=tu(e),a=Pa(r,s);a.tag=1,a.payload=t,void 0!==n&&null!==n&&(a.callback=n),null!==(t=za(e,a,s))&&(nu(t,e,s,r),Ba(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=eu(),r=tu(e),s=Pa(n,r);s.tag=2,void 0!==t&&null!==t&&(s.callback=t),null!==(t=za(e,s,r))&&(nu(t,e,r,n),Ba(t,e,r))}};function so(e,t,n,r,s,a,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,a,i):!t.prototype||!t.prototype.isPureReactComponent||(!lr(n,r)||!lr(s,a))}function ao(e,t,n){var r=!1,s=Es,a=t.contextType;return"object"===typeof a&&null!==a?a=Aa(a):(s=$s(t)?As:Cs.current,a=(r=null!==(r=t.contextTypes)&&void 0!==r)?Rs(e,s):Es),t=new t(n,a),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ro,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=a),t}function io(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ro.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs={},La(e);var a=t.contextType;"object"===typeof a&&null!==a?s.context=Aa(a):(a=$s(t)?As:Cs.current,s.context=Rs(e,a)),s.state=e.memoizedState,"function"===typeof(a=t.getDerivedStateFromProps)&&(no(e,t,a,n),s.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof s.getSnapshotBeforeUpdate||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||(t=s.state,"function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),t!==s.state&&ro.enqueueReplaceState(s,s.state,null),Va(e,n,s,r),s.state=e.memoizedState),"function"===typeof s.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",r=t;do{n+=U(r),r=r.return}while(r);var s=n}catch(a){s="\nError generating stack: "+a.message+"\n"+a.stack}return{value:e,source:t,stack:s,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function co(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=Pa(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){jl||(jl=!0,Gl=r),co(0,t)},n}function fo(e,t,n){(n=Pa(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"===typeof r){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){co(0,t)}}var a=e.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(n.callback=function(){co(0,t),"function"!==typeof r&&(null===Hl?Hl=new Set([this]):Hl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new ho;var s=new Set;r.set(t,s)}else void 0===(s=r.get(t))&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=Tu.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,r,s){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Pa(-1,1)).tag=2,za(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=s,e)}var bo=w.ReactCurrentOwner,vo=!1;function wo(e,t,n,r){t.child=null===e?xa(t,null,n,r):wa(t,e.child,n,r)}function xo(e,t,n,r,s){n=n.render;var a=t.ref;return _a(t,s),r=mi(e,t,n,r,a,s),n=gi(),null===e||vo?(sa&&n&&ea(t),t.flags|=1,wo(e,t,r,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,jo(e,t,s))}function ko(e,t,n,r,s){if(null===e){var a=n.type;return"function"!==typeof a||$u(a)||void 0!==a.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Du(n.type,null,r,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=a,So(e,t,a,r,s))}if(a=e.child,0===(e.lanes&s)){var i=a.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(i,r)&&e.ref===t.ref)return jo(e,t,s)}return t.flags|=1,(e=Ou(a,r)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,r,s){if(null!==e){var a=e.memoizedProps;if(lr(a,r)&&e.ref===t.ref){if(vo=!1,t.pendingProps=r=a,0===(e.lanes&s))return t.lanes=e.lanes,jo(e,t,s);0!==(131072&e.flags)&&(vo=!0)}}return No(e,t,n,r,s)}function Io(e,t,n){var r=t.pendingProps,s=r.children,a=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ns(Ol,$l),$l|=n;else{if(0===(1073741824&n))return e=null!==a?a.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ns(Ol,$l),$l|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==a?a.baseLanes:n,Ns(Ol,$l),$l|=r}else null!==a?(r=a.baseLanes|n,t.memoizedState=null):r=n,Ns(Ol,$l),$l|=r;return wo(e,t,s,n),t.child}function To(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,r,s){var a=$s(n)?As:Cs.current;return a=Rs(t,a),_a(t,s),n=mi(e,t,n,r,a,s),r=gi(),null===e||vo?(sa&&r&&ea(t),t.flags|=1,wo(e,t,n,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,jo(e,t,s))}function Eo(e,t,n,r,s){if($s(n)){var a=!0;Ls(t)}else a=!1;if(_a(t,s),null===t.stateNode)Wo(e,t),ao(t,n,r),oo(t,n,r,s),r=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;"object"===typeof u&&null!==u?u=Aa(u):u=Rs(t,u=$s(n)?As:Cs.current);var c=n.getDerivedStateFromProps,h="function"===typeof c||"function"===typeof i.getSnapshotBeforeUpdate;h||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==r||l!==u)&&io(t,i,r,u),Fa=!1;var d=t.memoizedState;i.state=d,Va(t,r,i,s),l=t.memoizedState,o!==r||d!==l||_s.current||Fa?("function"===typeof c&&(no(t,n,c,r),l=t.memoizedState),(o=Fa||so(t,n,o,r,d,l,u))?(h||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):("function"===typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,Ma(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),i.props=u,h=t.pendingProps,d=i.context,"object"===typeof(l=n.contextType)&&null!==l?l=Aa(l):l=Rs(t,l=$s(n)?As:Cs.current);var p=n.getDerivedStateFromProps;(c="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==h||d!==l)&&io(t,i,r,l),Fa=!1,d=t.memoizedState,i.state=d,Va(t,r,i,s);var f=t.memoizedState;o!==h||d!==f||_s.current||Fa?("function"===typeof p&&(no(t,n,p,r),f=t.memoizedState),(u=Fa||so(t,n,u,r,d,f,l)||!1)?(c||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,l),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),r=!1)}return Co(e,t,n,r,a,s)}function Co(e,t,n,r,s,a){To(e,t);var i=0!==(128&t.flags);if(!r&&!i)return s&&Ms(t,n,!1),jo(e,t,a);r=t.stateNode,bo.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=wa(t,e.child,null,a),t.child=wa(t,null,o,a)):wo(e,t,o,a),t.memoizedState=r.state,s&&Ms(t,n,!0),t.child}function _o(e){var t=e.stateNode;t.pendingContext?Ds(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ds(0,t.context,!1),Xa(e,t.containerInfo)}function Ao(e,t,n,r,s){return pa(),fa(s),t.flags|=256,wo(e,t,n,r),t.child}var Ro,$o,Oo,Do,Fo={dehydrated:null,treeContext:null,retryLane:0};function Lo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Mo(e,t,n){var r,s=t.pendingProps,i=Za.current,o=!1,l=0!==(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&0!==(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Ns(Za,1&i),null===e)return ua(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(l=s.children,e=s.fallback,o?(s=t.mode,o=t.child,l={mode:"hidden",children:l},0===(1&s)&&null!==o?(o.childLanes=0,o.pendingProps=l):o=Lu(l,s,0,null),e=Fu(e,s,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Lo(n),t.memoizedState=Fo,e):Po(t,l));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,s,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,r=uo(Error(a(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,s=t.mode,r=Lu({mode:"visible",children:r.children},s,0,null),(i=Fu(i,s,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,0!==(1&t.mode)&&wa(t,e.child,null,o),t.child.memoizedState=Lo(o),t.memoizedState=Fo,i);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===s.data){if(r=s.nextSibling&&s.nextSibling.dataset)var l=r.dgst;return r=l,zo(e,t,o,r=uo(i=Error(a(419)),r,void 0))}if(l=0!==(o&e.childLanes),vo||l){if(null!==(r=_l)){switch(o&-o){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}0!==(s=0!==(s&(r.suspendedLanes|o))?0:s)&&s!==i.retryLane&&(i.retryLane=s,Da(e,s),nu(r,e,s,-1))}return mu(),zo(e,t,o,r=uo(Error(a(421))))}return"$?"===s.data?(t.flags|=128,t.child=e.child,t=Eu.bind(null,e),s._reactRetry=t,null):(e=i.treeContext,ra=us(s.nextSibling),na=t,sa=!0,aa=null,null!==e&&(qs[Ks++]=Ys,qs[Ks++]=Qs,qs[Ks++]=Xs,Ys=e.id,Qs=e.overflow,Xs=t),t=Po(t,r.children),t.flags|=4096,t)}(e,t,l,s,r,i,n);if(o){o=s.fallback,l=t.mode,r=(i=e.child).sibling;var u={mode:"hidden",children:s.children};return 0===(1&l)&&t.child!==i?((s=t.child).childLanes=0,s.pendingProps=u,t.deletions=null):(s=Ou(i,u)).subtreeFlags=14680064&i.subtreeFlags,null!==r?o=Ou(r,o):(o=Fu(o,l,n,null)).flags|=2,o.return=t,s.return=t,s.sibling=o,t.child=s,s=o,o=t.child,l=null===(l=e.child.memoizedState)?Lo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Fo,s}return e=(o=e.child).sibling,s=Ou(o,{mode:"visible",children:s.children}),0===(1&t.mode)&&(s.lanes=n),s.return=t,s.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=s,t.memoizedState=null,s}function Po(e,t){return(t=Lu({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,r){return null!==r&&fa(r),wa(t,e.child,null,n),(e=Po(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),Ca(e.return,t,n)}function Uo(e,t,n,r,s){var a=e.memoizedState;null===a?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function Vo(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(wo(e,t,r.children,n),0!==(2&(r=Za.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Ns(Za,r),0===(1&t.mode))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),Uo(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===ei(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}Uo(t,!0,n,null,a);break;case"together":Uo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Wo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function jo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ll|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(a(153));if(null!==t.child){for(n=Ou(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Ou(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Go(e,t){if(!sa)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Ho(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=14680064&s.subtreeFlags,r|=14680064&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function qo(e,t,n){var r=t.pendingProps;switch(ta(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ho(t),null;case 1:case 17:return $s(t.type)&&Os(),Ho(t),null;case 3:return r=t.stateNode,Ya(),Ts(_s),Ts(Cs),ni(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(ha(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==aa&&(iu(aa),aa=null))),$o(e,t),Ho(t),null;case 5:Ja(t);var s=Ka(qa.current);if(n=t.type,null!==e&&null!=t.stateNode)Oo(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(a(166));return Ho(t),null}if(e=Ka(Ga.current),ha(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[ds]=t,r[ps]=i,e=0!==(1&t.mode),n){case"dialog":zr("cancel",r),zr("close",r);break;case"iframe":case"object":case"embed":zr("load",r);break;case"video":case"audio":for(s=0;s<Fr.length;s++)zr(Fr[s],r);break;case"source":zr("error",r);break;case"img":case"image":case"link":zr("error",r),zr("load",r);break;case"details":zr("toggle",r);break;case"input":Y(r,i),zr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},zr("invalid",r);break;case"textarea":se(r,i),zr("invalid",r)}for(var l in be(n,i),s=null,i)if(i.hasOwnProperty(l)){var u=i[l];"children"===l?"string"===typeof u?r.textContent!==u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),s=["children",u]):"number"===typeof u&&r.textContent!==""+u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),s=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zr("scroll",r)}switch(n){case"input":H(r),Z(r,i,!0);break;case"textarea":H(r),ie(r);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(r.onclick=Zr)}r=s,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===s.nodeType?s:s.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[ds]=t,e[ps]=r,Ro(e,t,!1,!1),t.stateNode=e;e:{switch(l=ve(n,r),n){case"dialog":zr("cancel",e),zr("close",e),s=r;break;case"iframe":case"object":case"embed":zr("load",e),s=r;break;case"video":case"audio":for(s=0;s<Fr.length;s++)zr(Fr[s],e);s=r;break;case"source":zr("error",e),s=r;break;case"img":case"image":case"link":zr("error",e),zr("load",e),s=r;break;case"details":zr("toggle",e),s=r;break;case"input":Y(e,r),s=X(e,r),zr("invalid",e);break;case"option":default:s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=M({},r,{value:void 0}),zr("invalid",e);break;case"textarea":se(e,r),s=re(e,r),zr("invalid",e)}for(i in be(n,s),u=s)if(u.hasOwnProperty(i)){var c=u[i];"style"===i?ge(e,c):"dangerouslySetInnerHTML"===i?null!=(c=c?c.__html:void 0)&&he(e,c):"children"===i?"string"===typeof c?("textarea"!==n||""!==c)&&de(e,c):"number"===typeof c&&de(e,""+c):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=c&&"onScroll"===i&&zr("scroll",e):null!=c&&v(e,i,c,l))}switch(n){case"input":H(e),Z(e,r,!1);break;case"textarea":H(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+j(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof s.onClick&&(e.onclick=Zr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ho(t),null;case 6:if(e&&null!=t.stateNode)Do(e,t,e.memoizedProps,r);else{if("string"!==typeof r&&null===t.stateNode)throw Error(a(166));if(n=Ka(qa.current),Ka(Ga.current),ha(t)){if(r=t.stateNode,n=t.memoizedProps,r[ds]=t,(i=r.nodeValue!==n)&&null!==(e=na))switch(e.tag){case 3:Jr(r.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Jr(r.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[ds]=t,t.stateNode=r}return Ho(t),null;case 13:if(Ts(Za),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(sa&&null!==ra&&0!==(1&t.mode)&&0===(128&t.flags))da(),pa(),t.flags|=98560,i=!1;else if(i=ha(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(a(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(a(317));i[ds]=t}else pa(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ho(t),i=!1}else null!==aa&&(iu(aa),aa=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&Za.current)?0===Dl&&(Dl=3):mu())),null!==t.updateQueue&&(t.flags|=4),Ho(t),null);case 4:return Ya(),$o(e,t),null===e&&Vr(t.stateNode.containerInfo),Ho(t),null;case 10:return Ea(t.type._context),Ho(t),null;case 19:if(Ts(Za),null===(i=t.memoizedState))return Ho(t),null;if(r=0!==(128&t.flags),null===(l=i.rendering))if(r)Go(i,!1);else{if(0!==Dl||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(l=ei(e))){for(t.flags|=128,Go(i,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ns(Za,1&Za.current|2),t.child}e=e.sibling}null!==i.tail&&Qe()>Vl&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ei(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Go(i,!0),null===i.tail&&"hidden"===i.tailMode&&!l.alternate&&!sa)return Ho(t),null}else 2*Qe()-i.renderingStartTime>Vl&&1073741824!==n&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304);i.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=i.last)?n.sibling=l:t.child=l,i.last=l)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Qe(),t.sibling=null,n=Za.current,Ns(Za,r?1&n|2:1&n),t):(Ho(t),null);case 22:case 23:return hu(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!==(1&t.mode)?0!==(1073741824&$l)&&(Ho(t),6&t.subtreeFlags&&(t.flags|=8192)):Ho(t),null;case 24:case 25:return null}throw Error(a(156,t.tag))}function Ko(e,t){switch(ta(t),t.tag){case 1:return $s(t.type)&&Os(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Ya(),Ts(_s),Ts(Cs),ni(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Ja(t),null;case 13:if(Ts(Za),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(a(340));pa()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ts(Za),null;case 4:return Ya(),null;case 10:return Ea(t.type._context),null;case 22:case 23:return hu(),null;default:return null}}Ro=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},$o=function(){},Oo=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,Ka(Ga.current);var a,i=null;switch(n){case"input":s=X(e,s),r=X(e,r),i=[];break;case"select":s=M({},s,{value:void 0}),r=M({},r,{value:void 0}),i=[];break;case"textarea":s=re(e,s),r=re(e,r),i=[];break;default:"function"!==typeof s.onClick&&"function"===typeof r.onClick&&(e.onclick=Zr)}for(c in be(n,r),n=null,s)if(!r.hasOwnProperty(c)&&s.hasOwnProperty(c)&&null!=s[c])if("style"===c){var l=s[c];for(a in l)l.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?i||(i=[]):(i=i||[]).push(c,null));for(c in r){var u=r[c];if(l=null!=s?s[c]:void 0,r.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(a in l)!l.hasOwnProperty(a)||u&&u.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in u)u.hasOwnProperty(a)&&l[a]!==u[a]&&(n||(n={}),n[a]=u[a])}else n||(i||(i=[]),i.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(c,u)):"children"===c?"string"!==typeof u&&"number"!==typeof u||(i=i||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&zr("scroll",e),i||l===u||(i=[])):(i=i||[]).push(c,u))}n&&(i=i||[]).push("style",n);var c=i;(t.updateQueue=c)&&(t.flags|=4)}},Do=function(e,t,n,r){n!==r&&(t.flags|=4)};var Xo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Jo=null;function Zo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Iu(e,t,r)}else n.current=null}function el(e,t,n){try{n()}catch(r){Iu(e,t,r)}}var tl=!1;function nl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var s=r=r.next;do{if((s.tag&e)===e){var a=s.destroy;s.destroy=void 0,void 0!==a&&el(t,n,a)}s=s.next}while(s!==r)}}function rl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function sl(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function al(e){var t=e.alternate;null!==t&&(e.alternate=null,al(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ds],delete t[ps],delete t[ms],delete t[gs],delete t[ys])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function il(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||il(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Zr));else if(4!==r&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function ul(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}var cl=null,hl=!1;function dl(e,t,n){for(n=n.child;null!==n;)pl(e,t,n),n=n.sibling}function pl(e,t,n){if(at&&"function"===typeof at.onCommitFiberUnmount)try{at.onCommitFiberUnmount(st,n)}catch(o){}switch(n.tag){case 5:Yo||Zo(n,t);case 6:var r=cl,s=hl;cl=null,dl(e,t,n),hl=s,null!==(cl=r)&&(hl?(e=cl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):cl.removeChild(n.stateNode));break;case 18:null!==cl&&(hl?(e=cl,n=n.stateNode,8===e.nodeType?ls(e.parentNode,n):1===e.nodeType&&ls(e,n),Vt(e)):ls(cl,n.stateNode));break;case 4:r=cl,s=hl,cl=n.stateNode.containerInfo,hl=!0,dl(e,t,n),cl=r,hl=s;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){s=r=r.next;do{var a=s,i=a.destroy;a=a.tag,void 0!==i&&(0!==(2&a)||0!==(4&a))&&el(n,t,i),s=s.next}while(s!==r)}dl(e,t,n);break;case 1:if(!Yo&&(Zo(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){Iu(n,t,o)}dl(e,t,n);break;case 21:dl(e,t,n);break;case 22:1&n.mode?(Yo=(r=Yo)||null!==n.memoizedState,dl(e,t,n),Yo=r):dl(e,t,n);break;default:dl(e,t,n)}}function fl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var r=Cu.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function ml(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var s=n[r];try{var i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:cl=l.stateNode,hl=!1;break e;case 3:case 4:cl=l.stateNode.containerInfo,hl=!0;break e}l=l.return}if(null===cl)throw Error(a(160));pl(i,o,s),cl=null,hl=!1;var u=s.alternate;null!==u&&(u.return=null),s.return=null}catch(c){Iu(s,t,c)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gl(t,e),t=t.sibling}function gl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ml(t,e),yl(e),4&r){try{nl(3,e,e.return),rl(3,e)}catch(g){Iu(e,e.return,g)}try{nl(5,e,e.return)}catch(g){Iu(e,e.return,g)}}break;case 1:ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return);break;case 5:if(ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return),32&e.flags){var s=e.stateNode;try{de(s,"")}catch(g){Iu(e,e.return,g)}}if(4&r&&null!=(s=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===i.type&&null!=i.name&&Q(s,i),ve(l,o);var c=ve(l,i);for(o=0;o<u.length;o+=2){var h=u[o],d=u[o+1];"style"===h?ge(s,d):"dangerouslySetInnerHTML"===h?he(s,d):"children"===h?de(s,d):v(s,h,d,c)}switch(l){case"input":J(s,i);break;case"textarea":ae(s,i);break;case"select":var p=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(s,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(s,!!i.multiple,i.defaultValue,!0):ne(s,!!i.multiple,i.multiple?[]:"",!1))}s[ps]=i}catch(g){Iu(e,e.return,g)}}break;case 6:if(ml(t,e),yl(e),4&r){if(null===e.stateNode)throw Error(a(162));s=e.stateNode,i=e.memoizedProps;try{s.nodeValue=i}catch(g){Iu(e,e.return,g)}}break;case 3:if(ml(t,e),yl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(g){Iu(e,e.return,g)}break;case 4:default:ml(t,e),yl(e);break;case 13:ml(t,e),yl(e),8192&(s=e.child).flags&&(i=null!==s.memoizedState,s.stateNode.isHidden=i,!i||null!==s.alternate&&null!==s.alternate.memoizedState||(Ul=Qe())),4&r&&fl(e);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(c=Yo)||h,ml(t,e),Yo=c):ml(t,e),yl(e),8192&r){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!h&&0!==(1&e.mode))for(Jo=e,h=e.child;null!==h;){for(d=Jo=h;null!==Jo;){switch(f=(p=Jo).child,p.tag){case 0:case 11:case 14:case 15:nl(4,p,p.return);break;case 1:Zo(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){r=p,n=p.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Iu(r,n,g)}}break;case 5:Zo(p,p.return);break;case 22:if(null!==p.memoizedState){xl(d);continue}}null!==f?(f.return=p,Jo=f):xl(d)}h=h.sibling}e:for(h=null,d=e;;){if(5===d.tag){if(null===h){h=d;try{s=d.stateNode,c?"function"===typeof(i=s.style).setProperty?i.setProperty("display","none","important"):i.display="none":(l=d.stateNode,o=void 0!==(u=d.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(g){Iu(e,e.return,g)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=c?"":d.memoizedProps}catch(g){Iu(e,e.return,g)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===e)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;null===d.sibling;){if(null===d.return||d.return===e)break e;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:ml(t,e),yl(e),4&r&&fl(e);case 21:}}function yl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(il(n)){var r=n;break e}n=n.return}throw Error(a(160))}switch(r.tag){case 5:var s=r.stateNode;32&r.flags&&(de(s,""),r.flags&=-33),ul(e,ol(e),s);break;case 3:case 4:var i=r.stateNode.containerInfo;ll(e,ol(e),i);break;default:throw Error(a(161))}}catch(o){Iu(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bl(e,t,n){Jo=e,vl(e,t,n)}function vl(e,t,n){for(var r=0!==(1&e.mode);null!==Jo;){var s=Jo,a=s.child;if(22===s.tag&&r){var i=null!==s.memoizedState||Xo;if(!i){var o=s.alternate,l=null!==o&&null!==o.memoizedState||Yo;o=Xo;var u=Yo;if(Xo=i,(Yo=l)&&!u)for(Jo=s;null!==Jo;)l=(i=Jo).child,22===i.tag&&null!==i.memoizedState?kl(s):null!==l?(l.return=i,Jo=l):kl(s);for(;null!==a;)Jo=a,vl(a,t,n),a=a.sibling;Jo=s,Xo=o,Yo=u}wl(e)}else 0!==(8772&s.subtreeFlags)&&null!==a?(a.return=s,Jo=a):wl(e)}}function wl(e){for(;null!==Jo;){var t=Jo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||rl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Yo)if(null===n)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Wa(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Wa(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var h=c.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Vt(d)}}}break;default:throw Error(a(163))}Yo||512&t.flags&&sl(t)}catch(p){Iu(t,t.return,p)}}if(t===e){Jo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Jo=n;break}Jo=t.return}}function xl(e){for(;null!==Jo;){var t=Jo;if(t===e){Jo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Jo=n;break}Jo=t.return}}function kl(e){for(;null!==Jo;){var t=Jo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{rl(4,t)}catch(l){Iu(t,n,l)}break;case 1:var r=t.stateNode;if("function"===typeof r.componentDidMount){var s=t.return;try{r.componentDidMount()}catch(l){Iu(t,s,l)}}var a=t.return;try{sl(t)}catch(l){Iu(t,a,l)}break;case 5:var i=t.return;try{sl(t)}catch(l){Iu(t,i,l)}}}catch(l){Iu(t,t.return,l)}if(t===e){Jo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Jo=o;break}Jo=t.return}}var Sl,Il=Math.ceil,Tl=w.ReactCurrentDispatcher,Nl=w.ReactCurrentOwner,El=w.ReactCurrentBatchConfig,Cl=0,_l=null,Al=null,Rl=0,$l=0,Ol=Is(0),Dl=0,Fl=null,Ll=0,Ml=0,Pl=0,zl=null,Bl=null,Ul=0,Vl=1/0,Wl=null,jl=!1,Gl=null,Hl=null,ql=!1,Kl=null,Xl=0,Yl=0,Ql=null,Jl=-1,Zl=0;function eu(){return 0!==(6&Cl)?Qe():-1!==Jl?Jl:Jl=Qe()}function tu(e){return 0===(1&e.mode)?1:0!==(2&Cl)&&0!==Rl?Rl&-Rl:null!==ma.transition?(0===Zl&&(Zl=mt()),Zl):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Yt(e.type)}function nu(e,t,n,r){if(50<Yl)throw Yl=0,Ql=null,Error(a(185));yt(e,n,r),0!==(2&Cl)&&e===_l||(e===_l&&(0===(2&Cl)&&(Ml|=n),4===Dl&&ou(e,Rl)),ru(e,r),1===n&&0===Cl&&0===(1&t.mode)&&(Vl=Qe()+500,zs&&Vs()))}function ru(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-it(a),o=1<<i,l=s[i];-1===l?0!==(o&n)&&0===(o&r)||(s[i]=pt(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}}(e,t);var r=dt(e,e===_l?Rl:0);if(0===r)null!==n&&Ke(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ke(n),1===t)0===e.tag?function(e){zs=!0,Us(e)}(lu.bind(null,e)):Us(lu.bind(null,e)),is((function(){0===(6&Cl)&&Vs()})),n=null;else{switch(wt(r)){case 1:n=Ze;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=_u(n,su.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function su(e,t){if(Jl=-1,Zl=0,0!==(6&Cl))throw Error(a(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var r=dt(e,e===_l?Rl:0);if(0===r)return null;if(0!==(30&r)||0!==(r&e.expiredLanes)||t)t=gu(e,r);else{t=r;var s=Cl;Cl|=2;var i=fu();for(_l===e&&Rl===t||(Wl=null,Vl=Qe()+500,du(e,t));;)try{bu();break}catch(l){pu(e,l)}Na(),Tl.current=i,Cl=s,null!==Al?t=0:(_l=null,Rl=0,t=Dl)}if(0!==t){if(2===t&&(0!==(s=ft(e))&&(r=s,t=au(e,s))),1===t)throw n=Fl,du(e,0),ou(e,r),ru(e,Qe()),n;if(6===t)ou(e,r);else{if(s=e.current.alternate,0===(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!or(a(),s))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(s)&&(2===(t=gu(e,r))&&(0!==(i=ft(e))&&(r=i,t=au(e,i))),1===t))throw n=Fl,du(e,0),ou(e,r),ru(e,Qe()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(a(345));case 2:case 5:xu(e,Bl,Wl);break;case 3:if(ou(e,r),(130023424&r)===r&&10<(t=Ul+500-Qe())){if(0!==dt(e,0))break;if(((s=e.suspendedLanes)&r)!==r){eu(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=rs(xu.bind(null,e,Bl,Wl),t);break}xu(e,Bl,Wl);break;case 4:if(ou(e,r),(4194240&r)===r)break;for(t=e.eventTimes,s=-1;0<r;){var o=31-it(r);i=1<<o,(o=t[o])>s&&(s=o),r&=~i}if(r=s,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Il(r/1960))-r)){e.timeoutHandle=rs(xu.bind(null,e,Bl,Wl),r);break}xu(e,Bl,Wl);break;default:throw Error(a(329))}}}return ru(e,Qe()),e.callbackNode===n?su.bind(null,e):null}function au(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(du(e,t).flags|=256),2!==(e=gu(e,t))&&(t=Bl,Bl=n,null!==t&&iu(t)),e}function iu(e){null===Bl?Bl=e:Bl.push.apply(Bl,e)}function ou(e,t){for(t&=~Pl,t&=~Ml,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function lu(e){if(0!==(6&Cl))throw Error(a(327));ku();var t=dt(e,0);if(0===(1&t))return ru(e,Qe()),null;var n=gu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=au(e,r))}if(1===n)throw n=Fl,du(e,0),ou(e,t),ru(e,Qe()),n;if(6===n)throw Error(a(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,xu(e,Bl,Wl),ru(e,Qe()),null}function uu(e,t){var n=Cl;Cl|=1;try{return e(t)}finally{0===(Cl=n)&&(Vl=Qe()+500,zs&&Vs())}}function cu(e){null!==Kl&&0===Kl.tag&&0===(6&Cl)&&ku();var t=Cl;Cl|=1;var n=El.transition,r=vt;try{if(El.transition=null,vt=1,e)return e()}finally{vt=r,El.transition=n,0===(6&(Cl=t))&&Vs()}}function hu(){$l=Ol.current,Ts(Ol)}function du(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,ss(n)),null!==Al)for(n=Al.return;null!==n;){var r=n;switch(ta(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Os();break;case 3:Ya(),Ts(_s),Ts(Cs),ni();break;case 5:Ja(r);break;case 4:Ya();break;case 13:case 19:Ts(Za);break;case 10:Ea(r.type._context);break;case 22:case 23:hu()}n=n.return}if(_l=e,Al=e=Ou(e.current,null),Rl=$l=t,Dl=0,Fl=null,Pl=Ml=Ll=0,Bl=zl=null,null!==Ra){for(t=0;t<Ra.length;t++)if(null!==(r=(n=Ra[t]).interleaved)){n.interleaved=null;var s=r.next,a=n.pending;if(null!==a){var i=a.next;a.next=s,r.next=i}n.pending=r}Ra=null}return e}function pu(e,t){for(;;){var n=Al;try{if(Na(),ri.current=Qi,ui){for(var r=ii.memoizedState;null!==r;){var s=r.queue;null!==s&&(s.pending=null),r=r.next}ui=!1}if(ai=0,li=oi=ii=null,ci=!1,hi=0,Nl.current=null,null===n||null===n.return){Dl=1,Fl=t,Al=null;break}e:{var i=e,o=n.return,l=n,u=t;if(t=Rl,l.flags|=32768,null!==u&&"object"===typeof u&&"function"===typeof u.then){var c=u,h=l,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,l,0,t),1&f.mode&&mo(i,c,t),u=c;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(0===(1&t)){mo(i,c,t),mu();break e}u=Error(a(426))}else if(sa&&1&l.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,l,0,t),fa(lo(u,l));break e}}i=u=lo(u,l),4!==Dl&&(Dl=2),null===zl?zl=[i]:zl.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Ua(i,po(0,u,t));break e;case 1:l=u;var b=i.type,v=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===Hl||!Hl.has(v)))){i.flags|=65536,t&=-t,i.lanes|=t,Ua(i,fo(i,l,t));break e}}i=i.return}while(null!==i)}wu(n)}catch(w){t=w,Al===n&&null!==n&&(Al=n=n.return);continue}break}}function fu(){var e=Tl.current;return Tl.current=Qi,null===e?Qi:e}function mu(){0!==Dl&&3!==Dl&&2!==Dl||(Dl=4),null===_l||0===(268435455&Ll)&&0===(268435455&Ml)||ou(_l,Rl)}function gu(e,t){var n=Cl;Cl|=2;var r=fu();for(_l===e&&Rl===t||(Wl=null,du(e,t));;)try{yu();break}catch(s){pu(e,s)}if(Na(),Cl=n,Tl.current=r,null!==Al)throw Error(a(261));return _l=null,Rl=0,Dl}function yu(){for(;null!==Al;)vu(Al)}function bu(){for(;null!==Al&&!Xe();)vu(Al)}function vu(e){var t=Sl(e.alternate,e,$l);e.memoizedProps=e.pendingProps,null===t?wu(e):Al=t,Nl.current=null}function wu(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,$l)))return void(Al=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(Al=n);if(null===e)return Dl=6,void(Al=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(Al=t);Al=t=e}while(null!==t);0===Dl&&(Dl=5)}function xu(e,t,n){var r=vt,s=El.transition;try{El.transition=null,vt=1,function(e,t,n,r){do{ku()}while(null!==Kl);if(0!==(6&Cl))throw Error(a(327));n=e.finishedWork;var s=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(a(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-it(n),a=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~a}}(e,i),e===_l&&(Al=_l=null,Rl=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||ql||(ql=!0,_u(tt,(function(){return ku(),null}))),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=El.transition,El.transition=null;var o=vt;vt=1;var l=Cl;Cl|=4,Nl.current=null,function(e,t){if(es=jt,pr(e=dr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var s=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(x){n=null;break e}var o=0,l=-1,u=-1,c=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==s&&3!==d.nodeType||(l=o+s),d!==i||0!==r&&3!==d.nodeType||(u=o+r),3===d.nodeType&&(o+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++c===s&&(l=o),p===i&&++h===r&&(u=o),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ts={focusedElem:e,selectionRange:n},jt=!1,Jo=t;null!==Jo;)if(e=(t=Jo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Jo=e;else for(;null!==Jo;){t=Jo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var w=t.stateNode.containerInfo;1===w.nodeType?w.textContent="":9===w.nodeType&&w.documentElement&&w.removeChild(w.documentElement);break;default:throw Error(a(163))}}catch(x){Iu(t,t.return,x)}if(null!==(e=t.sibling)){e.return=t.return,Jo=e;break}Jo=t.return}m=tl,tl=!1}(e,n),gl(n,e),fr(ts),jt=!!es,ts=es=null,e.current=n,bl(n,e,s),Ye(),Cl=l,vt=o,El.transition=i}else e.current=n;if(ql&&(ql=!1,Kl=e,Xl=s),i=e.pendingLanes,0===i&&(Hl=null),function(e){if(at&&"function"===typeof at.onCommitFiberRoot)try{at.onCommitFiberRoot(st,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),ru(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(jl)throw jl=!1,e=Gl,Gl=null,e;0!==(1&Xl)&&0!==e.tag&&ku(),i=e.pendingLanes,0!==(1&i)?e===Ql?Yl++:(Yl=0,Ql=e):Yl=0,Vs()}(e,t,n,r)}finally{El.transition=s,vt=r}return null}function ku(){if(null!==Kl){var e=wt(Xl),t=El.transition,n=vt;try{if(El.transition=null,vt=16>e?16:e,null===Kl)var r=!1;else{if(e=Kl,Kl=null,Xl=0,0!==(6&Cl))throw Error(a(331));var s=Cl;for(Cl|=4,Jo=e.current;null!==Jo;){var i=Jo,o=i.child;if(0!==(16&Jo.flags)){var l=i.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Jo=c;null!==Jo;){var h=Jo;switch(h.tag){case 0:case 11:case 15:nl(8,h,i)}var d=h.child;if(null!==d)d.return=h,Jo=d;else for(;null!==Jo;){var p=(h=Jo).sibling,f=h.return;if(al(h),h===c){Jo=null;break}if(null!==p){p.return=f,Jo=p;break}Jo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Jo=i}}if(0!==(2064&i.subtreeFlags)&&null!==o)o.return=i,Jo=o;else e:for(;null!==Jo;){if(0!==(2048&(i=Jo).flags))switch(i.tag){case 0:case 11:case 15:nl(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Jo=b;break e}Jo=i.return}}var v=e.current;for(Jo=v;null!==Jo;){var w=(o=Jo).child;if(0!==(2064&o.subtreeFlags)&&null!==w)w.return=o,Jo=w;else e:for(o=v;null!==Jo;){if(0!==(2048&(l=Jo).flags))try{switch(l.tag){case 0:case 11:case 15:rl(9,l)}}catch(k){Iu(l,l.return,k)}if(l===o){Jo=null;break e}var x=l.sibling;if(null!==x){x.return=l.return,Jo=x;break e}Jo=l.return}}if(Cl=s,Vs(),at&&"function"===typeof at.onPostCommitFiberRoot)try{at.onPostCommitFiberRoot(st,e)}catch(k){}r=!0}return r}finally{vt=n,El.transition=t}}return!1}function Su(e,t,n){e=za(e,t=po(0,t=lo(n,t),1),1),t=eu(),null!==e&&(yt(e,1,t),ru(e,t))}function Iu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Hl||!Hl.has(r))){t=za(t,e=fo(t,e=lo(n,e),1),1),e=eu(),null!==t&&(yt(t,1,e),ru(t,e));break}}t=t.return}}function Tu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=eu(),e.pingedLanes|=e.suspendedLanes&n,_l===e&&(Rl&n)===n&&(4===Dl||3===Dl&&(130023424&Rl)===Rl&&500>Qe()-Ul?du(e,0):Pl|=n),ru(e,t)}function Nu(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ct,0===(130023424&(ct<<=1))&&(ct=4194304)));var n=eu();null!==(e=Da(e,t))&&(yt(e,t,n),ru(e,n))}function Eu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Nu(e,n)}function Cu(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(a(314))}null!==r&&r.delete(t),Nu(e,n)}function _u(e,t){return qe(e,t)}function Au(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ru(e,t,n,r){return new Au(e,t,n,r)}function $u(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Ou(e,t){var n=e.alternate;return null===n?((n=Ru(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Du(e,t,n,r,s,i){var o=2;if(r=e,"function"===typeof e)$u(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Fu(n.children,s,i,t);case I:o=8,s|=8;break;case T:return(e=Ru(12,n,t,2|s)).elementType=T,e.lanes=i,e;case _:return(e=Ru(13,n,t,s)).elementType=_,e.lanes=i,e;case A:return(e=Ru(19,n,t,s)).elementType=A,e.lanes=i,e;case O:return Lu(n,s,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case E:o=9;break e;case C:o=11;break e;case R:o=14;break e;case $:o=16,r=null;break e}throw Error(a(130,null==e?e:typeof e,""))}return(t=Ru(o,n,t,s)).elementType=e,t.type=r,t.lanes=i,t}function Fu(e,t,n,r){return(e=Ru(7,e,r,t)).lanes=n,e}function Lu(e,t,n,r){return(e=Ru(22,e,r,t)).elementType=O,e.lanes=n,e.stateNode={isHidden:!1},e}function Mu(e,t,n){return(e=Ru(6,e,null,t)).lanes=n,e}function Pu(e,t,n){return(t=Ru(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Bu(e,t,n,r,s,a,i,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===a&&(t|=8)):t=0,a=Ru(3,null,null,t),e.current=a,a.stateNode=e,a.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},La(a),e}function Uu(e){if(!e)return Es;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(a(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if($s(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(a(171))}if(1===e.tag){var n=e.type;if($s(n))return Fs(e,n,t)}return t}function Vu(e,t,n,r,s,a,i,o,l){return(e=Bu(n,r,!0,e,0,a,0,o,l)).context=Uu(null),n=e.current,(a=Pa(r=eu(),s=tu(n))).callback=void 0!==t&&null!==t?t:null,za(n,a,s),e.current.lanes=s,yt(e,s,r),ru(e,r),e}function Wu(e,t,n,r){var s=t.current,a=eu(),i=tu(s);return n=Uu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Pa(a,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=za(s,t,i))&&(nu(e,s,i,a),Ba(e,s,i)),i}function ju(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Gu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Hu(e,t){Gu(e,t),(e=e.alternate)&&Gu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||_s.current)vo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return vo=!1,function(e,t,n){switch(t.tag){case 3:_o(t),pa();break;case 5:Qa(t);break;case 1:$s(t.type)&&Ls(t);break;case 4:Xa(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;Ns(ka,r._currentValue),r._currentValue=s;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Ns(Za,1&Za.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Mo(e,t,n):(Ns(Za,1&Za.current),null!==(e=jo(e,t,n))?e.sibling:null);Ns(Za,1&Za.current);break;case 19:if(r=0!==(n&t.childLanes),0!==(128&e.flags)){if(r)return Vo(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),Ns(Za,Za.current),r)break;return null;case 22:case 23:return t.lanes=0,Io(e,t,n)}return jo(e,t,n)}(e,t,n);vo=0!==(131072&e.flags)}else vo=!1,sa&&0!==(1048576&t.flags)&&Zs(t,Hs,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Wo(e,t),e=t.pendingProps;var s=Rs(t,Cs.current);_a(t,n),s=mi(null,t,r,e,s,n);var i=gi();return t.flags|=1,"object"===typeof s&&null!==s&&"function"===typeof s.render&&void 0===s.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,$s(r)?(i=!0,Ls(t)):i=!1,t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,La(t),s.updater=ro,t.stateNode=s,s._reactInternals=t,oo(t,r,e,n),t=Co(null,t,r,!0,i,n)):(t.tag=0,sa&&i&&ea(t),wo(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Wo(e,t),e=t.pendingProps,r=(s=r._init)(r._payload),t.type=r,s=t.tag=function(e){if("function"===typeof e)return $u(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===C)return 11;if(e===R)return 14}return 2}(r),e=to(r,e),s){case 0:t=No(null,t,r,e,n);break e;case 1:t=Eo(null,t,r,e,n);break e;case 11:t=xo(null,t,r,e,n);break e;case 14:t=ko(null,t,r,to(r.type,e),n);break e}throw Error(a(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,No(e,t,r,s=t.elementType===r?s:to(r,s),n);case 1:return r=t.type,s=t.pendingProps,Eo(e,t,r,s=t.elementType===r?s:to(r,s),n);case 3:e:{if(_o(t),null===e)throw Error(a(387));r=t.pendingProps,s=(i=t.memoizedState).element,Ma(e,t),Va(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=Ao(e,t,r,n,s=lo(Error(a(423)),t));break e}if(r!==s){t=Ao(e,t,r,n,s=lo(Error(a(424)),t));break e}for(ra=us(t.stateNode.containerInfo.firstChild),na=t,sa=!0,aa=null,n=xa(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pa(),r===s){t=jo(e,t,n);break e}wo(e,t,r,n)}t=t.child}return t;case 5:return Qa(t),null===e&&ua(t),r=t.type,s=t.pendingProps,i=null!==e?e.memoizedProps:null,o=s.children,ns(r,s)?o=null:null!==i&&ns(r,i)&&(t.flags|=32),To(e,t),wo(e,t,o,n),t.child;case 6:return null===e&&ua(t),null;case 13:return Mo(e,t,n);case 4:return Xa(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=wa(t,null,r,n):wo(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,xo(e,t,r,s=t.elementType===r?s:to(r,s),n);case 7:return wo(e,t,t.pendingProps,n),t.child;case 8:case 12:return wo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,i=t.memoizedProps,o=s.value,Ns(ka,r._currentValue),r._currentValue=o,null!==i)if(or(i.value,o)){if(i.children===s.children&&!_s.current){t=jo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var l=i.dependencies;if(null!==l){o=i.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===i.tag){(u=Pa(-1,n&-n)).tag=2;var c=i.updateQueue;if(null!==c){var h=(c=c.shared).pending;null===h?u.next=u:(u.next=h.next,h.next=u),c.pending=u}}i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),Ca(i.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(a(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),Ca(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}wo(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,_a(t,n),r=r(s=Aa(s)),t.flags|=1,wo(e,t,r,n),t.child;case 14:return s=to(r=t.type,t.pendingProps),ko(e,t,r,s=to(r.type,s),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:to(r,s),Wo(e,t),t.tag=1,$s(r)?(e=!0,Ls(t)):e=!1,_a(t,n),ao(t,r,s),oo(t,r,s,n),Co(null,t,r,!0,e,n);case 19:return Vo(e,t,n);case 22:return Io(e,t,n)}throw Error(a(156,t.tag))};var qu="function"===typeof reportError?reportError:function(e){console.error(e)};function Ku(e){this._internalRoot=e}function Xu(e){this._internalRoot=e}function Yu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Ju(){}function Zu(e,t,n,r,s){var a=n._reactRootContainer;if(a){var i=a;if("function"===typeof s){var o=s;s=function(){var e=ju(i);o.call(e)}}Wu(t,i,e,s)}else i=function(e,t,n,r,s){if(s){if("function"===typeof r){var a=r;r=function(){var e=ju(i);a.call(e)}}var i=Vu(t,r,e,0,null,!1,0,"",Ju);return e._reactRootContainer=i,e[fs]=i.current,Vr(8===e.nodeType?e.parentNode:e),cu(),i}for(;s=e.lastChild;)e.removeChild(s);if("function"===typeof r){var o=r;r=function(){var e=ju(l);o.call(e)}}var l=Bu(e,0,!1,null,0,!1,0,"",Ju);return e._reactRootContainer=l,e[fs]=l.current,Vr(8===e.nodeType?e.parentNode:e),cu((function(){Wu(t,l,n,r)})),l}(n,t,e,s,r);return ju(i)}Xu.prototype.render=Ku.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(a(409));Wu(e,t,null,null)},Xu.prototype.unmount=Ku.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;cu((function(){Wu(null,e,null,null)})),t[fs]=null}},Xu.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ot.length&&0!==t&&t<Ot[n].priority;n++);Ot.splice(n,0,e),0===n&&Mt(e)}},xt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=ht(t.pendingLanes);0!==n&&(bt(t,1|n),ru(t,Qe()),0===(6&Cl)&&(Vl=Qe()+500,Vs()))}break;case 13:cu((function(){var t=Da(e,1);if(null!==t){var n=eu();nu(t,e,1,n)}})),Hu(e,1)}},kt=function(e){if(13===e.tag){var t=Da(e,134217728);if(null!==t)nu(t,e,134217728,eu());Hu(e,134217728)}},St=function(e){if(13===e.tag){var t=tu(e),n=Da(e,t);if(null!==n)nu(n,e,t,eu());Hu(e,t)}},It=function(){return vt},Tt=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=xs(r);if(!s)throw Error(a(90));q(r),J(r,s)}}}break;case"textarea":ae(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ce=uu,_e=cu;var ec={usingClientEntryPoint:!1,Events:[vs,ws,xs,Ne,Ee,uu]},tc={findFiberByHostInstance:bs,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nc={bundleType:tc.bundleType,version:tc.version,rendererPackageName:tc.rendererPackageName,rendererConfig:tc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:w.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:tc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rc.isDisabled&&rc.supportsFiber)try{st=rc.inject(nc),at=rc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ec,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yu(t))throw Error(a(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yu(e))throw Error(a(299));var n=!1,r="",s=qu;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(s=t.onRecoverableError)),t=Bu(e,1,!1,null,0,n,0,r,s),e[fs]=t.current,Vr(8===e.nodeType?e.parentNode:e),new Ku(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(a(188));throw e=Object.keys(e).join(","),Error(a(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return cu(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(a(200));return Zu(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yu(e))throw Error(a(405));var r=null!=n&&n.hydratedSources||null,s=!1,i="",o=qu;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(s=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Vu(t,null,e,1,null!=n?n:null,s,0,i,o),e[fs]=t.current,Vr(e),r)for(e=0;e<r.length;e++)s=(s=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new Xu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(a(200));return Zu(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(a(40));return!!e._reactRootContainer&&(cu((function(){Zu(null,null,e,!1,(function(){e._reactRootContainer=null,e[fs]=null}))})),!0)},t.unstable_batchedUpdates=uu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qu(n))throw Error(a(200));if(null==e||void 0===e._reactInternals)throw Error(a(38));return Zu(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},4391:(e,t,n)=>{"use strict";var r=n(7950);t.createRoot=r.createRoot,t.hydrateRoot=r.hydrateRoot},7950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(2730)},1153:(e,t,n)=>{"use strict";var r=n(5043),s=Symbol.for("react.element"),a=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,a={},u=null,c=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(c=t.ref),t)i.call(t,r)&&!l.hasOwnProperty(r)&&(a[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===a[r]&&(a[r]=t[r]);return{$$typeof:s,type:e,key:u,ref:c,props:a,_owner:o.current}}t.Fragment=a,t.jsx=u,t.jsxs=u},4202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var w=v.prototype=new b;w.constructor=v,m(w,y.prototype),w.isPureReactComponent=!0;var x=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function T(e,t,r){var s,a={},i=null,o=null;if(null!=t)for(s in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,s)&&!I.hasOwnProperty(s)&&(a[s]=t[s]);var l=arguments.length-2;if(1===l)a.children=r;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];a.children=u}if(e&&e.defaultProps)for(s in l=e.defaultProps)void 0===a[s]&&(a[s]=l[s]);return{$$typeof:n,type:e,key:i,ref:o,props:a,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var E=/\/+/g;function C(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function _(e,t,s,a,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return i=i(l=e),e=""===a?"."+C(l,0):a,x(i)?(s="",null!=e&&(s=e.replace(E,"$&/")+"/"),_(i,t,s,"",(function(e){return e}))):null!=i&&(N(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,s+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(E,"$&/")+"/")+e)),t.push(i)),1;if(l=0,a=""===a?".":a+":",x(e))for(var u=0;u<e.length;u++){var c=a+C(o=e[u],u);l+=_(o,t,s,c,i)}else if(c=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=_(o=o.value,t,s,c=a+C(o,u++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function A(e,t,n){if(null==e)return e;var r=[],s=0;return _(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function R(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var $={current:null},O={transition:null},D={ReactCurrentDispatcher:$,ReactCurrentBatchConfig:O,ReactCurrentOwner:S};function F(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:A,forEach:function(e,t,n){A(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return A(e,(function(){t++})),t},toArray:function(e){return A(e,(function(e){return e}))||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=s,t.Profiler=i,t.PureComponent=v,t.StrictMode=a,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=F,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=m({},e.props),a=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(a=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(s[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)s.children=r;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];s.children=l}return{$$typeof:n,type:e.type,key:a,ref:i,props:s,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=T,t.createFactory=function(e){var t=T.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:R}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=O.transition;O.transition={};try{e()}finally{O.transition=t}},t.unstable_act=F,t.useCallback=function(e,t){return $.current.useCallback(e,t)},t.useContext=function(e){return $.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return $.current.useDeferredValue(e)},t.useEffect=function(e,t){return $.current.useEffect(e,t)},t.useId=function(){return $.current.useId()},t.useImperativeHandle=function(e,t,n){return $.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return $.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return $.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return $.current.useMemo(e,t)},t.useReducer=function(e,t,n){return $.current.useReducer(e,t,n)},t.useRef=function(e){return $.current.useRef(e)},t.useState=function(e){return $.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return $.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return $.current.useTransition()},t.version="18.3.1"},5043:(e,t,n)=>{"use strict";e.exports=n(4202)},579:(e,t,n)=>{"use strict";e.exports=n(1153)},7234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,s=e[r];if(!(0<a(s,t)))break e;e[r]=t,e[n]=s,n=r}}function r(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,s=e.length,i=s>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>a(l,n))u<s&&0>a(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<s&&0>a(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function a(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],h=1,d=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function w(e){for(var t=r(c);null!==t;){if(null===t.callback)s(c);else{if(!(t.startTime<=e))break;s(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function x(e){if(g=!1,w(e),!m)if(null!==r(u))m=!0,O(k);else{var t=r(c);null!==t&&D(x,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(N),N=-1),f=!0;var a=p;try{for(w(n),d=r(u);null!==d&&(!(d.expirationTime>n)||e&&!_());){var i=d.callback;if("function"===typeof i){d.callback=null,p=d.priorityLevel;var o=i(d.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?d.callback=o:d===r(u)&&s(u),w(n)}else s(u);d=r(u)}if(null!==d)var l=!0;else{var h=r(c);null!==h&&D(x,h.startTime-n),l=!1}return l}finally{d=null,p=a,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,T=null,N=-1,E=5,C=-1;function _(){return!(t.unstable_now()-C<E)}function A(){if(null!==T){var e=t.unstable_now();C=e;var n=!0;try{n=T(!0,e)}finally{n?S():(I=!1,T=null)}}else I=!1}if("function"===typeof v)S=function(){v(A)};else if("undefined"!==typeof MessageChannel){var R=new MessageChannel,$=R.port2;R.port1.onmessage=A,S=function(){$.postMessage(null)}}else S=function(){y(A,0)};function O(e){T=e,I||(I=!0,S())}function D(e,n){N=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,O(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,a){var i=t.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:h++,callback:s,priorityLevel:e,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>i?(e.sortIndex=a,n(c,e),null===r(u)&&e===r(c)&&(g?(b(N),N=-1):g=!0,D(x,a-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,O(k))),e},t.unstable_shouldYield=_,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},8853:(e,t,n)=>{"use strict";e.exports=n(7234)},4334:(e,t,n)=>{var r=n(7359),s=n(7066),a=n(9016),i=n(9538),o=n(6288),l=n(5262),u=n(2430);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},7359:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},5262:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},7066:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},6288:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},9538:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},9016:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},2430:function(e,t,n){var r;!function(s,a,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(a)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=d&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*l+i[d&(i[s]=i[a=d&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),a),e.exports){e.exports=p;try{o=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},6884:(e,t,n)=>{const r=n(7346);e.exports={recognize:async(e,t,n)=>{const s=await r(t,1,n);return s.recognize(e).finally((async()=>{await s.terminate()}))},detect:async(e,t)=>{const n=await r("osd",0,t);return n.detect(e).finally((async()=>{await n.terminate()}))}}},9511:e=>{e.exports={TESSERACT_ONLY:0,LSTM_ONLY:1,TESSERACT_LSTM_COMBINED:2,DEFAULT:3}},4588:e=>{e.exports={OSD_ONLY:"0",AUTO_OSD:"1",AUTO_ONLY:"2",AUTO:"3",SINGLE_COLUMN:"4",SINGLE_BLOCK_VERT_TEXT:"5",SINGLE_BLOCK:"6",SINGLE_LINE:"7",SINGLE_WORD:"8",CIRCLE_WORD:"9",SINGLE_CHAR:"10",SPARSE_TEXT:"11",SPARSE_TEXT_OSD:"12",RAW_LINE:"13"}},5147:e=>{e.exports={workerBlobURL:!0,logger:()=>{}}},5571:e=>{e.exports={AFR:"afr",AMH:"amh",ARA:"ara",ASM:"asm",AZE:"aze",AZE_CYRL:"aze_cyrl",BEL:"bel",BEN:"ben",BOD:"bod",BOS:"bos",BUL:"bul",CAT:"cat",CEB:"ceb",CES:"ces",CHI_SIM:"chi_sim",CHI_TRA:"chi_tra",CHR:"chr",CYM:"cym",DAN:"dan",DEU:"deu",DZO:"dzo",ELL:"ell",ENG:"eng",ENM:"enm",EPO:"epo",EST:"est",EUS:"eus",FAS:"fas",FIN:"fin",FRA:"fra",FRK:"frk",FRM:"frm",GLE:"gle",GLG:"glg",GRC:"grc",GUJ:"guj",HAT:"hat",HEB:"heb",HIN:"hin",HRV:"hrv",HUN:"hun",IKU:"iku",IND:"ind",ISL:"isl",ITA:"ita",ITA_OLD:"ita_old",JAV:"jav",JPN:"jpn",KAN:"kan",KAT:"kat",KAT_OLD:"kat_old",KAZ:"kaz",KHM:"khm",KIR:"kir",KOR:"kor",KUR:"kur",LAO:"lao",LAT:"lat",LAV:"lav",LIT:"lit",MAL:"mal",MAR:"mar",MKD:"mkd",MLT:"mlt",MSA:"msa",MYA:"mya",NEP:"nep",NLD:"nld",NOR:"nor",ORI:"ori",PAN:"pan",POL:"pol",POR:"por",PUS:"pus",RON:"ron",RUS:"rus",SAN:"san",SIN:"sin",SLK:"slk",SLV:"slv",SPA:"spa",SPA_OLD:"spa_old",SQI:"sqi",SRP:"srp",SRP_LATN:"srp_latn",SWA:"swa",SWE:"swe",SYR:"syr",TAM:"tam",TEL:"tel",TGK:"tgk",TGL:"tgl",THA:"tha",TIR:"tir",TUR:"tur",UIG:"uig",UKR:"ukr",URD:"urd",UZB:"uzb",UZB_CYRL:"uzb_cyrl",VIE:"vie",YID:"yid"}},5701:(e,t,n)=>{const r=n(9593);let s=0;e.exports=e=>{let{id:t,action:n,payload:a={}}=e,i=t;return"undefined"===typeof i&&(i=r("Job",s),s+=1),{id:i,action:n,payload:a}}},4447:function(e,t,n){const r=n(5701),{log:s}=n(9926),a=n(9593);let i=0;e.exports=()=>{const e=a("Scheduler",i),t={},n={};let o=[];i+=1;const l=()=>Object.keys(t).length,u=()=>{if(0!==o.length){const e=Object.keys(t);for(let r=0;r<e.length;r+=1)if("undefined"===typeof n[e[r]]){o[0](t[e[r]]);break}}},c=(t,a)=>new Promise(((i,l)=>{const c=r({action:t,payload:a});o.push((async e=>{o.shift(),n[e.id]=c;try{i(await e[t].apply(this,[...a,c.id]))}catch(r){l(r)}finally{delete n[e.id],u()}})),s(`[${e}]: Add ${c.id} to JobQueue`),s(`[${e}]: JobQueue length=${o.length}`),u()}));return{addWorker:n=>(t[n.id]=n,s(`[${e}]: Add ${n.id}`),s(`[${e}]: Number of workers=${l()}`),u(),n.id),addJob:async function(t){if(0===l())throw Error(`[${e}]: You need to have at least one worker before adding jobs`);for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return c(t,r)},terminate:async()=>{Object.keys(t).forEach((async e=>{await t[e].terminate()})),o=[]},getQueueLen:()=>o.length,getNumWorkers:l}}},7346:(e,t,n)=>{const r=n(4402),s=n(3057),a=n(5701),{log:i}=n(9926),o=n(9593),l=n(9511),{defaultOptions:u,spawnWorker:c,terminateWorker:h,onMessage:d,loadImage:p,send:f}=n(2034);let m=0;e.exports=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"eng",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.LSTM_ONLY,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const y=o("Worker",m),{logger:b,errorHandler:v,...w}=r({...u,...n}),x={},k={},S="string"===typeof e?e.split("+"):e;let I=t,T=g;const N=[l.DEFAULT,l.LSTM_ONLY].includes(t)&&!w.legacyCore;let E,C;const _=new Promise(((e,t)=>{C=e,E=t}));let A=c(w);A.onerror=e=>{E(e.message)},m+=1;const R=(e,t)=>{x[e]=t},$=(e,t)=>{k[e]=t},O=e=>{let{id:t,action:n,payload:r}=e;return new Promise(((e,s)=>{i(`[${y}]: Start ${t}, action=${n}`);const a=`${n}-${t}`;R(a,e),$(a,s),f(A,{workerId:y,jobId:t,action:n,payload:r})}))},D=(e,t)=>O(a({id:t,action:"loadLanguage",payload:{langs:e,options:{langPath:w.langPath,dataPath:w.dataPath,cachePath:w.cachePath,cacheMethod:w.cacheMethod,gzip:w.gzip,lstmOnly:[l.DEFAULT,l.LSTM_ONLY].includes(I)&&!w.legacyLang}}})),F=(e,t,n,r)=>O(a({id:r,action:"initialize",payload:{langs:e,oem:t,config:n}}));d(A,(e=>{let{workerId:t,jobId:n,status:r,action:a,data:o}=e;const l=`${a}-${n}`;if("resolve"===r){i(`[${t}]: Complete ${n}`);let e=o;"recognize"===a?e=s(o):"getPDF"===a&&(e=Array.from({...o,length:Object.keys(o).length})),x[l]({jobId:n,data:e})}else if("reject"===r){if(k[l](o),"load"===a&&E(o),!v)throw Error(o);v(o)}else"progress"===r&&b({...o,userJobId:n})}));const L={id:y,worker:A,setResolve:R,setReject:$,load:()=>console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)"),writeText:(e,t,n)=>O(a({id:n,action:"FS",payload:{method:"writeFile",args:[e,t]}})),readText:(e,t)=>O(a({id:t,action:"FS",payload:{method:"readFile",args:[e,{encoding:"utf8"}]}})),removeFile:(e,t)=>O(a({id:t,action:"FS",payload:{method:"unlink",args:[e]}})),FS:(e,t,n)=>O(a({id:n,action:"FS",payload:{method:e,args:t}})),loadLanguage:()=>console.warn("`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)"),initialize:()=>console.warn("`initialize` is depreciated and should be removed from code (workers now come pre-initialized)"),reinitialize:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"eng",t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(N&&[l.TESSERACT_ONLY,l.TESSERACT_LSTM_COMBINED].includes(t))throw Error("Legacy model requested but code missing.");const s=t||I;I=s;const a=n||T;T=a;const i=("string"===typeof e?e.split("+"):e).filter((e=>!S.includes(e)));return S.push(...i),i.length>0?D(i,r).then((()=>F(e,s,a,r))):F(e,s,a,r)},setParameters:function(){return O(a({id:arguments.length>1?arguments[1]:void 0,action:"setParameters",payload:{params:arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}}}))},recognize:async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{blocks:!0,text:!0,hocr:!0,tsv:!0};return O(a({id:arguments.length>3?arguments[3]:void 0,action:"recognize",payload:{image:await p(e),options:t,output:n}}))},getPDF:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Tesseract OCR Result",t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;return console.log("`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead."),O(a({id:n,action:"getPDF",payload:{title:e,textonly:t}}))},detect:async(e,t)=>{if(N)throw Error("`worker.detect` requires Legacy model, which was not loaded.");return O(a({id:t,action:"detect",payload:{image:await p(e)}}))},terminate:async()=>(null!==A&&(h(A),A=null),Promise.resolve())};var M;return O(a({id:M,action:"load",payload:{options:{lstmOnly:N,corePath:w.corePath,logging:w.logging}}})).then((()=>D(e))).then((()=>F(e,t,g))).then((()=>C(L))).catch((()=>{})),_}},9938:(e,t,n)=>{const r=n(4447),s=n(7346),a=n(6884),i=n(5571),o=n(9511),l=n(4588),{setLogging:u}=n(9926);e.exports={languages:i,OEM:o,PSM:l,createScheduler:r,createWorker:s,setLogging:u,...a}},3057:e=>{e.exports=e=>{const t=[],n=[],r=[],s=[],a=[];return e.blocks&&e.blocks.forEach((i=>{i.paragraphs.forEach((t=>{t.lines.forEach((n=>{n.words.forEach((r=>{r.symbols.forEach((s=>{a.push({...s,page:e,block:i,paragraph:t,line:n,word:r})})),s.push({...r,page:e,block:i,paragraph:t,line:n})})),r.push({...n,page:e,block:i,paragraph:t})})),n.push({...t,page:e,block:i})})),t.push({...i,page:e})})),{...e,blocks:t,paragraphs:n,lines:r,words:s,symbols:a}}},9003:(e,t,n)=>{const r=n(4053);e.exports=e=>{const t={};return"undefined"!==typeof WorkerGlobalScope?t.type="webworker":r()?t.type="electron":"object"===typeof document?t.type="browser":"object"===typeof process&&(t.type="node"),"undefined"===typeof e?t:t[e]}},9593:e=>{e.exports=(e,t)=>`${e}-${t}-${Math.random().toString(16).slice(3,8)}`},9926:function(e,t){var n=this;let r=!1;t.logging=r,t.setLogging=e=>{r=e},t.log=function(){for(var e=arguments.length,t=new Array(e),s=0;s<e;s++)t[s]=arguments[s];return r?console.log.apply(n,t):null}},4402:(e,t,n)=>{const r="browser"===n(9003)("type")?e=>new URL(e,window.location.href).href:e=>e;e.exports=e=>{const t={...e};return["corePath","workerPath","langPath"].forEach((n=>{e[n]&&(t[n]=r(t[n]))})),t}},1597:(e,t,n)=>{const r=n(6125).rE,s=n(5147);e.exports={...s,workerPath:`https://cdn.jsdelivr.net/npm/tesseract.js@v${r}/dist/worker.min.js`}},2034:(e,t,n)=>{const r=n(1597),s=n(5095),a=n(4871),i=n(1942),o=n(7870),l=n(383);e.exports={defaultOptions:r,spawnWorker:s,terminateWorker:a,onMessage:i,send:o,loadImage:l}},383:e=>{const t=e=>new Promise(((t,n)=>{const r=new FileReader;r.onload=()=>{t(r.result)},r.onerror=e=>{let{target:{error:{code:t}}}=e;n(Error(`File could not be read! Code=${t}`))},r.readAsArrayBuffer(e)})),n=async e=>{let r=e;if("undefined"===typeof e)return"undefined";if("string"===typeof e)if(/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(e))r=atob(e.split(",")[1]).split("").map((e=>e.charCodeAt(0)));else{const t=await fetch(e);r=await t.arrayBuffer()}else if("undefined"!==typeof HTMLElement&&e instanceof HTMLElement)"IMG"===e.tagName&&(r=await n(e.src)),"VIDEO"===e.tagName&&(r=await n(e.poster)),"CANVAS"===e.tagName&&await new Promise((n=>{e.toBlob((async e=>{r=await t(e),n()}))}));else if("undefined"!==typeof OffscreenCanvas&&e instanceof OffscreenCanvas){const n=await e.convertToBlob();r=await t(n)}else(e instanceof File||e instanceof Blob)&&(r=await t(e));return new Uint8Array(r)};e.exports=n},1942:e=>{e.exports=(e,t)=>{e.onmessage=e=>{let{data:n}=e;t(n)}}},7870:e=>{e.exports=async(e,t)=>{e.postMessage(t)}},5095:e=>{e.exports=e=>{let t,{workerPath:n,workerBlobURL:r}=e;if(Blob&&URL&&r){const e=new Blob([`importScripts("${n}");`],{type:"application/javascript"});t=new Worker(URL.createObjectURL(e))}else t=new Worker(n);return t}},4871:e=>{e.exports=e=>{e.terminate()}},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},1234:()=>{},4634:e=>{function t(){return e.exports=t=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},e.exports.__esModule=!0,e.exports.default=e.exports,t.apply(null,arguments)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports},4994:e=>{e.exports=function(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},4893:e=>{e.exports=function(e,t){if(null==e)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.includes(r))continue;n[r]=e[r]}return n},e.exports.__esModule=!0,e.exports.default=e.exports},8168:(e,t,n)=>{"use strict";function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},r.apply(null,arguments)}n.d(t,{A:()=>r})},8587:(e,t,n)=>{"use strict";function r(e,t){if(null==e)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.includes(r))continue;n[r]=e[r]}return n}n.d(t,{A:()=>r})},6125:e=>{"use strict";e.exports={rE:"5.1.1"}}},t={};function n(r){var s=t[r];if(void 0!==s)return s.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(r,s){if(1&s&&(r=this(r)),8&s)return r;if("object"===typeof r&&r){if(4&s&&r.__esModule)return r;if(16&s&&"function"===typeof r.then)return r}var a=Object.create(null);n.r(a);var i={};e=e||[null,t({}),t([]),t(t)];for(var o=2&s&&r;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>i[e]=()=>r[e]));return i.default=()=>r,n.d(a,i),a}})(),n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{hasBrowserEnv:()=>Cg,hasStandardBrowserEnv:()=>Ag,hasStandardBrowserWebWorkerEnv:()=>Rg,navigator:()=>_g,origin:()=>$g});var t={};n.r(t),n.d(t,{CompositeArrayBuffer:()=>jS,browserFiles:()=>PT,browserHTTPRequest:()=>qT,concatenateArrayBuffers:()=>uI,copyModel:()=>KI,decodeWeights:()=>eI,decodeWeightsStream:()=>aI,encodeWeights:()=>ZS,fromMemory:()=>QT,fromMemorySync:()=>JT,getLoadHandlers:()=>wI,getModelArtifactsForJSON:()=>pI,getModelArtifactsForJSONSync:()=>dI,getModelArtifactsInfoForJSON:()=>fI,getSaveHandlers:()=>vI,getWeightSpecs:()=>mI,http:()=>HT,isHTTPScheme:()=>jT,listModels:()=>HI,loadWeights:()=>UT,moveModel:()=>XI,registerLoadRouter:()=>bI,registerSaveRouter:()=>yI,removeModel:()=>qI,weightsLoaderFactory:()=>VT,withSaveHandler:()=>ZT,withSaveHandlerSync:()=>eN});var r={};n.r(r),n.d(r,{assertParamsValid:()=>oN,computeFlatOffset:()=>wN,computeOutShape:()=>uN,getNormalizedAxes:()=>pN,isSliceContinous:()=>vN,maskToAxes:()=>lN,parseSliceParams:()=>xN,sliceInfo:()=>kN,startForAxis:()=>yN,startIndicesWithElidedDims:()=>fN,stopForAxis:()=>bN,stopIndicesWithElidedDims:()=>mN,stridesForAxis:()=>gN,stridesWithElidedDims:()=>cN});var s={};n.r(s),n.d(s,{conv2d:()=>FA,depthwiseConv2d:()=>PA,matMul:()=>zA});var a={};n.r(a),n.d(a,{collectGatherOpShapeInfo:()=>Y$,computeOutShape:()=>X$,segOpComputeOptimalWindowSize:()=>K$});var i={};n.r(i),n.d(i,{ERF_A1:()=>d$,ERF_A2:()=>p$,ERF_A3:()=>f$,ERF_A4:()=>m$,ERF_A5:()=>g$,ERF_P:()=>h$,PARALLELIZE_THRESHOLD:()=>e$,RowPartitionType:()=>XR,SELU_SCALE:()=>c$,SELU_SCALEALPHA:()=>u$,applyActivation:()=>OA,assertAndGetBroadcastShape:()=>CT,assertAxesAreInnerMostDims:()=>XE,assertParamsConsistent:()=>qR,assignToTypedArray:()=>k$,axesAreInnerMostDims:()=>GE,calculateShapes:()=>uA,checkEinsumDimSizes:()=>R$,checkPadOnDimRoundingMode:()=>YN,combineLocations:()=>HE,combineRaggedTensorToTensorShapes:()=>YR,complexWithEvenIndex:()=>v$,complexWithOddIndex:()=>w$,computeConv2DInfo:()=>zN,computeConv3DInfo:()=>BN,computeDefaultPad:()=>UN,computeDilation2DInfo:()=>LN,computeOptimalWindowSize:()=>t$,computeOutAndReduceShapes:()=>qE,computeOutShape:()=>KR,computePool2DInfo:()=>MN,computePool3DInfo:()=>PN,convertConv2DDataFormat:()=>XN,decodeEinsumEquation:()=>_$,eitherStridesOrDilationsAreOne:()=>qN,expandShapeToKeepDim:()=>KE,exponent:()=>I$,exponents:()=>S$,fromStringArrayToUint8:()=>J$,fromUint8ToStringArray:()=>Q$,getAxesPermutation:()=>YE,getBroadcastDims:()=>NT,getComplexWithIndex:()=>x$,getEinsumComputePath:()=>$$,getEinsumPermutation:()=>A$,getFusedBiasGradient:()=>$A,getFusedDyActivation:()=>RA,getImageCenter:()=>n$,getInnerMostAxes:()=>JE,getPermuted:()=>s$,getRaggedRank:()=>JR,getReductionAxes:()=>ET,getReshaped:()=>r$,getReshapedPermuted:()=>a$,getRowPartitionTypesHelper:()=>QR,getSliceBeginCoords:()=>i$,getSliceSize:()=>o$,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>L$,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>M$,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>P$,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>U$,getSparseReshapeInputOutputMismatchErrorMessage:()=>W$,getSparseReshapeInputOutputMultipleErrorMessage:()=>V$,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>z$,getSparseReshapeNegativeOutputDimErrorMessage:()=>B$,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>q$,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>j$,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>G$,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>H$,getUndoAxesPermutation:()=>QE,isIdentityPermutation:()=>O$,log:()=>yk,mergeRealAndImagArrays:()=>y$,prepareAndValidate:()=>l$,prepareSplitSize:()=>F$,segment_util:()=>a,shouldFuse:()=>DA,slice_util:()=>r,splitRealAndImagArrays:()=>b$,stridesOrDilationsArePositive:()=>KN,tupleValuesAreOne:()=>HN,upcastType:()=>mS,validateDefaultValueShape:()=>ZR,validateInput:()=>lA,validateUpdateShape:()=>oA,warn:()=>gk});var o={};n.r(o),n.d(o,{json:()=>GB});var l={};n.r(l),n.d(l,{json:()=>HB});var u={};n.r(u),n.d(u,{json:()=>qB});var c={};n.r(c),n.d(c,{json:()=>KB});var h={};n.r(h),n.d(h,{json:()=>XB});var d={};n.r(d),n.d(d,{json:()=>YB});var p={};n.r(p),n.d(p,{json:()=>QB});var f={};n.r(f),n.d(f,{json:()=>JB});var m={};n.r(m),n.d(m,{json:()=>ZB});var g={};n.r(g),n.d(g,{json:()=>eU});var y={};n.r(y),n.d(y,{json:()=>tU});var b={};n.r(b),n.d(b,{json:()=>nU});var v={};n.r(v),n.d(v,{json:()=>rU});var w={};n.r(w),n.d(w,{json:()=>sU});var x={};n.r(x),n.d(x,{json:()=>aU});var k={};n.r(k),n.d(k,{json:()=>iU});var S={};n.r(S),n.d(S,{json:()=>oU});var I={};n.r(I),n.d(I,{json:()=>lU});var T={};n.r(T),n.d(T,{json:()=>uU});var N={};n.r(N),n.d(N,{OP_SCOPE_SUFFIX:()=>PS,abs:()=>TT,acos:()=>IN,acosh:()=>TN,add:()=>sT,addN:()=>NN,all:()=>EN,any:()=>CN,argMax:()=>_N,argMin:()=>AN,asin:()=>RN,asinh:()=>$N,atan:()=>ON,atan2:()=>DN,atanh:()=>FN,avgPool:()=>JN,avgPool3d:()=>ZN,basicLSTMCell:()=>aE,batchNorm:()=>oE,batchNorm2d:()=>lE,batchNorm3d:()=>uE,batchNorm4d:()=>cE,batchToSpaceND:()=>iE,bincount:()=>hE,bitwiseAnd:()=>dE,booleanMaskAsync:()=>wA,broadcastArgs:()=>pE,broadcastTo:()=>fE,buffer:()=>eT,cast:()=>tT,ceil:()=>mE,clipByValue:()=>gE,clone:()=>nT,complex:()=>BS,concat:()=>eE,concat1d:()=>yE,concat2d:()=>bE,concat3d:()=>vE,concat4d:()=>wE,conv1d:()=>kE,conv2d:()=>xE,conv2dTranspose:()=>IE,conv3d:()=>TE,conv3dTranspose:()=>EE,cos:()=>CE,cosh:()=>_E,cosineWindow:()=>CA,cumprod:()=>AE,cumsum:()=>RE,denseBincount:()=>$E,depthToSpace:()=>OE,depthwiseConv2d:()=>DE,diag:()=>FE,dilation2d:()=>LE,div:()=>iT,divNoNan:()=>zE,dot:()=>BE,dropout:()=>NA,einsum:()=>UE,elu:()=>VE,enclosingPowerOfTwo:()=>EA,ensureShape:()=>WE,equal:()=>ME,erf:()=>jE,euclideanNorm:()=>sC,exp:()=>aC,expandDims:()=>iC,expm1:()=>oC,eye:()=>uC,fft:()=>G_,fill:()=>wT,floor:()=>cC,floorDiv:()=>aT,fused:()=>s,gather:()=>hC,gatherND:()=>TA,greater:()=>dC,greaterEqual:()=>pC,ifft:()=>H_,imag:()=>fC,image:()=>zR,inTopKAsync:()=>_A,irfft:()=>q_,isFinite:()=>mC,isInf:()=>gC,isNaN:()=>yC,leakyRelu:()=>bC,less:()=>vC,lessEqual:()=>wC,linalg:()=>BR,linspace:()=>xC,localResponseNormalization:()=>kC,log:()=>SC,log1p:()=>IC,logSigmoid:()=>EC,logSoftmax:()=>CC,logSumExp:()=>_C,logicalAnd:()=>AC,logicalNot:()=>RC,logicalOr:()=>$C,logicalXor:()=>OC,losses:()=>UR,lowerBound:()=>LC,matMul:()=>tE,max:()=>ZE,maxPool:()=>MC,maxPool3d:()=>PC,maxPoolWithArgmax:()=>zC,maximum:()=>_T,mean:()=>BC,meshgrid:()=>WC,min:()=>eC,minimum:()=>jC,mirrorPad:()=>GC,mod:()=>HC,moments:()=>qC,movingAverage:()=>kA,mul:()=>oT,multiRNNCell:()=>KC,multinomial:()=>XC,neg:()=>TC,norm:()=>rC,notEqual:()=>YC,oneHot:()=>QC,ones:()=>VC,onesLike:()=>JC,op:()=>zS,outerProduct:()=>ZC,pad:()=>e_,pad1d:()=>t_,pad2d:()=>n_,pad3d:()=>r_,pad4d:()=>s_,pool:()=>i_,pow:()=>kT,prelu:()=>o_,print:()=>rT,prod:()=>l_,raggedGather:()=>u_,raggedRange:()=>c_,raggedTensorToTensor:()=>h_,rand:()=>d_,randomGamma:()=>y_,randomNormal:()=>b_,randomStandardNormal:()=>v_,randomUniform:()=>w_,randomUniformInt:()=>x_,range:()=>k_,real:()=>S_,reciprocal:()=>I_,relu:()=>T_,relu6:()=>N_,reshape:()=>QN,reverse:()=>E_,reverse1d:()=>C_,reverse2d:()=>__,reverse3d:()=>A_,reverse4d:()=>R_,rfft:()=>X_,round:()=>$_,rsqrt:()=>O_,scalar:()=>dT,scatterND:()=>SA,searchSorted:()=>FC,selu:()=>D_,separableConv2d:()=>F_,setdiff1dAsync:()=>L_,sigmoid:()=>nE,sign:()=>M_,signal:()=>PR,sin:()=>P_,sinh:()=>z_,slice:()=>rE,slice1d:()=>B_,slice2d:()=>U_,slice3d:()=>V_,slice4d:()=>W_,softmax:()=>j_,softplus:()=>NC,spaceToBatchND:()=>a_,sparse:()=>VR,sparseToDense:()=>IA,spectral:()=>MR,split:()=>K_,sqrt:()=>lT,square:()=>uT,squaredDifference:()=>Y_,squeeze:()=>Q_,stack:()=>J_,step:()=>Z_,stridedSlice:()=>eA,string:()=>WR,sub:()=>ST,sum:()=>tC,tan:()=>tA,tanh:()=>sE,tensor:()=>VS,tensor1d:()=>nA,tensor2d:()=>rA,tensor3d:()=>tN,tensor4d:()=>sA,tensor5d:()=>aA,tensor6d:()=>iA,tensorScatterUpdate:()=>cA,tile:()=>lC,topk:()=>hA,transpose:()=>xA,truncatedNormal:()=>dA,unique:()=>pA,unsortedSegmentSum:()=>fA,unstack:()=>mA,upperBound:()=>gA,variable:()=>yA,where:()=>PE,whereAsync:()=>vA,zeros:()=>UC,zerosLike:()=>cT});var E={};n.r(E),n.d(E,{mx:()=>cW,XI:()=>nj,Nk:()=>rj,f6:()=>aj,ct:()=>aW,YG:()=>uj,hH:()=>mj,z3:()=>Zj,sG:()=>cG,uM:()=>mG,vS:()=>$G,qB:()=>BG,GG:()=>VG,lg:()=>qG,rq:()=>jG,cu:()=>iH,WR:()=>rH,GE:()=>uH,px:()=>hH,jC:()=>NH,He:()=>_H,hE:()=>zH,BF:()=>Gj,Dk:()=>XH,cl:()=>rq,_B:()=>gq,ub:()=>xq,_f:()=>Iq,Ku:()=>Aq,qy:()=>$q,Zy:()=>jq,bu:()=>qq,zv:()=>YV,dH:()=>vW,HS:()=>JW,yH:()=>pK,l3:()=>mK,z9:()=>yK,x6:()=>kK,_m:()=>_K,eW:()=>DK,GK:()=>MK,SP:()=>BK,yr:()=>VK,dl:()=>xG,Dw:()=>KK,xT:()=>JK,_X:()=>NW,wz:()=>aX});var C,_=n(5043),A=n.t(_,2),R=n(4391),$=n(7950),O=n.t($,2);function D(){return D=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},D.apply(this,arguments)}!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(C||(C={}));const F="popstate";function L(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function M(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function P(e,t){return{usr:e.state,key:e.key,idx:t}}function z(e,t,n,r){return void 0===n&&(n=null),D({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?U(t):t,{state:n,key:t&&t.key||r||Math.random().toString(36).substr(2,8)})}function B(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function U(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function V(e,t,n,r){void 0===r&&(r={});let{window:s=document.defaultView,v5Compat:a=!1}=r,i=s.history,o=C.Pop,l=null,u=c();function c(){return(i.state||{idx:null}).idx}function h(){o=C.Pop;let e=c(),t=null==e?null:e-u;u=e,l&&l({action:o,location:p.location,delta:t})}function d(e){let t="null"!==s.location.origin?s.location.origin:s.location.href,n="string"===typeof e?e:B(e);return n=n.replace(/ $/,"%20"),L(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==u&&(u=0,i.replaceState(D({},i.state,{idx:u}),""));let p={get action(){return o},get location(){return e(s,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return s.addEventListener(F,h),l=e,()=>{s.removeEventListener(F,h),l=null}},createHref:e=>t(s,e),createURL:d,encodeLocation(e){let t=d(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o=C.Push;let r=z(p.location,e,t);n&&n(r,e),u=c()+1;let h=P(r,u),d=p.createHref(r);try{i.pushState(h,"",d)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;s.location.assign(d)}a&&l&&l({action:o,location:p.location,delta:1})},replace:function(e,t){o=C.Replace;let r=z(p.location,e,t);n&&n(r,e),u=c();let s=P(r,u),h=p.createHref(r);i.replaceState(s,"",h),a&&l&&l({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}var W;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(W||(W={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function j(e,t,n){return void 0===n&&(n="/"),G(e,t,n,!1)}function G(e,t,n,r){let s=ae(("string"===typeof t?U(t):t).pathname||"/",n);if(null==s)return null;let a=H(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(a);let i=null;for(let o=0;null==i&&o<a.length;++o){let e=se(s);i=ne(a[o],e,r)}return i}function H(e,t,n,r){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===r&&(r="");let s=(e,s,a)=>{let i={relativePath:void 0===a?e.path||"":a,caseSensitive:!0===e.caseSensitive,childrenIndex:s,route:e};i.relativePath.startsWith("/")&&(L(i.relativePath.startsWith(r),'Absolute route path "'+i.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(r.length));let o=ce([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(L(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),H(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:te(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let r of q(e.path))s(e,t,r);else s(e,t)})),t}function q(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,s=n.endsWith("?"),a=n.replace(/\?$/,"");if(0===r.length)return s?[a,""]:[a];let i=q(r.join("/")),o=[];return o.push(...i.map((e=>""===e?a:[a,e].join("/")))),s&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}const K=/^:[\w-]+$/,X=3,Y=2,Q=1,J=10,Z=-2,ee=e=>"*"===e;function te(e,t){let n=e.split("/"),r=n.length;return n.some(ee)&&(r+=Z),t&&(r+=Y),n.filter((e=>!ee(e))).reduce(((e,t)=>e+(K.test(t)?X:""===t?Q:J)),r)}function ne(e,t,n){void 0===n&&(n=!1);let{routesMeta:r}=e,s={},a="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===a?t:t.slice(a.length)||"/",c=re({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),h=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=re({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(s,c.params),i.push({params:s,pathname:ce([a,c.pathname]),pathnameBase:he(ce([a,c.pathnameBase])),route:h}),"/"!==c.pathnameBase&&(a=ce([a,c.pathnameBase]))}return i}function re(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);M("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),s+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":""!==e&&"/"!==e&&(s+="(?:(?=\\/|$))");let a=new RegExp(s,t?void 0:"i");return[a,r]}(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let a=s[0],i=a.replace(/(.)\/+$/,"$1"),o=s.slice(1);return{params:r.reduce(((e,t,n)=>{let{paramName:r,isOptional:s}=t;if("*"===r){let e=o[n]||"";i=a.slice(0,a.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=s&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:a,pathnameBase:i,pattern:e}}function se(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return M(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function ae(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function ie(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function oe(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function le(e,t){let n=oe(e);return t?n.map(((e,t)=>t===n.length-1?e.pathname:e.pathnameBase)):n.map((e=>e.pathnameBase))}function ue(e,t,n,r){let s;void 0===r&&(r=!1),"string"===typeof e?s=U(e):(s=D({},e),L(!s.pathname||!s.pathname.includes("?"),ie("?","pathname","search",s)),L(!s.pathname||!s.pathname.includes("#"),ie("#","pathname","hash",s)),L(!s.search||!s.search.includes("#"),ie("#","search","hash",s)));let a,i=""===e||""===s.pathname,o=i?"/":s.pathname;if(null==o)a=n;else{let e=t.length-1;if(!r&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;s.pathname=t.join("/")}a=e>=0?t[e]:"/"}let l=function(e,t){void 0===t&&(t="/");let{pathname:n,search:r="",hash:s=""}="string"===typeof e?U(e):e,a=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:a,search:de(r),hash:pe(s)}}(s,a),u=o&&"/"!==o&&o.endsWith("/"),c=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!c||(l.pathname+="/"),l}const ce=e=>e.join("/").replace(/\/\/+/g,"/"),he=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),de=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",pe=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function fe(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const me=["post","put","patch","delete"],ge=(new Set(me),["get",...me]);new Set(ge),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function ye(){return ye=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ye.apply(this,arguments)}const be=_.createContext(null);const ve=_.createContext(null);const we=_.createContext(null);const xe=_.createContext(null);const ke=_.createContext({outlet:null,matches:[],isDataRoute:!1});const Se=_.createContext(null);function Ie(){return null!=_.useContext(xe)}function Te(){return Ie()||L(!1),_.useContext(xe).location}function Ne(e){_.useContext(we).static||_.useLayoutEffect(e)}function Ee(){let{isDataRoute:e}=_.useContext(ke);return e?function(){let{router:e}=Me(Fe.UseNavigateStable),t=ze(Le.UseNavigateStable),n=_.useRef(!1);return Ne((()=>{n.current=!0})),_.useCallback((function(r,s){void 0===s&&(s={}),n.current&&("number"===typeof r?e.navigate(r):e.navigate(r,ye({fromRouteId:t},s)))}),[e,t])}():function(){Ie()||L(!1);let e=_.useContext(be),{basename:t,future:n,navigator:r}=_.useContext(we),{matches:s}=_.useContext(ke),{pathname:a}=Te(),i=JSON.stringify(le(s,n.v7_relativeSplatPath)),o=_.useRef(!1);Ne((()=>{o.current=!0}));let l=_.useCallback((function(n,s){if(void 0===s&&(s={}),!o.current)return;if("number"===typeof n)return void r.go(n);let l=ue(n,JSON.parse(i),a,"path"===s.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:ce([t,l.pathname])),(s.replace?r.replace:r.push)(l,s.state,s)}),[t,r,i,a,e]);return l}()}function Ce(e,t){let{relative:n}=void 0===t?{}:t,{future:r}=_.useContext(we),{matches:s}=_.useContext(ke),{pathname:a}=Te(),i=JSON.stringify(le(s,r.v7_relativeSplatPath));return _.useMemo((()=>ue(e,JSON.parse(i),a,"path"===n)),[e,i,a,n])}function _e(e,t,n,r){Ie()||L(!1);let{navigator:s}=_.useContext(we),{matches:a}=_.useContext(ke),i=a[a.length-1],o=i?i.params:{},l=(i&&i.pathname,i?i.pathnameBase:"/");i&&i.route;let u,c=Te();if(t){var h;let e="string"===typeof t?U(t):t;"/"===l||(null==(h=e.pathname)?void 0:h.startsWith(l))||L(!1),u=e}else u=c;let d=u.pathname||"/",p=d;if("/"!==l){let e=l.replace(/^\//,"").split("/");p="/"+d.replace(/^\//,"").split("/").slice(e.length).join("/")}let f=j(e,{pathname:p});let m=De(f&&f.map((e=>Object.assign({},e,{params:Object.assign({},o,e.params),pathname:ce([l,s.encodeLocation?s.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?l:ce([l,s.encodeLocation?s.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),a,n,r);return t&&m?_.createElement(xe.Provider,{value:{location:ye({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:C.Pop}},m):m}function Ae(){let e=function(){var e;let t=_.useContext(Se),n=Pe(Le.UseRouteError),r=ze(Le.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[r]}(),t=fe(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:r};return _.createElement(_.Fragment,null,_.createElement("h2",null,"Unexpected Application Error!"),_.createElement("h3",{style:{fontStyle:"italic"}},t),n?_.createElement("pre",{style:s},n):null,null)}const Re=_.createElement(Ae,null);class $e extends _.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?_.createElement(ke.Provider,{value:this.props.routeContext},_.createElement(Se.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function Oe(e){let{routeContext:t,match:n,children:r}=e,s=_.useContext(be);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),_.createElement(ke.Provider,{value:t},r)}function De(e,t,n,r){var s;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==e){var a;if(!n)return null;if(n.errors)e=n.matches;else{if(!(null!=(a=r)&&a.v7_partialHydration&&0===t.length&&!n.initialized&&n.matches.length>0))return null;e=n.matches}}let i=e,o=null==(s=n)?void 0:s.errors;if(null!=o){let e=i.findIndex((e=>e.route.id&&void 0!==(null==o?void 0:o[e.route.id])));e>=0||L(!1),i=i.slice(0,Math.min(i.length,e+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let c=0;c<i.length;c++){let e=i[c];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(u=c),e.route.id){let{loaderData:t,errors:r}=n,s=e.route.loader&&void 0===t[e.route.id]&&(!r||void 0===r[e.route.id]);if(e.route.lazy||s){l=!0,i=u>=0?i.slice(0,u+1):[i[0]];break}}}return i.reduceRight(((e,r,s)=>{let a,c=!1,h=null,d=null;var p;n&&(a=o&&r.route.id?o[r.route.id]:void 0,h=r.route.errorElement||Re,l&&(u<0&&0===s?(p="route-fallback",!1||Be[p]||(Be[p]=!0),c=!0,d=null):u===s&&(c=!0,d=r.route.hydrateFallbackElement||null)));let f=t.concat(i.slice(0,s+1)),m=()=>{let t;return t=a?h:c?d:r.route.Component?_.createElement(r.route.Component,null):r.route.element?r.route.element:e,_.createElement(Oe,{match:r,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===s)?_.createElement($e,{location:n.location,revalidation:n.revalidation,component:h,error:a,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()}),null)}var Fe=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Fe||{}),Le=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(Le||{});function Me(e){let t=_.useContext(be);return t||L(!1),t}function Pe(e){let t=_.useContext(ve);return t||L(!1),t}function ze(e){let t=function(){let e=_.useContext(ke);return e||L(!1),e}(),n=t.matches[t.matches.length-1];return n.route.id||L(!1),n.route.id}const Be={};A.startTransition;function Ue(e){let{to:t,replace:n,state:r,relative:s}=e;Ie()||L(!1);let{future:a,static:i}=_.useContext(we),{matches:o}=_.useContext(ke),{pathname:l}=Te(),u=Ee(),c=ue(t,le(o,a.v7_relativeSplatPath),l,"path"===s),h=JSON.stringify(c);return _.useEffect((()=>u(JSON.parse(h),{replace:n,state:r,relative:s})),[u,h,s,n,r]),null}function Ve(e){L(!1)}function We(e){let{basename:t="/",children:n=null,location:r,navigationType:s=C.Pop,navigator:a,static:i=!1,future:o}=e;Ie()&&L(!1);let l=t.replace(/^\/*/,"/"),u=_.useMemo((()=>({basename:l,navigator:a,static:i,future:ye({v7_relativeSplatPath:!1},o)})),[l,o,a,i]);"string"===typeof r&&(r=U(r));let{pathname:c="/",search:h="",hash:d="",state:p=null,key:f="default"}=r,m=_.useMemo((()=>{let e=ae(c,l);return null==e?null:{location:{pathname:e,search:h,hash:d,state:p,key:f},navigationType:s}}),[l,c,h,d,p,f,s]);return null==m?null:_.createElement(we.Provider,{value:u},_.createElement(xe.Provider,{children:n,value:m}))}function je(e){let{children:t,location:n}=e;return _e(Ge(t),n)}new Promise((()=>{}));_.Component;function Ge(e,t){void 0===t&&(t=[]);let n=[];return _.Children.forEach(e,((e,r)=>{if(!_.isValidElement(e))return;let s=[...t,r];if(e.type===_.Fragment)return void n.push.apply(n,Ge(e.props.children,s));e.type!==Ve&&L(!1),e.props.index&&e.props.children&&L(!1);let a={id:e.props.id||s.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(a.children=Ge(e.props.children,s)),n.push(a)})),n}function He(){return He=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},He.apply(this,arguments)}function qe(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);const Ke=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"];try{window.__reactRouterVersion="6"}catch(t5){}new Map;const Xe=A.startTransition;O.flushSync,A.useId;function Ye(e){let{basename:t,children:n,future:r,window:s}=e,a=_.useRef();var i;null==a.current&&(a.current=(void 0===(i={window:s,v5Compat:!0})&&(i={}),V((function(e,t){let{pathname:n,search:r,hash:s}=e.location;return z("",{pathname:n,search:r,hash:s},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:B(t)}),null,i)));let o=a.current,[l,u]=_.useState({action:o.action,location:o.location}),{v7_startTransition:c}=r||{},h=_.useCallback((e=>{c&&Xe?Xe((()=>u(e))):u(e)}),[u,c]);return _.useLayoutEffect((()=>o.listen(h)),[o,h]),_.createElement(We,{basename:t,children:n,location:l.location,navigationType:l.action,navigator:o,future:r})}const Qe="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,Je=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ze=_.forwardRef((function(e,t){let n,{onClick:r,relative:s,reloadDocument:a,replace:i,state:o,target:l,to:u,preventScrollReset:c,viewTransition:h}=e,d=qe(e,Ke),{basename:p}=_.useContext(we),f=!1;if("string"===typeof u&&Je.test(u)&&(n=u,Qe))try{let e=new URL(window.location.href),t=u.startsWith("//")?new URL(e.protocol+u):new URL(u),n=ae(t.pathname,p);t.origin===e.origin&&null!=n?u=n+t.search+t.hash:f=!0}catch(t5){}let m=function(e,t){let{relative:n}=void 0===t?{}:t;Ie()||L(!1);let{basename:r,navigator:s}=_.useContext(we),{hash:a,pathname:i,search:o}=Ce(e,{relative:n}),l=i;return"/"!==r&&(l="/"===i?r:ce([r,i])),s.createHref({pathname:l,search:o,hash:a})}(u,{relative:s}),g=function(e,t){let{target:n,replace:r,state:s,preventScrollReset:a,relative:i,viewTransition:o}=void 0===t?{}:t,l=Ee(),u=Te(),c=Ce(e,{relative:i});return _.useCallback((t=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(t,n)){t.preventDefault();let n=void 0!==r?r:B(u)===B(c);l(e,{replace:n,state:s,preventScrollReset:a,relative:i,viewTransition:o})}}),[u,l,c,r,s,n,e,a,i,o])}(u,{replace:i,state:o,target:l,preventScrollReset:c,relative:s,viewTransition:h});return _.createElement("a",He({},d,{href:n||m,onClick:f||a?r:function(e){r&&r(e),e.defaultPrevented||g(e)},ref:t,target:l}))}));var et,tt;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(et||(et={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(tt||(tt={}));const nt=function(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let s=e.charCodeAt(r);s<128?t[n++]=s:s<2048?(t[n++]=s>>6|192,t[n++]=63&s|128):55296===(64512&s)&&r+1<e.length&&56320===(64512&e.charCodeAt(r+1))?(s=65536+((1023&s)<<10)+(1023&e.charCodeAt(++r)),t[n++]=s>>18|240,t[n++]=s>>12&63|128,t[n++]=s>>6&63|128,t[n++]=63&s|128):(t[n++]=s>>12|224,t[n++]=s>>6&63|128,t[n++]=63&s|128)}return t},rt={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:"function"===typeof atob,encodeByteArray(e,t){if(!Array.isArray(e))throw Error("encodeByteArray takes an array as a parameter");this.init_();const n=t?this.byteToCharMapWebSafe_:this.byteToCharMap_,r=[];for(let s=0;s<e.length;s+=3){const t=e[s],a=s+1<e.length,i=a?e[s+1]:0,o=s+2<e.length,l=o?e[s+2]:0,u=t>>2,c=(3&t)<<4|i>>4;let h=(15&i)<<2|l>>6,d=63&l;o||(d=64,a||(h=64)),r.push(n[u],n[c],n[h],n[d])}return r.join("")},encodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?btoa(e):this.encodeByteArray(nt(e),t)},decodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?atob(e):function(e){const t=[];let n=0,r=0;for(;n<e.length;){const s=e[n++];if(s<128)t[r++]=String.fromCharCode(s);else if(s>191&&s<224){const a=e[n++];t[r++]=String.fromCharCode((31&s)<<6|63&a)}else if(s>239&&s<365){const a=((7&s)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536;t[r++]=String.fromCharCode(55296+(a>>10)),t[r++]=String.fromCharCode(56320+(1023&a))}else{const a=e[n++],i=e[n++];t[r++]=String.fromCharCode((15&s)<<12|(63&a)<<6|63&i)}}return t.join("")}(this.decodeStringToByteArray(e,t))},decodeStringToByteArray(e,t){this.init_();const n=t?this.charToByteMapWebSafe_:this.charToByteMap_,r=[];for(let s=0;s<e.length;){const t=n[e.charAt(s++)],a=s<e.length?n[e.charAt(s)]:0;++s;const i=s<e.length?n[e.charAt(s)]:64;++s;const o=s<e.length?n[e.charAt(s)]:64;if(++s,null==t||null==a||null==i||null==o)throw new st;const l=t<<2|a>>4;if(r.push(l),64!==i){const e=a<<4&240|i>>2;if(r.push(e),64!==o){const e=i<<6&192|o;r.push(e)}}}return r},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let e=0;e<this.ENCODED_VALS.length;e++)this.byteToCharMap_[e]=this.ENCODED_VALS.charAt(e),this.charToByteMap_[this.byteToCharMap_[e]]=e,this.byteToCharMapWebSafe_[e]=this.ENCODED_VALS_WEBSAFE.charAt(e),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]]=e,e>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)]=e,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)]=e)}}};class st extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const at=function(e){return function(e){const t=nt(e);return rt.encodeByteArray(t,!0)}(e).replace(/\./g,"")},it=function(e){try{return rt.decodeString(e,!0)}catch(t5){console.error("base64Decode failed: ",t5)}return null};const ot=()=>function(){if("undefined"!==typeof self)return self;if("undefined"!==typeof window)return window;if("undefined"!==typeof n.g)return n.g;throw new Error("Unable to locate global object.")}().__FIREBASE_DEFAULTS__,lt=()=>{try{return ot()||(()=>{if("undefined"===typeof process)return;const e={NODE_ENV:"production",PUBLIC_URL:"/Translator",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_FIREBASE_MESSAGING_SENDER_ID:"832165372977",REACT_APP_FIREBASE_STORAGE_BUCKET:"globetalk-d37c8.appspot.com",REACT_APP_FIREBASE_AUTH_DOMAIN:"globetalk-d37c8.firebaseapp.com",REACT_APP_FIREBASE_PROJECT_ID:"globetalk-d37c8",REACT_APP_FIREBASE_APP_ID:"G-8HX5HB0C7B",REACT_APP_FIREBASE_API_KEY:"AIzaSyA8vD4MJ8xAKJVPFzTy68nZT47GD_e3oiI"}.__FIREBASE_DEFAULTS__;return e?JSON.parse(e):void 0})()||(()=>{if("undefined"===typeof document)return;let e;try{e=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch(t5){return}const t=e&&it(e[1]);return t&&JSON.parse(t)})()}catch(t5){return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t5}`)}},ut=e=>{var t,n;return null===(n=null===(t=lt())||void 0===t?void 0:t.emulatorHosts)||void 0===n?void 0:n[e]},ct=()=>{var e;return null===(e=lt())||void 0===e?void 0:e.config},ht=e=>{var t;return null===(t=lt())||void 0===t?void 0:t[`_${e}`]};class dt{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}wrapCallback(e){return(t,n)=>{t?this.reject(t):this.resolve(n),"function"===typeof e&&(this.promise.catch((()=>{})),1===e.length?e(t):e(t,n))}}}function pt(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function ft(){return!function(){var e;const t=null===(e=lt())||void 0===e?void 0:e.forceEnvironment;if("node"===t)return!0;if("browser"===t)return!1;try{return"[object process]"===Object.prototype.toString.call(n.g.process)}catch(t5){return!1}}()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function mt(){try{return"object"===typeof indexedDB}catch(t5){return!1}}class gt extends Error{constructor(e,t,n){super(t),this.code=e,this.customData=n,this.name="FirebaseError",Object.setPrototypeOf(this,gt.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,yt.prototype.create)}}class yt{constructor(e,t,n){this.service=e,this.serviceName=t,this.errors=n}create(e){const t=(arguments.length<=1?void 0:arguments[1])||{},n=`${this.service}/${e}`,r=this.errors[e],s=r?function(e,t){return e.replace(bt,((e,n)=>{const r=t[n];return null!=r?String(r):`<${n}?>`}))}(r,t):"Error",a=`${this.serviceName}: ${s} (${n}).`;return new gt(n,a,t)}}const bt=/\{\$([^}]+)}/g;function vt(e,t){if(e===t)return!0;const n=Object.keys(e),r=Object.keys(t);for(const s of n){if(!r.includes(s))return!1;const n=e[s],a=t[s];if(wt(n)&&wt(a)){if(!vt(n,a))return!1}else if(n!==a)return!1}for(const s of r)if(!n.includes(s))return!1;return!0}function wt(e){return null!==e&&"object"===typeof e}function xt(e){const t=[];for(const[n,r]of Object.entries(e))Array.isArray(r)?r.forEach((e=>{t.push(encodeURIComponent(n)+"="+encodeURIComponent(e))})):t.push(encodeURIComponent(n)+"="+encodeURIComponent(r));return t.length?"&"+t.join("&"):""}function kt(e){const t={};return e.replace(/^\?/,"").split("&").forEach((e=>{if(e){const[n,r]=e.split("=");t[decodeURIComponent(n)]=decodeURIComponent(r)}})),t}function St(e){const t=e.indexOf("?");if(!t)return"";const n=e.indexOf("#",t);return e.substring(t,n>0?n:void 0)}class It{constructor(e,t){this.observers=[],this.unsubscribes=[],this.observerCount=0,this.task=Promise.resolve(),this.finalized=!1,this.onNoObservers=t,this.task.then((()=>{e(this)})).catch((e=>{this.error(e)}))}next(e){this.forEachObserver((t=>{t.next(e)}))}error(e){this.forEachObserver((t=>{t.error(e)})),this.close(e)}complete(){this.forEachObserver((e=>{e.complete()})),this.close()}subscribe(e,t,n){let r;if(void 0===e&&void 0===t&&void 0===n)throw new Error("Missing Observer.");r=function(e,t){if("object"!==typeof e||null===e)return!1;for(const n of t)if(n in e&&"function"===typeof e[n])return!0;return!1}(e,["next","error","complete"])?e:{next:e,error:t,complete:n},void 0===r.next&&(r.next=Tt),void 0===r.error&&(r.error=Tt),void 0===r.complete&&(r.complete=Tt);const s=this.unsubscribeOne.bind(this,this.observers.length);return this.finalized&&this.task.then((()=>{try{this.finalError?r.error(this.finalError):r.complete()}catch(t5){}})),this.observers.push(r),s}unsubscribeOne(e){void 0!==this.observers&&void 0!==this.observers[e]&&(delete this.observers[e],this.observerCount-=1,0===this.observerCount&&void 0!==this.onNoObservers&&this.onNoObservers(this))}forEachObserver(e){if(!this.finalized)for(let t=0;t<this.observers.length;t++)this.sendOne(t,e)}sendOne(e,t){this.task.then((()=>{if(void 0!==this.observers&&void 0!==this.observers[e])try{t(this.observers[e])}catch(t5){"undefined"!==typeof console&&console.error&&console.error(t5)}}))}close(e){this.finalized||(this.finalized=!0,void 0!==e&&(this.finalError=e),this.task.then((()=>{this.observers=void 0,this.onNoObservers=void 0})))}}function Tt(){}function Nt(e){return e&&e._delegate?e._delegate:e}class Et{constructor(e,t,n){this.name=e,this.instanceFactory=t,this.type=n,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const Ct="[DEFAULT]";class _t{constructor(e,t){this.name=e,this.container=t,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const t=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(t)){const e=new dt;if(this.instancesDeferred.set(t,e),this.isInitialized(t)||this.shouldAutoInitialize())try{const n=this.getOrInitializeService({instanceIdentifier:t});n&&e.resolve(n)}catch(t5){}}return this.instancesDeferred.get(t).promise}getImmediate(e){var t;const n=this.normalizeInstanceIdentifier(null===e||void 0===e?void 0:e.identifier),r=null!==(t=null===e||void 0===e?void 0:e.optional)&&void 0!==t&&t;if(!this.isInitialized(n)&&!this.shouldAutoInitialize()){if(r)return null;throw Error(`Service ${this.name} is not available`)}try{return this.getOrInitializeService({instanceIdentifier:n})}catch(t5){if(r)return null;throw t5}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,this.shouldAutoInitialize()){if(function(e){return"EAGER"===e.instantiationMode}(e))try{this.getOrInitializeService({instanceIdentifier:Ct})}catch(t5){}for(const[e,t]of this.instancesDeferred.entries()){const n=this.normalizeInstanceIdentifier(e);try{const e=this.getOrInitializeService({instanceIdentifier:n});t.resolve(e)}catch(t5){}}}}clearInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ct;this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter((e=>"INTERNAL"in e)).map((e=>e.INTERNAL.delete())),...e.filter((e=>"_delete"in e)).map((e=>e._delete()))])}isComponentSet(){return null!=this.component}isInitialized(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ct;return this.instances.has(e)}getOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ct;return this.instancesOptions.get(e)||{}}initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{options:t={}}=e,n=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(n))throw Error(`${this.name}(${n}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const r=this.getOrInitializeService({instanceIdentifier:n,options:t});for(const[s,a]of this.instancesDeferred.entries()){n===this.normalizeInstanceIdentifier(s)&&a.resolve(r)}return r}onInit(e,t){var n;const r=this.normalizeInstanceIdentifier(t),s=null!==(n=this.onInitCallbacks.get(r))&&void 0!==n?n:new Set;s.add(e),this.onInitCallbacks.set(r,s);const a=this.instances.get(r);return a&&e(a,r),()=>{s.delete(e)}}invokeOnInitCallbacks(e,t){const n=this.onInitCallbacks.get(t);if(n)for(const s of n)try{s(e,t)}catch(r){}}getOrInitializeService(e){let{instanceIdentifier:t,options:n={}}=e,r=this.instances.get(t);if(!r&&this.component&&(r=this.component.instanceFactory(this.container,{instanceIdentifier:(s=t,s===Ct?void 0:s),options:n}),this.instances.set(t,r),this.instancesOptions.set(t,n),this.invokeOnInitCallbacks(r,t),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,t,r)}catch(a){}var s;return r||null}normalizeInstanceIdentifier(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ct;return this.component?this.component.multipleInstances?e:Ct:e}shouldAutoInitialize(){return!!this.component&&"EXPLICIT"!==this.component.instantiationMode}}class At{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const t=this.getProvider(e.name);if(t.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);t.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const t=new _t(e,this);return this.providers.set(e,t),t}getProviders(){return Array.from(this.providers.values())}}const Rt=[];var $t;!function(e){e[e.DEBUG=0]="DEBUG",e[e.VERBOSE=1]="VERBOSE",e[e.INFO=2]="INFO",e[e.WARN=3]="WARN",e[e.ERROR=4]="ERROR",e[e.SILENT=5]="SILENT"}($t||($t={}));const Ot={debug:$t.DEBUG,verbose:$t.VERBOSE,info:$t.INFO,warn:$t.WARN,error:$t.ERROR,silent:$t.SILENT},Dt=$t.INFO,Ft={[$t.DEBUG]:"log",[$t.VERBOSE]:"log",[$t.INFO]:"info",[$t.WARN]:"warn",[$t.ERROR]:"error"},Lt=function(e,t){if(t<e.logLevel)return;const n=(new Date).toISOString(),r=Ft[t];if(!r)throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);for(var s=arguments.length,a=new Array(s>2?s-2:0),i=2;i<s;i++)a[i-2]=arguments[i];console[r](`[${n}]  ${e.name}:`,...a)};class Mt{constructor(e){this.name=e,this._logLevel=Dt,this._logHandler=Lt,this._userLogHandler=null,Rt.push(this)}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in $t))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel="string"===typeof e?Ot[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if("function"!==typeof e)throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,$t.DEBUG,...t),this._logHandler(this,$t.DEBUG,...t)}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,$t.VERBOSE,...t),this._logHandler(this,$t.VERBOSE,...t)}info(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,$t.INFO,...t),this._logHandler(this,$t.INFO,...t)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,$t.WARN,...t),this._logHandler(this,$t.WARN,...t)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,$t.ERROR,...t),this._logHandler(this,$t.ERROR,...t)}}let Pt,zt;const Bt=new WeakMap,Ut=new WeakMap,Vt=new WeakMap,Wt=new WeakMap,jt=new WeakMap;let Gt={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return Ut.get(e);if("objectStoreNames"===t)return e.objectStoreNames||Vt.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return Kt(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function Ht(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(zt||(zt=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return e.apply(Xt(this),n),Kt(Bt.get(this))}:function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return Kt(e.apply(Xt(this),n))}:function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];const a=e.call(Xt(this),t,...r);return Vt.set(a,t.sort?t.sort():[t]),Kt(a)}}function qt(e){return"function"===typeof e?Ht(e):(e instanceof IDBTransaction&&function(e){if(Ut.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",a),e.removeEventListener("abort",a)},s=()=>{t(),r()},a=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",s),e.addEventListener("error",a),e.addEventListener("abort",a)}));Ut.set(e,t)}(e),t=e,(Pt||(Pt=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])).some((e=>t instanceof e))?new Proxy(e,Gt):e);var t}function Kt(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",s),e.removeEventListener("error",a)},s=()=>{t(Kt(e.result)),r()},a=()=>{n(e.error),r()};e.addEventListener("success",s),e.addEventListener("error",a)}));return t.then((t=>{t instanceof IDBCursor&&Bt.set(t,e)})).catch((()=>{})),jt.set(t,e),t}(e);if(Wt.has(e))return Wt.get(e);const t=qt(e);return t!==e&&(Wt.set(e,t),jt.set(t,e)),t}const Xt=e=>jt.get(e);const Yt=["get","getKey","getAll","getAllKeys","count"],Qt=["put","add","delete","clear"],Jt=new Map;function Zt(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!==typeof t)return;if(Jt.get(t))return Jt.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,s=Qt.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!s&&!Yt.includes(n))return;const a=async function(e){const t=this.transaction(e,s?"readwrite":"readonly");let a=t.store;for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return r&&(a=a.index(o.shift())),(await Promise.all([a[n](...o),s&&t.done]))[0]};return Jt.set(t,a),a}Gt=(e=>({...e,get:(t,n,r)=>Zt(t,n)||e.get(t,n,r),has:(t,n)=>!!Zt(t,n)||e.has(t,n)}))(Gt);class en{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map((e=>{if(function(e){const t=e.getComponent();return"VERSION"===(null===t||void 0===t?void 0:t.type)}(e)){const t=e.getImmediate();return`${t.library}/${t.version}`}return null})).filter((e=>e)).join(" ")}}const tn="@firebase/app",nn="0.10.15",rn=new Mt("@firebase/app"),sn="@firebase/app-compat",an="@firebase/analytics-compat",on="@firebase/analytics",ln="@firebase/app-check-compat",un="@firebase/app-check",cn="@firebase/auth",hn="@firebase/auth-compat",dn="@firebase/database",pn="@firebase/data-connect",fn="@firebase/database-compat",mn="@firebase/functions",gn="@firebase/functions-compat",yn="@firebase/installations",bn="@firebase/installations-compat",vn="@firebase/messaging",wn="@firebase/messaging-compat",xn="@firebase/performance",kn="@firebase/performance-compat",Sn="@firebase/remote-config",In="@firebase/remote-config-compat",Tn="@firebase/storage",Nn="@firebase/storage-compat",En="@firebase/firestore",Cn="@firebase/vertexai",_n="@firebase/firestore-compat",An="firebase",Rn="[DEFAULT]",$n={[tn]:"fire-core",[sn]:"fire-core-compat",[on]:"fire-analytics",[an]:"fire-analytics-compat",[un]:"fire-app-check",[ln]:"fire-app-check-compat",[cn]:"fire-auth",[hn]:"fire-auth-compat",[dn]:"fire-rtdb",[pn]:"fire-data-connect",[fn]:"fire-rtdb-compat",[mn]:"fire-fn",[gn]:"fire-fn-compat",[yn]:"fire-iid",[bn]:"fire-iid-compat",[vn]:"fire-fcm",[wn]:"fire-fcm-compat",[xn]:"fire-perf",[kn]:"fire-perf-compat",[Sn]:"fire-rc",[In]:"fire-rc-compat",[Tn]:"fire-gcs",[Nn]:"fire-gcs-compat",[En]:"fire-fst",[_n]:"fire-fst-compat",[Cn]:"fire-vertex","fire-js":"fire-js",[An]:"fire-js-all"},On=new Map,Dn=new Map,Fn=new Map;function Ln(e,t){try{e.container.addComponent(t)}catch(t5){rn.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`,t5)}}function Mn(e){const t=e.name;if(Fn.has(t))return rn.debug(`There were multiple attempts to register component ${t}.`),!1;Fn.set(t,e);for(const n of On.values())Ln(n,e);for(const n of Dn.values())Ln(n,e);return!0}function Pn(e,t){const n=e.container.getProvider("heartbeat").getImmediate({optional:!0});return n&&n.triggerHeartbeat(),e.container.getProvider(t)}function zn(e){return void 0!==e.settings}const Bn=new yt("app","Firebase",{"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."});class Un{constructor(e,t,n){this._isDeleted=!1,this._options=Object.assign({},e),this._config=Object.assign({},t),this._name=t.name,this._automaticDataCollectionEnabled=t.automaticDataCollectionEnabled,this._container=n,this.container.addComponent(new Et("app",(()=>this),"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw Bn.create("app-deleted",{appName:this._name})}}const Vn="11.0.1";function Wn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e;if("object"!==typeof t){t={name:t}}const r=Object.assign({name:Rn,automaticDataCollectionEnabled:!1},t),s=r.name;if("string"!==typeof s||!s)throw Bn.create("bad-app-name",{appName:String(s)});if(n||(n=ct()),!n)throw Bn.create("no-options");const a=On.get(s);if(a){if(vt(n,a.options)&&vt(r,a.config))return a;throw Bn.create("duplicate-app",{appName:s})}const i=new At(s);for(const l of Fn.values())i.addComponent(l);const o=new Un(n,r,i);return On.set(s,o),o}function jn(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Rn;const t=On.get(e);if(!t&&e===Rn&&ct())return Wn();if(!t)throw Bn.create("no-app",{appName:e});return t}function Gn(e,t,n){var r;let s=null!==(r=$n[e])&&void 0!==r?r:e;n&&(s+=`-${n}`);const a=s.match(/\s|\//),i=t.match(/\s|\//);if(a||i){const e=[`Unable to register library "${s}" with version "${t}":`];return a&&e.push(`library name "${s}" contains illegal characters (whitespace or "/")`),a&&i&&e.push("and"),i&&e.push(`version name "${t}" contains illegal characters (whitespace or "/")`),void rn.warn(e.join(" "))}Mn(new Et(`${s}-version`,(()=>({library:s,version:t})),"VERSION"))}const Hn="firebase-heartbeat-store";let qn=null;function Kn(){return qn||(qn=function(e,t){let{blocked:n,upgrade:r,blocking:s,terminated:a}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=indexedDB.open(e,t),o=Kt(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(Kt(i.result),e.oldVersion,e.newVersion,Kt(i.transaction),e)})),n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),o.then((e=>{a&&e.addEventListener("close",(()=>a())),s&&e.addEventListener("versionchange",(e=>s(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),o}("firebase-heartbeat-database",1,{upgrade:(e,t)=>{if(0===t)try{e.createObjectStore(Hn)}catch(t5){console.warn(t5)}}}).catch((e=>{throw Bn.create("idb-open",{originalErrorMessage:e.message})}))),qn}async function Xn(e,t){try{const n=(await Kn()).transaction(Hn,"readwrite"),r=n.objectStore(Hn);await r.put(t,Yn(e)),await n.done}catch(t5){if(t5 instanceof gt)rn.warn(t5.message);else{const t=Bn.create("idb-set",{originalErrorMessage:null===t5||void 0===t5?void 0:t5.message});rn.warn(t.message)}}}function Yn(e){return`${e.name}!${e.options.appId}`}class Qn{constructor(e){this.container=e,this._heartbeatsCache=null;const t=this.container.getProvider("app").getImmediate();this._storage=new Zn(t),this._heartbeatsCachePromise=this._storage.read().then((e=>(this._heartbeatsCache=e,e)))}async triggerHeartbeat(){var e,t;try{const n=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),r=Jn();if(null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)&&(this._heartbeatsCache=await this._heartbeatsCachePromise,null==(null===(t=this._heartbeatsCache)||void 0===t?void 0:t.heartbeats)))return;if(this._heartbeatsCache.lastSentHeartbeatDate===r||this._heartbeatsCache.heartbeats.some((e=>e.date===r)))return;return this._heartbeatsCache.heartbeats.push({date:r,agent:n}),this._heartbeatsCache.heartbeats=this._heartbeatsCache.heartbeats.filter((e=>{const t=new Date(e.date).valueOf();return Date.now()-t<=2592e6})),this._storage.overwrite(this._heartbeatsCache)}catch(t5){rn.warn(t5)}}async getHeartbeatsHeader(){var e;try{if(null===this._heartbeatsCache&&await this._heartbeatsCachePromise,null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)||0===this._heartbeatsCache.heartbeats.length)return"";const t=Jn(),{heartbeatsToSend:n,unsentEntries:r}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024;const n=[];let r=e.slice();for(const s of e){const e=n.find((e=>e.agent===s.agent));if(e){if(e.dates.push(s.date),er(n)>t){e.dates.pop();break}}else if(n.push({agent:s.agent,dates:[s.date]}),er(n)>t){n.pop();break}r=r.slice(1)}return{heartbeatsToSend:n,unsentEntries:r}}(this._heartbeatsCache.heartbeats),s=at(JSON.stringify({version:2,heartbeats:n}));return this._heartbeatsCache.lastSentHeartbeatDate=t,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),s}catch(t5){return rn.warn(t5),""}}}function Jn(){return(new Date).toISOString().substring(0,10)}class Zn{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return!!mt()&&new Promise(((e,t)=>{try{let n=!0;const r="validate-browser-context-for-indexeddb-analytics-module",s=self.indexedDB.open(r);s.onsuccess=()=>{s.result.close(),n||self.indexedDB.deleteDatabase(r),e(!0)},s.onupgradeneeded=()=>{n=!1},s.onerror=()=>{var e;t((null===(e=s.error)||void 0===e?void 0:e.message)||"")}}catch(n){t(n)}})).then((()=>!0)).catch((()=>!1))}async read(){if(await this._canUseIndexedDBPromise){const e=await async function(e){try{const t=(await Kn()).transaction(Hn),n=await t.objectStore(Hn).get(Yn(e));return await t.done,n}catch(t5){if(t5 instanceof gt)rn.warn(t5.message);else{const t=Bn.create("idb-get",{originalErrorMessage:null===t5||void 0===t5?void 0:t5.message});rn.warn(t.message)}}}(this.app);return(null===e||void 0===e?void 0:e.heartbeats)?e:{heartbeats:[]}}return{heartbeats:[]}}async overwrite(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return Xn(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:e.heartbeats})}}async add(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return Xn(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:[...n.heartbeats,...e.heartbeats]})}}}function er(e){return at(JSON.stringify({version:2,heartbeats:e})).length}var tr;tr="",Mn(new Et("platform-logger",(e=>new en(e)),"PRIVATE")),Mn(new Et("heartbeat",(e=>new Qn(e)),"PRIVATE")),Gn(tn,nn,tr),Gn(tn,nn,"esm2017"),Gn("fire-js","");function nr(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}Object.create;Object.create;"function"===typeof SuppressedError&&SuppressedError;function rr(){return{"dependent-sdk-initialized-before-auth":"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}}const sr=rr,ar=new yt("auth","Firebase",{"dependent-sdk-initialized-before-auth":"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}),ir=new Mt("@firebase/auth");function or(e){if(ir.logLevel<=$t.ERROR){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];ir.error(`Auth (${Vn}): ${e}`,...n)}}function lr(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw dr(e,...n)}function ur(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return dr(e,...n)}function cr(e,t,n){const r=Object.assign(Object.assign({},sr()),{[t]:n});return new yt("auth","Firebase",r).create(t,{appName:e.name})}function hr(e){return cr(e,"operation-not-supported-in-this-environment","Operations that alter the current user are not supported in conjunction with FirebaseServerApp")}function dr(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if("string"!==typeof e){const t=n[0],r=[...n.slice(1)];return r[0]&&(r[0].appName=e.name),e._errorFactory.create(t,...r)}return ar.create(e,...n)}function pr(e,t){if(!e){for(var n=arguments.length,r=new Array(n>2?n-2:0),s=2;s<n;s++)r[s-2]=arguments[s];throw dr(t,...r)}}function fr(e){const t="INTERNAL ASSERTION FAILED: "+e;throw or(t),new Error(t)}function mr(e,t){e||fr(t)}function gr(){var e;return"undefined"!==typeof self&&(null===(e=self.location)||void 0===e?void 0:e.href)||""}function yr(){return"http:"===br()||"https:"===br()}function br(){var e;return"undefined"!==typeof self&&(null===(e=self.location)||void 0===e?void 0:e.protocol)||null}function vr(){return!("undefined"!==typeof navigator&&navigator&&"onLine"in navigator&&"boolean"===typeof navigator.onLine&&(yr()||function(){const e="object"===typeof chrome?chrome.runtime:"object"===typeof browser?browser.runtime:void 0;return"object"===typeof e&&void 0!==e.id}()||"connection"in navigator))||navigator.onLine}class wr{constructor(e,t){this.shortDelay=e,this.longDelay=t,mr(t>e,"Short delay should be less than long delay!"),this.isMobile="undefined"!==typeof window&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(pt())||"object"===typeof navigator&&"ReactNative"===navigator.product}get(){return vr()?this.isMobile?this.longDelay:this.shortDelay:Math.min(5e3,this.shortDelay)}}function xr(e,t){mr(e.emulator,"Emulator should always be set here");const{url:n}=e.emulator;return t?`${n}${t.startsWith("/")?t.slice(1):t}`:n}class kr{static initialize(e,t,n){this.fetchImpl=e,t&&(this.headersImpl=t),n&&(this.responseImpl=n)}static fetch(){return this.fetchImpl?this.fetchImpl:"undefined"!==typeof self&&"fetch"in self?self.fetch:"undefined"!==typeof globalThis&&globalThis.fetch?globalThis.fetch:"undefined"!==typeof fetch?fetch:void fr("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static headers(){return this.headersImpl?this.headersImpl:"undefined"!==typeof self&&"Headers"in self?self.Headers:"undefined"!==typeof globalThis&&globalThis.Headers?globalThis.Headers:"undefined"!==typeof Headers?Headers:void fr("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static response(){return this.responseImpl?this.responseImpl:"undefined"!==typeof self&&"Response"in self?self.Response:"undefined"!==typeof globalThis&&globalThis.Response?globalThis.Response:"undefined"!==typeof Response?Response:void fr("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}}const Sr={CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_PASSWORD:"wrong-password",MISSING_PASSWORD:"missing-password",INVALID_LOGIN_CREDENTIALS:"invalid-credential",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",INVALID_PENDING_TOKEN:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",MISSING_REQ_TYPE:"internal-error",EMAIL_NOT_FOUND:"user-not-found",RESET_PASSWORD_EXCEED_LIMIT:"too-many-requests",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",PASSWORD_DOES_NOT_MEET_REQUIREMENTS:"password-does-not-meet-requirements",INVALID_CODE:"invalid-verification-code",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_SESSION_INFO:"missing-verification-id",SESSION_EXPIRED:"code-expired",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",ADMIN_ONLY_OPERATION:"admin-restricted-operation",INVALID_MFA_PENDING_CREDENTIAL:"invalid-multi-factor-session",MFA_ENROLLMENT_NOT_FOUND:"multi-factor-info-not-found",MISSING_MFA_ENROLLMENT_ID:"missing-multi-factor-info",MISSING_MFA_PENDING_CREDENTIAL:"missing-multi-factor-session",SECOND_FACTOR_EXISTS:"second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"maximum-second-factor-count-exceeded",BLOCKING_FUNCTION_ERROR_RESPONSE:"internal-error",RECAPTCHA_NOT_ENABLED:"recaptcha-not-enabled",MISSING_RECAPTCHA_TOKEN:"missing-recaptcha-token",INVALID_RECAPTCHA_TOKEN:"invalid-recaptcha-token",INVALID_RECAPTCHA_ACTION:"invalid-recaptcha-action",MISSING_CLIENT_TYPE:"missing-client-type",MISSING_RECAPTCHA_VERSION:"missing-recaptcha-version",INVALID_RECAPTCHA_VERSION:"invalid-recaptcha-version",INVALID_REQ_TYPE:"invalid-req-type"},Ir=new wr(3e4,6e4);function Tr(e,t){return e.tenantId&&!t.tenantId?Object.assign(Object.assign({},t),{tenantId:e.tenantId}):t}async function Nr(e,t,n,r){return Er(e,arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},(async()=>{let s={},a={};r&&("GET"===t?a=r:s={body:JSON.stringify(r)});const i=xt(Object.assign({key:e.config.apiKey},a)).slice(1),o=await e._getAdditionalHeaders();o["Content-Type"]="application/json",e.languageCode&&(o["X-Firebase-Locale"]=e.languageCode);const l=Object.assign({method:t,headers:o},s);return"undefined"!==typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||(l.referrerPolicy="no-referrer"),kr.fetch()(_r(e,e.config.apiHost,n,i),l)}))}async function Er(e,t,n){e._canInitEmulator=!1;const r=Object.assign(Object.assign({},Sr),t);try{const t=new Rr(e),s=await Promise.race([n(),t.promise]);t.clearNetworkTimeout();const a=await s.json();if("needConfirmation"in a)throw $r(e,"account-exists-with-different-credential",a);if(s.ok&&!("errorMessage"in a))return a;{const t=s.ok?a.errorMessage:a.error.message,[n,i]=t.split(" : ");if("FEDERATED_USER_ID_ALREADY_LINKED"===n)throw $r(e,"credential-already-in-use",a);if("EMAIL_EXISTS"===n)throw $r(e,"email-already-in-use",a);if("USER_DISABLED"===n)throw $r(e,"user-disabled",a);const o=r[n]||n.toLowerCase().replace(/[_\s]+/g,"-");if(i)throw cr(e,o,i);lr(e,o)}}catch(t5){if(t5 instanceof gt)throw t5;lr(e,"network-request-failed",{message:String(t5)})}}async function Cr(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const a=await Nr(e,t,n,r,s);return"mfaPendingCredential"in a&&lr(e,"multi-factor-auth-required",{_serverResponse:a}),a}function _r(e,t,n,r){const s=`${t}${n}?${r}`;return e.config.emulator?xr(e.config,s):`${e.config.apiScheme}://${s}`}function Ar(e){switch(e){case"ENFORCE":return"ENFORCE";case"AUDIT":return"AUDIT";case"OFF":return"OFF";default:return"ENFORCEMENT_STATE_UNSPECIFIED"}}class Rr{constructor(e){this.auth=e,this.timer=null,this.promise=new Promise(((e,t)=>{this.timer=setTimeout((()=>t(ur(this.auth,"network-request-failed"))),Ir.get())}))}clearNetworkTimeout(){clearTimeout(this.timer)}}function $r(e,t,n){const r={appName:e.name};n.email&&(r.email=n.email),n.phoneNumber&&(r.phoneNumber=n.phoneNumber);const s=ur(e,t,r);return s.customData._tokenResponse=n,s}function Or(e){return void 0!==e&&void 0!==e.enterprise}class Dr{constructor(e){if(this.siteKey="",this.recaptchaEnforcementState=[],void 0===e.recaptchaKey)throw new Error("recaptchaKey undefined");this.siteKey=e.recaptchaKey.split("/")[3],this.recaptchaEnforcementState=e.recaptchaEnforcementState}getProviderEnforcementState(e){if(!this.recaptchaEnforcementState||0===this.recaptchaEnforcementState.length)return null;for(const t of this.recaptchaEnforcementState)if(t.provider&&t.provider===e)return Ar(t.enforcementState);return null}isProviderEnabled(e){return"ENFORCE"===this.getProviderEnforcementState(e)||"AUDIT"===this.getProviderEnforcementState(e)}isAnyProviderEnabled(){return this.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")||this.isProviderEnabled("PHONE_PROVIDER")}}async function Fr(e,t){return Nr(e,"GET","/v2/recaptchaConfig",Tr(e,t))}async function Lr(e,t){return Nr(e,"POST","/v1/accounts:lookup",t)}function Mr(e){if(e)try{const t=new Date(Number(e));if(!isNaN(t.getTime()))return t.toUTCString()}catch(t5){}}function Pr(e){return 1e3*Number(e)}function zr(e){const[t,n,r]=e.split(".");if(void 0===t||void 0===n||void 0===r)return or("JWT malformed, contained fewer than 3 sections"),null;try{const e=it(n);return e?JSON.parse(e):(or("Failed to decode base64 JWT payload"),null)}catch(t5){return or("Caught error parsing JWT payload as JSON",null===t5||void 0===t5?void 0:t5.toString()),null}}function Br(e){const t=zr(e);return pr(t,"internal-error"),pr("undefined"!==typeof t.exp,"internal-error"),pr("undefined"!==typeof t.iat,"internal-error"),Number(t.exp)-Number(t.iat)}async function Ur(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return t;try{return await t}catch(t5){throw t5 instanceof gt&&function(e){let{code:t}=e;return"auth/user-disabled"===t||"auth/user-token-expired"===t}(t5)&&e.auth.currentUser===e&&await e.auth.signOut(),t5}}class Vr{constructor(e){this.user=e,this.isRunning=!1,this.timerId=null,this.errorBackoff=3e4}_start(){this.isRunning||(this.isRunning=!0,this.schedule())}_stop(){this.isRunning&&(this.isRunning=!1,null!==this.timerId&&clearTimeout(this.timerId))}getInterval(e){var t;if(e){const e=this.errorBackoff;return this.errorBackoff=Math.min(2*this.errorBackoff,96e4),e}{this.errorBackoff=3e4;const e=(null!==(t=this.user.stsTokenManager.expirationTime)&&void 0!==t?t:0)-Date.now()-3e5;return Math.max(0,e)}}schedule(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.isRunning)return;const t=this.getInterval(e);this.timerId=setTimeout((async()=>{await this.iteration()}),t)}async iteration(){try{await this.user.getIdToken(!0)}catch(t5){return void("auth/network-request-failed"===(null===t5||void 0===t5?void 0:t5.code)&&this.schedule(!0))}this.schedule()}}class Wr{constructor(e,t){this.createdAt=e,this.lastLoginAt=t,this._initializeTime()}_initializeTime(){this.lastSignInTime=Mr(this.lastLoginAt),this.creationTime=Mr(this.createdAt)}_copy(e){this.createdAt=e.createdAt,this.lastLoginAt=e.lastLoginAt,this._initializeTime()}toJSON(){return{createdAt:this.createdAt,lastLoginAt:this.lastLoginAt}}}async function jr(e){var t;const n=e.auth,r=await e.getIdToken(),s=await Ur(e,Lr(n,{idToken:r}));pr(null===s||void 0===s?void 0:s.users.length,n,"internal-error");const a=s.users[0];e._notifyReloadListener(a);const i=(null===(t=a.providerUserInfo)||void 0===t?void 0:t.length)?Gr(a.providerUserInfo):[],o=(l=e.providerData,u=i,[...l.filter((e=>!u.some((t=>t.providerId===e.providerId)))),...u]);var l,u;const c=e.isAnonymous,h=!(e.email&&a.passwordHash)&&!(null===o||void 0===o?void 0:o.length),d=!!c&&h,p={uid:a.localId,displayName:a.displayName||null,photoURL:a.photoUrl||null,email:a.email||null,emailVerified:a.emailVerified||!1,phoneNumber:a.phoneNumber||null,tenantId:a.tenantId||null,providerData:o,metadata:new Wr(a.createdAt,a.lastLoginAt),isAnonymous:d};Object.assign(e,p)}function Gr(e){return e.map((e=>{var{providerId:t}=e,n=nr(e,["providerId"]);return{providerId:t,uid:n.rawId||"",displayName:n.displayName||null,email:n.email||null,phoneNumber:n.phoneNumber||null,photoURL:n.photoUrl||null}}))}class Hr{constructor(){this.refreshToken=null,this.accessToken=null,this.expirationTime=null}get isExpired(){return!this.expirationTime||Date.now()>this.expirationTime-3e4}updateFromServerResponse(e){pr(e.idToken,"internal-error"),pr("undefined"!==typeof e.idToken,"internal-error"),pr("undefined"!==typeof e.refreshToken,"internal-error");const t="expiresIn"in e&&"undefined"!==typeof e.expiresIn?Number(e.expiresIn):Br(e.idToken);this.updateTokensAndExpiration(e.idToken,e.refreshToken,t)}updateFromIdToken(e){pr(0!==e.length,"internal-error");const t=Br(e);this.updateTokensAndExpiration(e,null,t)}async getToken(e){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]||!this.accessToken||this.isExpired?(pr(this.refreshToken,e,"user-token-expired"),this.refreshToken?(await this.refresh(e,this.refreshToken),this.accessToken):null):this.accessToken}clearRefreshToken(){this.refreshToken=null}async refresh(e,t){const{accessToken:n,refreshToken:r,expiresIn:s}=await async function(e,t){const n=await Er(e,{},(async()=>{const n=xt({grant_type:"refresh_token",refresh_token:t}).slice(1),{tokenApiHost:r,apiKey:s}=e.config,a=_r(e,r,"/v1/token",`key=${s}`),i=await e._getAdditionalHeaders();return i["Content-Type"]="application/x-www-form-urlencoded",kr.fetch()(a,{method:"POST",headers:i,body:n})}));return{accessToken:n.access_token,expiresIn:n.expires_in,refreshToken:n.refresh_token}}(e,t);this.updateTokensAndExpiration(n,r,Number(s))}updateTokensAndExpiration(e,t,n){this.refreshToken=t||null,this.accessToken=e||null,this.expirationTime=Date.now()+1e3*n}static fromJSON(e,t){const{refreshToken:n,accessToken:r,expirationTime:s}=t,a=new Hr;return n&&(pr("string"===typeof n,"internal-error",{appName:e}),a.refreshToken=n),r&&(pr("string"===typeof r,"internal-error",{appName:e}),a.accessToken=r),s&&(pr("number"===typeof s,"internal-error",{appName:e}),a.expirationTime=s),a}toJSON(){return{refreshToken:this.refreshToken,accessToken:this.accessToken,expirationTime:this.expirationTime}}_assign(e){this.accessToken=e.accessToken,this.refreshToken=e.refreshToken,this.expirationTime=e.expirationTime}_clone(){return Object.assign(new Hr,this.toJSON())}_performRefresh(){return fr("not implemented")}}function qr(e,t){pr("string"===typeof e||"undefined"===typeof e,"internal-error",{appName:t})}class Kr{constructor(e){var{uid:t,auth:n,stsTokenManager:r}=e,s=nr(e,["uid","auth","stsTokenManager"]);this.providerId="firebase",this.proactiveRefresh=new Vr(this),this.reloadUserInfo=null,this.reloadListener=null,this.uid=t,this.auth=n,this.stsTokenManager=r,this.accessToken=r.accessToken,this.displayName=s.displayName||null,this.email=s.email||null,this.emailVerified=s.emailVerified||!1,this.phoneNumber=s.phoneNumber||null,this.photoURL=s.photoURL||null,this.isAnonymous=s.isAnonymous||!1,this.tenantId=s.tenantId||null,this.providerData=s.providerData?[...s.providerData]:[],this.metadata=new Wr(s.createdAt||void 0,s.lastLoginAt||void 0)}async getIdToken(e){const t=await Ur(this,this.stsTokenManager.getToken(this.auth,e));return pr(t,this.auth,"internal-error"),this.accessToken!==t&&(this.accessToken=t,await this.auth._persistUserIfCurrent(this),this.auth._notifyListenersIfCurrent(this)),t}getIdTokenResult(e){return async function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=Nt(e),r=await n.getIdToken(t),s=zr(r);pr(s&&s.exp&&s.auth_time&&s.iat,n.auth,"internal-error");const a="object"===typeof s.firebase?s.firebase:void 0,i=null===a||void 0===a?void 0:a.sign_in_provider;return{claims:s,token:r,authTime:Mr(Pr(s.auth_time)),issuedAtTime:Mr(Pr(s.iat)),expirationTime:Mr(Pr(s.exp)),signInProvider:i||null,signInSecondFactor:(null===a||void 0===a?void 0:a.sign_in_second_factor)||null}}(this,e)}reload(){return async function(e){const t=Nt(e);await jr(t),await t.auth._persistUserIfCurrent(t),t.auth._notifyListenersIfCurrent(t)}(this)}_assign(e){this!==e&&(pr(this.uid===e.uid,this.auth,"internal-error"),this.displayName=e.displayName,this.photoURL=e.photoURL,this.email=e.email,this.emailVerified=e.emailVerified,this.phoneNumber=e.phoneNumber,this.isAnonymous=e.isAnonymous,this.tenantId=e.tenantId,this.providerData=e.providerData.map((e=>Object.assign({},e))),this.metadata._copy(e.metadata),this.stsTokenManager._assign(e.stsTokenManager))}_clone(e){const t=new Kr(Object.assign(Object.assign({},this),{auth:e,stsTokenManager:this.stsTokenManager._clone()}));return t.metadata._copy(this.metadata),t}_onReload(e){pr(!this.reloadListener,this.auth,"internal-error"),this.reloadListener=e,this.reloadUserInfo&&(this._notifyReloadListener(this.reloadUserInfo),this.reloadUserInfo=null)}_notifyReloadListener(e){this.reloadListener?this.reloadListener(e):this.reloadUserInfo=e}_startProactiveRefresh(){this.proactiveRefresh._start()}_stopProactiveRefresh(){this.proactiveRefresh._stop()}async _updateTokensIfNecessary(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!1;e.idToken&&e.idToken!==this.stsTokenManager.accessToken&&(this.stsTokenManager.updateFromServerResponse(e),n=!0),t&&await jr(this),await this.auth._persistUserIfCurrent(this),n&&this.auth._notifyListenersIfCurrent(this)}async delete(){if(zn(this.auth.app))return Promise.reject(hr(this.auth));const e=await this.getIdToken();return await Ur(this,async function(e,t){return Nr(e,"POST","/v1/accounts:delete",t)}(this.auth,{idToken:e})),this.stsTokenManager.clearRefreshToken(),this.auth.signOut()}toJSON(){return Object.assign(Object.assign({uid:this.uid,email:this.email||void 0,emailVerified:this.emailVerified,displayName:this.displayName||void 0,isAnonymous:this.isAnonymous,photoURL:this.photoURL||void 0,phoneNumber:this.phoneNumber||void 0,tenantId:this.tenantId||void 0,providerData:this.providerData.map((e=>Object.assign({},e))),stsTokenManager:this.stsTokenManager.toJSON(),_redirectEventId:this._redirectEventId},this.metadata.toJSON()),{apiKey:this.auth.config.apiKey,appName:this.auth.name})}get refreshToken(){return this.stsTokenManager.refreshToken||""}static _fromJSON(e,t){var n,r,s,a,i,o,l,u;const c=null!==(n=t.displayName)&&void 0!==n?n:void 0,h=null!==(r=t.email)&&void 0!==r?r:void 0,d=null!==(s=t.phoneNumber)&&void 0!==s?s:void 0,p=null!==(a=t.photoURL)&&void 0!==a?a:void 0,f=null!==(i=t.tenantId)&&void 0!==i?i:void 0,m=null!==(o=t._redirectEventId)&&void 0!==o?o:void 0,g=null!==(l=t.createdAt)&&void 0!==l?l:void 0,y=null!==(u=t.lastLoginAt)&&void 0!==u?u:void 0,{uid:b,emailVerified:v,isAnonymous:w,providerData:x,stsTokenManager:k}=t;pr(b&&k,e,"internal-error");const S=Hr.fromJSON(this.name,k);pr("string"===typeof b,e,"internal-error"),qr(c,e.name),qr(h,e.name),pr("boolean"===typeof v,e,"internal-error"),pr("boolean"===typeof w,e,"internal-error"),qr(d,e.name),qr(p,e.name),qr(f,e.name),qr(m,e.name),qr(g,e.name),qr(y,e.name);const I=new Kr({uid:b,auth:e,email:h,emailVerified:v,displayName:c,isAnonymous:w,photoURL:p,phoneNumber:d,tenantId:f,stsTokenManager:S,createdAt:g,lastLoginAt:y});return x&&Array.isArray(x)&&(I.providerData=x.map((e=>Object.assign({},e)))),m&&(I._redirectEventId=m),I}static async _fromIdTokenResponse(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=new Hr;r.updateFromServerResponse(t);const s=new Kr({uid:t.localId,auth:e,stsTokenManager:r,isAnonymous:n});return await jr(s),s}static async _fromGetAccountInfoResponse(e,t,n){const r=t.users[0];pr(void 0!==r.localId,"internal-error");const s=void 0!==r.providerUserInfo?Gr(r.providerUserInfo):[],a=!(r.email&&r.passwordHash)&&!(null===s||void 0===s?void 0:s.length),i=new Hr;i.updateFromIdToken(n);const o=new Kr({uid:r.localId,auth:e,stsTokenManager:i,isAnonymous:a}),l={uid:r.localId,displayName:r.displayName||null,photoURL:r.photoUrl||null,email:r.email||null,emailVerified:r.emailVerified||!1,phoneNumber:r.phoneNumber||null,tenantId:r.tenantId||null,providerData:s,metadata:new Wr(r.createdAt,r.lastLoginAt),isAnonymous:!(r.email&&r.passwordHash)&&!(null===s||void 0===s?void 0:s.length)};return Object.assign(o,l),o}}const Xr=new Map;function Yr(e){mr(e instanceof Function,"Expected a class definition");let t=Xr.get(e);return t?(mr(t instanceof e,"Instance stored in cache mismatched with class"),t):(t=new e,Xr.set(e,t),t)}class Qr{constructor(){this.type="NONE",this.storage={}}async _isAvailable(){return!0}async _set(e,t){this.storage[e]=t}async _get(e){const t=this.storage[e];return void 0===t?null:t}async _remove(e){delete this.storage[e]}_addListener(e,t){}_removeListener(e,t){}}Qr.type="NONE";const Jr=Qr;function Zr(e,t,n){return`firebase:${e}:${t}:${n}`}class es{constructor(e,t,n){this.persistence=e,this.auth=t,this.userKey=n;const{config:r,name:s}=this.auth;this.fullUserKey=Zr(this.userKey,r.apiKey,s),this.fullPersistenceKey=Zr("persistence",r.apiKey,s),this.boundEventHandler=t._onStorageEvent.bind(t),this.persistence._addListener(this.fullUserKey,this.boundEventHandler)}setCurrentUser(e){return this.persistence._set(this.fullUserKey,e.toJSON())}async getCurrentUser(){const e=await this.persistence._get(this.fullUserKey);return e?Kr._fromJSON(this.auth,e):null}removeCurrentUser(){return this.persistence._remove(this.fullUserKey)}savePersistenceForRedirect(){return this.persistence._set(this.fullPersistenceKey,this.persistence.type)}async setPersistence(e){if(this.persistence===e)return;const t=await this.getCurrentUser();return await this.removeCurrentUser(),this.persistence=e,t?this.setCurrentUser(t):void 0}delete(){this.persistence._removeListener(this.fullUserKey,this.boundEventHandler)}static async create(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"authUser";if(!t.length)return new es(Yr(Jr),e,n);const r=(await Promise.all(t.map((async e=>{if(await e._isAvailable())return e})))).filter((e=>e));let s=r[0]||Yr(Jr);const a=Zr(n,e.config.apiKey,e.name);let i=null;for(const u of t)try{const t=await u._get(a);if(t){const n=Kr._fromJSON(e,t);u!==s&&(i=n),s=u;break}}catch(l){}const o=r.filter((e=>e._shouldAllowMigration));return s._shouldAllowMigration&&o.length?(s=o[0],i&&await s._set(a,i.toJSON()),await Promise.all(t.map((async e=>{if(e!==s)try{await e._remove(a)}catch(l){}}))),new es(s,e,n)):new es(s,e,n)}}function ts(e){const t=e.toLowerCase();if(t.includes("opera/")||t.includes("opr/")||t.includes("opios/"))return"Opera";if(as(t))return"IEMobile";if(t.includes("msie")||t.includes("trident/"))return"IE";if(t.includes("edge/"))return"Edge";if(ns(t))return"Firefox";if(t.includes("silk/"))return"Silk";if(os(t))return"Blackberry";if(ls(t))return"Webos";if(rs(t))return"Safari";if((t.includes("chrome/")||ss(t))&&!t.includes("edge/"))return"Chrome";if(is(t))return"Android";{const t=/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,n=e.match(t);if(2===(null===n||void 0===n?void 0:n.length))return n[1]}return"Other"}function ns(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/firefox\//i.test(e)}function rs(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt()).toLowerCase();return e.includes("safari/")&&!e.includes("chrome/")&&!e.includes("crios/")&&!e.includes("android")}function ss(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/crios\//i.test(e)}function as(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/iemobile/i.test(e)}function is(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/android/i.test(e)}function os(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/blackberry/i.test(e)}function ls(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/webos/i.test(e)}function us(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return/iphone|ipad|ipod/i.test(e)||/macintosh/i.test(e)&&/mobile/i.test(e)}function cs(){return function(){const e=pt();return e.indexOf("MSIE ")>=0||e.indexOf("Trident/")>=0}()&&10===document.documentMode}function hs(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt();return us(e)||is(e)||ls(e)||os(e)||/windows phone/i.test(e)||as(e)}function ds(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];switch(e){case"Browser":t=ts(pt());break;case"Worker":t=`${ts(pt())}-${e}`;break;default:t=e}const r=n.length?n.join(","):"FirebaseCore-web";return`${t}/JsCore/${Vn}/${r}`}class ps{constructor(e){this.auth=e,this.queue=[]}pushCallback(e,t){const n=t=>new Promise(((n,r)=>{try{n(e(t))}catch(t5){r(t5)}}));n.onAbort=t,this.queue.push(n);const r=this.queue.length-1;return()=>{this.queue[r]=()=>Promise.resolve()}}async runMiddleware(e){if(this.auth.currentUser===e)return;const t=[];try{for(const n of this.queue)await n(e),n.onAbort&&t.push(n.onAbort)}catch(t5){t.reverse();for(const r of t)try{r()}catch(n){}throw this.auth._errorFactory.create("login-blocked",{originalMessage:null===t5||void 0===t5?void 0:t5.message})}}}class fs{constructor(e){var t,n,r,s;const a=e.customStrengthOptions;this.customStrengthOptions={},this.customStrengthOptions.minPasswordLength=null!==(t=a.minPasswordLength)&&void 0!==t?t:6,a.maxPasswordLength&&(this.customStrengthOptions.maxPasswordLength=a.maxPasswordLength),void 0!==a.containsLowercaseCharacter&&(this.customStrengthOptions.containsLowercaseLetter=a.containsLowercaseCharacter),void 0!==a.containsUppercaseCharacter&&(this.customStrengthOptions.containsUppercaseLetter=a.containsUppercaseCharacter),void 0!==a.containsNumericCharacter&&(this.customStrengthOptions.containsNumericCharacter=a.containsNumericCharacter),void 0!==a.containsNonAlphanumericCharacter&&(this.customStrengthOptions.containsNonAlphanumericCharacter=a.containsNonAlphanumericCharacter),this.enforcementState=e.enforcementState,"ENFORCEMENT_STATE_UNSPECIFIED"===this.enforcementState&&(this.enforcementState="OFF"),this.allowedNonAlphanumericCharacters=null!==(r=null===(n=e.allowedNonAlphanumericCharacters)||void 0===n?void 0:n.join(""))&&void 0!==r?r:"",this.forceUpgradeOnSignin=null!==(s=e.forceUpgradeOnSignin)&&void 0!==s&&s,this.schemaVersion=e.schemaVersion}validatePassword(e){var t,n,r,s,a,i;const o={isValid:!0,passwordPolicy:this};return this.validatePasswordLengthOptions(e,o),this.validatePasswordCharacterOptions(e,o),o.isValid&&(o.isValid=null===(t=o.meetsMinPasswordLength)||void 0===t||t),o.isValid&&(o.isValid=null===(n=o.meetsMaxPasswordLength)||void 0===n||n),o.isValid&&(o.isValid=null===(r=o.containsLowercaseLetter)||void 0===r||r),o.isValid&&(o.isValid=null===(s=o.containsUppercaseLetter)||void 0===s||s),o.isValid&&(o.isValid=null===(a=o.containsNumericCharacter)||void 0===a||a),o.isValid&&(o.isValid=null===(i=o.containsNonAlphanumericCharacter)||void 0===i||i),o}validatePasswordLengthOptions(e,t){const n=this.customStrengthOptions.minPasswordLength,r=this.customStrengthOptions.maxPasswordLength;n&&(t.meetsMinPasswordLength=e.length>=n),r&&(t.meetsMaxPasswordLength=e.length<=r)}validatePasswordCharacterOptions(e,t){let n;this.updatePasswordCharacterOptionsStatuses(t,!1,!1,!1,!1);for(let r=0;r<e.length;r++)n=e.charAt(r),this.updatePasswordCharacterOptionsStatuses(t,n>="a"&&n<="z",n>="A"&&n<="Z",n>="0"&&n<="9",this.allowedNonAlphanumericCharacters.includes(n))}updatePasswordCharacterOptionsStatuses(e,t,n,r,s){this.customStrengthOptions.containsLowercaseLetter&&(e.containsLowercaseLetter||(e.containsLowercaseLetter=t)),this.customStrengthOptions.containsUppercaseLetter&&(e.containsUppercaseLetter||(e.containsUppercaseLetter=n)),this.customStrengthOptions.containsNumericCharacter&&(e.containsNumericCharacter||(e.containsNumericCharacter=r)),this.customStrengthOptions.containsNonAlphanumericCharacter&&(e.containsNonAlphanumericCharacter||(e.containsNonAlphanumericCharacter=s))}}class ms{constructor(e,t,n,r){this.app=e,this.heartbeatServiceProvider=t,this.appCheckServiceProvider=n,this.config=r,this.currentUser=null,this.emulatorConfig=null,this.operations=Promise.resolve(),this.authStateSubscription=new ys(this),this.idTokenSubscription=new ys(this),this.beforeStateQueue=new ps(this),this.redirectUser=null,this.isProactiveRefreshEnabled=!1,this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION=1,this._canInitEmulator=!0,this._isInitialized=!1,this._deleted=!1,this._initializationPromise=null,this._popupRedirectResolver=null,this._errorFactory=ar,this._agentRecaptchaConfig=null,this._tenantRecaptchaConfigs={},this._projectPasswordPolicy=null,this._tenantPasswordPolicies={},this.lastNotifiedUid=void 0,this.languageCode=null,this.tenantId=null,this.settings={appVerificationDisabledForTesting:!1},this.frameworks=[],this.name=e.name,this.clientVersion=r.sdkClientVersion}_initializeWithPersistence(e,t){return t&&(this._popupRedirectResolver=Yr(t)),this._initializationPromise=this.queue((async()=>{var n,r;if(!this._deleted&&(this.persistenceManager=await es.create(this,e),!this._deleted)){if(null===(n=this._popupRedirectResolver)||void 0===n?void 0:n._shouldInitProactively)try{await this._popupRedirectResolver._initialize(this)}catch(t5){}await this.initializeCurrentUser(t),this.lastNotifiedUid=(null===(r=this.currentUser)||void 0===r?void 0:r.uid)||null,this._deleted||(this._isInitialized=!0)}})),this._initializationPromise}async _onStorageEvent(){if(this._deleted)return;const e=await this.assertedPersistence.getCurrentUser();return this.currentUser||e?this.currentUser&&e&&this.currentUser.uid===e.uid?(this._currentUser._assign(e),void await this.currentUser.getIdToken()):void await this._updateCurrentUser(e,!0):void 0}async initializeCurrentUserFromIdToken(e){try{const t=await Lr(this,{idToken:e}),n=await Kr._fromGetAccountInfoResponse(this,t,e);await this.directlySetCurrentUser(n)}catch(t){console.warn("FirebaseServerApp could not login user with provided authIdToken: ",t),await this.directlySetCurrentUser(null)}}async initializeCurrentUser(e){var t;if(zn(this.app)){const e=this.app.settings.authIdToken;return e?new Promise((t=>{setTimeout((()=>this.initializeCurrentUserFromIdToken(e).then(t,t)))})):this.directlySetCurrentUser(null)}const n=await this.assertedPersistence.getCurrentUser();let r=n,s=!1;if(e&&this.config.authDomain){await this.getOrInitRedirectPersistenceManager();const n=null===(t=this.redirectUser)||void 0===t?void 0:t._redirectEventId,a=null===r||void 0===r?void 0:r._redirectEventId,i=await this.tryRedirectSignIn(e);n&&n!==a||!(null===i||void 0===i?void 0:i.user)||(r=i.user,s=!0)}if(!r)return this.directlySetCurrentUser(null);if(!r._redirectEventId){if(s)try{await this.beforeStateQueue.runMiddleware(r)}catch(t5){r=n,this._popupRedirectResolver._overrideRedirectResult(this,(()=>Promise.reject(t5)))}return r?this.reloadAndSetCurrentUserOrClear(r):this.directlySetCurrentUser(null)}return pr(this._popupRedirectResolver,this,"argument-error"),await this.getOrInitRedirectPersistenceManager(),this.redirectUser&&this.redirectUser._redirectEventId===r._redirectEventId?this.directlySetCurrentUser(r):this.reloadAndSetCurrentUserOrClear(r)}async tryRedirectSignIn(e){let t=null;try{t=await this._popupRedirectResolver._completeRedirectFn(this,e,!0)}catch(t5){await this._setRedirectUser(null)}return t}async reloadAndSetCurrentUserOrClear(e){try{await jr(e)}catch(t5){if("auth/network-request-failed"!==(null===t5||void 0===t5?void 0:t5.code))return this.directlySetCurrentUser(null)}return this.directlySetCurrentUser(e)}useDeviceLanguage(){this.languageCode=function(){if("undefined"===typeof navigator)return null;const e=navigator;return e.languages&&e.languages[0]||e.language||null}()}async _delete(){this._deleted=!0}async updateCurrentUser(e){if(zn(this.app))return Promise.reject(hr(this));const t=e?Nt(e):null;return t&&pr(t.auth.config.apiKey===this.config.apiKey,this,"invalid-user-token"),this._updateCurrentUser(t&&t._clone(this))}async _updateCurrentUser(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this._deleted)return e&&pr(this.tenantId===e.tenantId,this,"tenant-id-mismatch"),t||await this.beforeStateQueue.runMiddleware(e),this.queue((async()=>{await this.directlySetCurrentUser(e),this.notifyAuthListeners()}))}async signOut(){return zn(this.app)?Promise.reject(hr(this)):(await this.beforeStateQueue.runMiddleware(null),(this.redirectPersistenceManager||this._popupRedirectResolver)&&await this._setRedirectUser(null),this._updateCurrentUser(null,!0))}setPersistence(e){return zn(this.app)?Promise.reject(hr(this)):this.queue((async()=>{await this.assertedPersistence.setPersistence(Yr(e))}))}_getRecaptchaConfig(){return null==this.tenantId?this._agentRecaptchaConfig:this._tenantRecaptchaConfigs[this.tenantId]}async validatePassword(e){this._getPasswordPolicyInternal()||await this._updatePasswordPolicy();const t=this._getPasswordPolicyInternal();return t.schemaVersion!==this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION?Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version",{})):t.validatePassword(e)}_getPasswordPolicyInternal(){return null===this.tenantId?this._projectPasswordPolicy:this._tenantPasswordPolicies[this.tenantId]}async _updatePasswordPolicy(){const e=await async function(e){return Nr(e,"GET","/v2/passwordPolicy",Tr(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}))}(this),t=new fs(e);null===this.tenantId?this._projectPasswordPolicy=t:this._tenantPasswordPolicies[this.tenantId]=t}_getPersistence(){return this.assertedPersistence.persistence.type}_updateErrorMap(e){this._errorFactory=new yt("auth","Firebase",e())}onAuthStateChanged(e,t,n){return this.registerStateListener(this.authStateSubscription,e,t,n)}beforeAuthStateChanged(e,t){return this.beforeStateQueue.pushCallback(e,t)}onIdTokenChanged(e,t,n){return this.registerStateListener(this.idTokenSubscription,e,t,n)}authStateReady(){return new Promise(((e,t)=>{if(this.currentUser)e();else{const n=this.onAuthStateChanged((()=>{n(),e()}),t)}}))}async revokeAccessToken(e){if(this.currentUser){const t={providerId:"apple.com",tokenType:"ACCESS_TOKEN",token:e,idToken:await this.currentUser.getIdToken()};null!=this.tenantId&&(t.tenantId=this.tenantId),await async function(e,t){return Nr(e,"POST","/v2/accounts:revokeToken",Tr(e,t))}(this,t)}}toJSON(){var e;return{apiKey:this.config.apiKey,authDomain:this.config.authDomain,appName:this.name,currentUser:null===(e=this._currentUser)||void 0===e?void 0:e.toJSON()}}async _setRedirectUser(e,t){const n=await this.getOrInitRedirectPersistenceManager(t);return null===e?n.removeCurrentUser():n.setCurrentUser(e)}async getOrInitRedirectPersistenceManager(e){if(!this.redirectPersistenceManager){const t=e&&Yr(e)||this._popupRedirectResolver;pr(t,this,"argument-error"),this.redirectPersistenceManager=await es.create(this,[Yr(t._redirectPersistence)],"redirectUser"),this.redirectUser=await this.redirectPersistenceManager.getCurrentUser()}return this.redirectPersistenceManager}async _redirectUserForId(e){var t,n;return this._isInitialized&&await this.queue((async()=>{})),(null===(t=this._currentUser)||void 0===t?void 0:t._redirectEventId)===e?this._currentUser:(null===(n=this.redirectUser)||void 0===n?void 0:n._redirectEventId)===e?this.redirectUser:null}async _persistUserIfCurrent(e){if(e===this.currentUser)return this.queue((async()=>this.directlySetCurrentUser(e)))}_notifyListenersIfCurrent(e){e===this.currentUser&&this.notifyAuthListeners()}_key(){return`${this.config.authDomain}:${this.config.apiKey}:${this.name}`}_startProactiveRefresh(){this.isProactiveRefreshEnabled=!0,this.currentUser&&this._currentUser._startProactiveRefresh()}_stopProactiveRefresh(){this.isProactiveRefreshEnabled=!1,this.currentUser&&this._currentUser._stopProactiveRefresh()}get _currentUser(){return this.currentUser}notifyAuthListeners(){var e,t;if(!this._isInitialized)return;this.idTokenSubscription.next(this.currentUser);const n=null!==(t=null===(e=this.currentUser)||void 0===e?void 0:e.uid)&&void 0!==t?t:null;this.lastNotifiedUid!==n&&(this.lastNotifiedUid=n,this.authStateSubscription.next(this.currentUser))}registerStateListener(e,t,n,r){if(this._deleted)return()=>{};const s="function"===typeof t?t:t.next.bind(t);let a=!1;const i=this._isInitialized?Promise.resolve():this._initializationPromise;if(pr(i,this,"internal-error"),i.then((()=>{a||s(this.currentUser)})),"function"===typeof t){const s=e.addObserver(t,n,r);return()=>{a=!0,s()}}{const n=e.addObserver(t);return()=>{a=!0,n()}}}async directlySetCurrentUser(e){this.currentUser&&this.currentUser!==e&&this._currentUser._stopProactiveRefresh(),e&&this.isProactiveRefreshEnabled&&e._startProactiveRefresh(),this.currentUser=e,e?await this.assertedPersistence.setCurrentUser(e):await this.assertedPersistence.removeCurrentUser()}queue(e){return this.operations=this.operations.then(e,e),this.operations}get assertedPersistence(){return pr(this.persistenceManager,this,"internal-error"),this.persistenceManager}_logFramework(e){e&&!this.frameworks.includes(e)&&(this.frameworks.push(e),this.frameworks.sort(),this.clientVersion=ds(this.config.clientPlatform,this._getFrameworks()))}_getFrameworks(){return this.frameworks}async _getAdditionalHeaders(){var e;const t={"X-Client-Version":this.clientVersion};this.app.options.appId&&(t["X-Firebase-gmpid"]=this.app.options.appId);const n=await(null===(e=this.heartbeatServiceProvider.getImmediate({optional:!0}))||void 0===e?void 0:e.getHeartbeatsHeader());n&&(t["X-Firebase-Client"]=n);const r=await this._getAppCheckToken();return r&&(t["X-Firebase-AppCheck"]=r),t}async _getAppCheckToken(){var e;const t=await(null===(e=this.appCheckServiceProvider.getImmediate({optional:!0}))||void 0===e?void 0:e.getToken());return(null===t||void 0===t?void 0:t.error)&&function(e){if(ir.logLevel<=$t.WARN){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];ir.warn(`Auth (${Vn}): ${e}`,...n)}}(`Error while retrieving App Check token: ${t.error}`),null===t||void 0===t?void 0:t.token}}function gs(e){return Nt(e)}class ys{constructor(e){this.auth=e,this.observer=null,this.addObserver=function(e,t){const n=new It(e,t);return n.subscribe.bind(n)}((e=>this.observer=e))}get next(){return pr(this.observer,this.auth,"internal-error"),this.observer.next.bind(this.observer)}}let bs={async loadJS(){throw new Error("Unable to load external scripts")},recaptchaV2Script:"",recaptchaEnterpriseScript:"",gapiScript:""};function vs(e){return bs.loadJS(e)}function ws(e){return`__${e}${Math.floor(1e6*Math.random())}`}class xs{constructor(){this.enterprise=new ks}ready(e){e()}execute(e,t){return Promise.resolve("token")}render(e,t){return""}}class ks{ready(e){e()}execute(e,t){return Promise.resolve("token")}render(e,t){return""}}const Ss="NO_RECAPTCHA";class Is{constructor(e){this.type="recaptcha-enterprise",this.auth=gs(e)}async verify(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"verify",t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];function n(t,n,r){const s=window.grecaptcha;Or(s)?s.enterprise.ready((()=>{s.enterprise.execute(t,{action:e}).then((e=>{n(e)})).catch((()=>{n(Ss)}))})):r(Error("No reCAPTCHA enterprise script loaded."))}if(this.auth.settings.appVerificationDisabledForTesting){return(new xs).execute("siteKey",{action:"verify"})}return new Promise(((e,r)=>{(async function(e){if(!t){if(null==e.tenantId&&null!=e._agentRecaptchaConfig)return e._agentRecaptchaConfig.siteKey;if(null!=e.tenantId&&void 0!==e._tenantRecaptchaConfigs[e.tenantId])return e._tenantRecaptchaConfigs[e.tenantId].siteKey}return new Promise((async(t,n)=>{Fr(e,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"}).then((r=>{if(void 0!==r.recaptchaKey){const n=new Dr(r);return null==e.tenantId?e._agentRecaptchaConfig=n:e._tenantRecaptchaConfigs[e.tenantId]=n,t(n.siteKey)}n(new Error("recaptcha Enterprise site key undefined"))})).catch((e=>{n(e)}))}))})(this.auth).then((s=>{if(!t&&Or(window.grecaptcha))n(s,e,r);else{if("undefined"===typeof window)return void r(new Error("RecaptchaVerifier is only supported in browser"));let t=bs.recaptchaEnterpriseScript;0!==t.length&&(t+=s),vs(t).then((()=>{n(s,e,r)})).catch((e=>{r(e)}))}})).catch((e=>{r(e)}))}))}}async function Ts(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const a=new Is(e);let i;if(s)i=Ss;else try{i=await a.verify(n)}catch(l){i=await a.verify(n,!0)}const o=Object.assign({},t);if("mfaSmsEnrollment"===n||"mfaSmsSignIn"===n){if("phoneEnrollmentInfo"in o){const e=o.phoneEnrollmentInfo.phoneNumber,t=o.phoneEnrollmentInfo.recaptchaToken;Object.assign(o,{phoneEnrollmentInfo:{phoneNumber:e,recaptchaToken:t,captchaResponse:i,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}else if("phoneSignInInfo"in o){const e=o.phoneSignInInfo.recaptchaToken;Object.assign(o,{phoneSignInInfo:{recaptchaToken:e,captchaResponse:i,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}return o}return r?Object.assign(o,{captchaResp:i}):Object.assign(o,{captchaResponse:i}),Object.assign(o,{clientType:"CLIENT_TYPE_WEB"}),Object.assign(o,{recaptchaVersion:"RECAPTCHA_ENTERPRISE"}),o}async function Ns(e,t,n,r,s){var a,i;if("EMAIL_PASSWORD_PROVIDER"===s){if(null===(a=e._getRecaptchaConfig())||void 0===a?void 0:a.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")){const s=await Ts(e,t,n,"getOobCode"===n);return r(e,s)}return r(e,t).catch((async s=>{if("auth/missing-recaptcha-token"===s.code){console.log(`${n} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);const s=await Ts(e,t,n,"getOobCode"===n);return r(e,s)}return Promise.reject(s)}))}if("PHONE_PROVIDER"===s){if(null===(i=e._getRecaptchaConfig())||void 0===i?void 0:i.isProviderEnabled("PHONE_PROVIDER")){const s=await Ts(e,t,n);return r(e,s).catch((async s=>{var a;if("AUDIT"===(null===(a=e._getRecaptchaConfig())||void 0===a?void 0:a.getProviderEnforcementState("PHONE_PROVIDER"))&&("auth/missing-recaptcha-token"===s.code||"auth/invalid-app-credential"===s.code)){console.log(`Failed to verify with reCAPTCHA Enterprise. Automatically triggering the reCAPTCHA v2 flow to complete the ${n} flow.`);const s=await Ts(e,t,n,!1,!0);return r(e,s)}return Promise.reject(s)}))}{const s=await Ts(e,t,n,!1,!0);return r(e,s)}}return Promise.reject(s+" provider is not supported.")}async function Es(e){const t=gs(e),n=await Fr(t,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"}),r=new Dr(n);if(null==t.tenantId?t._agentRecaptchaConfig=r:t._tenantRecaptchaConfigs[t.tenantId]=r,r.isAnyProviderEnabled()){new Is(t).verify()}}function Cs(e,t,n){const r=gs(e);pr(r._canInitEmulator,r,"emulator-config-failed"),pr(/^https?:\/\//.test(t),r,"invalid-emulator-scheme");const s=!!(null===n||void 0===n?void 0:n.disableWarnings),a=_s(t),{host:i,port:o}=function(e){const t=_s(e),n=/(\/\/)?([^?#/]+)/.exec(e.substr(t.length));if(!n)return{host:"",port:null};const r=n[2].split("@").pop()||"",s=/^(\[[^\]]+\])(:|$)/.exec(r);if(s){const e=s[1];return{host:e,port:As(r.substr(e.length+1))}}{const[e,t]=r.split(":");return{host:e,port:As(t)}}}(t),l=null===o?"":`:${o}`;r.config.emulator={url:`${a}//${i}${l}/`},r.settings.appVerificationDisabledForTesting=!0,r.emulatorConfig=Object.freeze({host:i,port:o,protocol:a.replace(":",""),options:Object.freeze({disableWarnings:s})}),s||function(){function e(){const e=document.createElement("p"),t=e.style;e.innerText="Running in emulator mode. Do not use with production credentials.",t.position="fixed",t.width="100%",t.backgroundColor="#ffffff",t.border=".1em solid #000000",t.color="#b50000",t.bottom="0px",t.left="0px",t.margin="0px",t.zIndex="10000",t.textAlign="center",e.classList.add("firebase-emulator-warning"),document.body.appendChild(e)}"undefined"!==typeof console&&"function"===typeof console.info&&console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");"undefined"!==typeof window&&"undefined"!==typeof document&&("loading"===document.readyState?window.addEventListener("DOMContentLoaded",e):e())}()}function _s(e){const t=e.indexOf(":");return t<0?"":e.substr(0,t+1)}function As(e){if(!e)return null;const t=Number(e);return isNaN(t)?null:t}class Rs{constructor(e,t){this.providerId=e,this.signInMethod=t}toJSON(){return fr("not implemented")}_getIdTokenResponse(e){return fr("not implemented")}_linkToIdToken(e,t){return fr("not implemented")}_getReauthenticationResolver(e){return fr("not implemented")}}async function $s(e,t){return Nr(e,"POST","/v1/accounts:signUp",t)}async function Os(e,t){return Cr(e,"POST","/v1/accounts:signInWithPassword",Tr(e,t))}class Ds extends Rs{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super("password",n),this._email=e,this._password=t,this._tenantId=r}static _fromEmailAndPassword(e,t){return new Ds(e,t,"password")}static _fromEmailAndCode(e,t){return new Ds(e,t,"emailLink",arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}toJSON(){return{email:this._email,password:this._password,signInMethod:this.signInMethod,tenantId:this._tenantId}}static fromJSON(e){const t="string"===typeof e?JSON.parse(e):e;if((null===t||void 0===t?void 0:t.email)&&(null===t||void 0===t?void 0:t.password)){if("password"===t.signInMethod)return this._fromEmailAndPassword(t.email,t.password);if("emailLink"===t.signInMethod)return this._fromEmailAndCode(t.email,t.password,t.tenantId)}return null}async _getIdTokenResponse(e){switch(this.signInMethod){case"password":return Ns(e,{returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"},"signInWithPassword",Os,"EMAIL_PASSWORD_PROVIDER");case"emailLink":return async function(e,t){return Cr(e,"POST","/v1/accounts:signInWithEmailLink",Tr(e,t))}(e,{email:this._email,oobCode:this._password});default:lr(e,"internal-error")}}async _linkToIdToken(e,t){switch(this.signInMethod){case"password":return Ns(e,{idToken:t,returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"},"signUpPassword",$s,"EMAIL_PASSWORD_PROVIDER");case"emailLink":return async function(e,t){return Cr(e,"POST","/v1/accounts:signInWithEmailLink",Tr(e,t))}(e,{idToken:t,email:this._email,oobCode:this._password});default:lr(e,"internal-error")}}_getReauthenticationResolver(e){return this._getIdTokenResponse(e)}}async function Fs(e,t){return Cr(e,"POST","/v1/accounts:signInWithIdp",Tr(e,t))}class Ls extends Rs{constructor(){super(...arguments),this.pendingToken=null}static _fromParams(e){const t=new Ls(e.providerId,e.signInMethod);return e.idToken||e.accessToken?(e.idToken&&(t.idToken=e.idToken),e.accessToken&&(t.accessToken=e.accessToken),e.nonce&&!e.pendingToken&&(t.nonce=e.nonce),e.pendingToken&&(t.pendingToken=e.pendingToken)):e.oauthToken&&e.oauthTokenSecret?(t.accessToken=e.oauthToken,t.secret=e.oauthTokenSecret):lr("argument-error"),t}toJSON(){return{idToken:this.idToken,accessToken:this.accessToken,secret:this.secret,nonce:this.nonce,pendingToken:this.pendingToken,providerId:this.providerId,signInMethod:this.signInMethod}}static fromJSON(e){const t="string"===typeof e?JSON.parse(e):e,{providerId:n,signInMethod:r}=t,s=nr(t,["providerId","signInMethod"]);if(!n||!r)return null;const a=new Ls(n,r);return a.idToken=s.idToken||void 0,a.accessToken=s.accessToken||void 0,a.secret=s.secret,a.nonce=s.nonce,a.pendingToken=s.pendingToken||null,a}_getIdTokenResponse(e){return Fs(e,this.buildRequest())}_linkToIdToken(e,t){const n=this.buildRequest();return n.idToken=t,Fs(e,n)}_getReauthenticationResolver(e){const t=this.buildRequest();return t.autoCreate=!1,Fs(e,t)}buildRequest(){const e={requestUri:"http://localhost",returnSecureToken:!0};if(this.pendingToken)e.pendingToken=this.pendingToken;else{const t={};this.idToken&&(t.id_token=this.idToken),this.accessToken&&(t.access_token=this.accessToken),this.secret&&(t.oauth_token_secret=this.secret),t.providerId=this.providerId,this.nonce&&!this.pendingToken&&(t.nonce=this.nonce),e.postBody=xt(t)}return e}}async function Ms(e,t){return Nr(e,"POST","/v1/accounts:sendVerificationCode",Tr(e,t))}const Ps={USER_NOT_FOUND:"user-not-found"};class zs extends Rs{constructor(e){super("phone","phone"),this.params=e}static _fromVerification(e,t){return new zs({verificationId:e,verificationCode:t})}static _fromTokenResponse(e,t){return new zs({phoneNumber:e,temporaryProof:t})}_getIdTokenResponse(e){return async function(e,t){return Cr(e,"POST","/v1/accounts:signInWithPhoneNumber",Tr(e,t))}(e,this._makeVerificationRequest())}_linkToIdToken(e,t){return async function(e,t){const n=await Cr(e,"POST","/v1/accounts:signInWithPhoneNumber",Tr(e,t));if(n.temporaryProof)throw $r(e,"account-exists-with-different-credential",n);return n}(e,Object.assign({idToken:t},this._makeVerificationRequest()))}_getReauthenticationResolver(e){return async function(e,t){return Cr(e,"POST","/v1/accounts:signInWithPhoneNumber",Tr(e,Object.assign(Object.assign({},t),{operation:"REAUTH"})),Ps)}(e,this._makeVerificationRequest())}_makeVerificationRequest(){const{temporaryProof:e,phoneNumber:t,verificationId:n,verificationCode:r}=this.params;return e&&t?{temporaryProof:e,phoneNumber:t}:{sessionInfo:n,code:r}}toJSON(){const e={providerId:this.providerId};return this.params.phoneNumber&&(e.phoneNumber=this.params.phoneNumber),this.params.temporaryProof&&(e.temporaryProof=this.params.temporaryProof),this.params.verificationCode&&(e.verificationCode=this.params.verificationCode),this.params.verificationId&&(e.verificationId=this.params.verificationId),e}static fromJSON(e){"string"===typeof e&&(e=JSON.parse(e));const{verificationId:t,verificationCode:n,phoneNumber:r,temporaryProof:s}=e;return n||t||r||s?new zs({verificationId:t,verificationCode:n,phoneNumber:r,temporaryProof:s}):null}}class Bs{constructor(e){var t,n,r,s,a,i;const o=kt(St(e)),l=null!==(t=o.apiKey)&&void 0!==t?t:null,u=null!==(n=o.oobCode)&&void 0!==n?n:null,c=function(e){switch(e){case"recoverEmail":return"RECOVER_EMAIL";case"resetPassword":return"PASSWORD_RESET";case"signIn":return"EMAIL_SIGNIN";case"verifyEmail":return"VERIFY_EMAIL";case"verifyAndChangeEmail":return"VERIFY_AND_CHANGE_EMAIL";case"revertSecondFactorAddition":return"REVERT_SECOND_FACTOR_ADDITION";default:return null}}(null!==(r=o.mode)&&void 0!==r?r:null);pr(l&&u&&c,"argument-error"),this.apiKey=l,this.operation=c,this.code=u,this.continueUrl=null!==(s=o.continueUrl)&&void 0!==s?s:null,this.languageCode=null!==(a=o.languageCode)&&void 0!==a?a:null,this.tenantId=null!==(i=o.tenantId)&&void 0!==i?i:null}static parseLink(e){const t=function(e){const t=kt(St(e)).link,n=t?kt(St(t)).deep_link_id:null,r=kt(St(e)).deep_link_id;return(r?kt(St(r)).link:null)||r||n||t||e}(e);try{return new Bs(t)}catch(n){return null}}}class Us{constructor(){this.providerId=Us.PROVIDER_ID}static credential(e,t){return Ds._fromEmailAndPassword(e,t)}static credentialWithLink(e,t){const n=Bs.parseLink(t);return pr(n,"argument-error"),Ds._fromEmailAndCode(e,n.code,n.tenantId)}}Us.PROVIDER_ID="password",Us.EMAIL_PASSWORD_SIGN_IN_METHOD="password",Us.EMAIL_LINK_SIGN_IN_METHOD="emailLink";class Vs{constructor(e){this.providerId=e,this.defaultLanguageCode=null,this.customParameters={}}setDefaultLanguage(e){this.defaultLanguageCode=e}setCustomParameters(e){return this.customParameters=e,this}getCustomParameters(){return this.customParameters}}class Ws extends Vs{constructor(){super(...arguments),this.scopes=[]}addScope(e){return this.scopes.includes(e)||this.scopes.push(e),this}getScopes(){return[...this.scopes]}}class js extends Ws{constructor(){super("facebook.com")}static credential(e){return Ls._fromParams({providerId:js.PROVIDER_ID,signInMethod:js.FACEBOOK_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return js.credentialFromTaggedObject(e)}static credentialFromError(e){return js.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject(e){let{_tokenResponse:t}=e;if(!t||!("oauthAccessToken"in t))return null;if(!t.oauthAccessToken)return null;try{return js.credential(t.oauthAccessToken)}catch(n){return null}}}js.FACEBOOK_SIGN_IN_METHOD="facebook.com",js.PROVIDER_ID="facebook.com";class Gs extends Ws{constructor(){super("google.com"),this.addScope("profile")}static credential(e,t){return Ls._fromParams({providerId:Gs.PROVIDER_ID,signInMethod:Gs.GOOGLE_SIGN_IN_METHOD,idToken:e,accessToken:t})}static credentialFromResult(e){return Gs.credentialFromTaggedObject(e)}static credentialFromError(e){return Gs.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject(e){let{_tokenResponse:t}=e;if(!t)return null;const{oauthIdToken:n,oauthAccessToken:r}=t;if(!n&&!r)return null;try{return Gs.credential(n,r)}catch(s){return null}}}Gs.GOOGLE_SIGN_IN_METHOD="google.com",Gs.PROVIDER_ID="google.com";class Hs extends Ws{constructor(){super("github.com")}static credential(e){return Ls._fromParams({providerId:Hs.PROVIDER_ID,signInMethod:Hs.GITHUB_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return Hs.credentialFromTaggedObject(e)}static credentialFromError(e){return Hs.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject(e){let{_tokenResponse:t}=e;if(!t||!("oauthAccessToken"in t))return null;if(!t.oauthAccessToken)return null;try{return Hs.credential(t.oauthAccessToken)}catch(n){return null}}}Hs.GITHUB_SIGN_IN_METHOD="github.com",Hs.PROVIDER_ID="github.com";class qs extends Ws{constructor(){super("twitter.com")}static credential(e,t){return Ls._fromParams({providerId:qs.PROVIDER_ID,signInMethod:qs.TWITTER_SIGN_IN_METHOD,oauthToken:e,oauthTokenSecret:t})}static credentialFromResult(e){return qs.credentialFromTaggedObject(e)}static credentialFromError(e){return qs.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject(e){let{_tokenResponse:t}=e;if(!t)return null;const{oauthAccessToken:n,oauthTokenSecret:r}=t;if(!n||!r)return null;try{return qs.credential(n,r)}catch(s){return null}}}async function Ks(e,t){return Cr(e,"POST","/v1/accounts:signUp",Tr(e,t))}qs.TWITTER_SIGN_IN_METHOD="twitter.com",qs.PROVIDER_ID="twitter.com";class Xs{constructor(e){this.user=e.user,this.providerId=e.providerId,this._tokenResponse=e._tokenResponse,this.operationType=e.operationType}static async _fromIdTokenResponse(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=await Kr._fromIdTokenResponse(e,n,r),a=Ys(n);return new Xs({user:s,providerId:a,_tokenResponse:n,operationType:t})}static async _forOperation(e,t,n){await e._updateTokensIfNecessary(n,!0);const r=Ys(n);return new Xs({user:e,providerId:r,_tokenResponse:n,operationType:t})}}function Ys(e){return e.providerId?e.providerId:"phoneNumber"in e?"phone":null}class Qs extends gt{constructor(e,t,n,r){var s;super(t.code,t.message),this.operationType=n,this.user=r,Object.setPrototypeOf(this,Qs.prototype),this.customData={appName:e.name,tenantId:null!==(s=e.tenantId)&&void 0!==s?s:void 0,_serverResponse:t.customData._serverResponse,operationType:n}}static _fromErrorAndOperation(e,t,n,r){return new Qs(e,t,n,r)}}function Js(e,t,n,r){return("reauthenticate"===t?n._getReauthenticationResolver(e):n._getIdTokenResponse(e)).catch((n=>{if("auth/multi-factor-auth-required"===n.code)throw Qs._fromErrorAndOperation(e,n,t,r);throw n}))}async function Zs(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=await Ur(e,t._linkToIdToken(e.auth,await e.getIdToken()),n);return Xs._forOperation(e,"link",r)}async function ea(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const{auth:r}=e;if(zn(r.app))return Promise.reject(hr(r));const s="reauthenticate";try{const a=await Ur(e,Js(r,s,t,e),n);pr(a.idToken,r,"internal-error");const i=zr(a.idToken);pr(i,r,"internal-error");const{sub:o}=i;return pr(e.uid===o,r,"user-mismatch"),Xs._forOperation(e,s,a)}catch(t5){throw"auth/user-not-found"===(null===t5||void 0===t5?void 0:t5.code)&&lr(r,"user-mismatch"),t5}}async function ta(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(zn(e.app))return Promise.reject(hr(e));const r="signIn",s=await Js(e,r,t),a=await Xs._fromIdTokenResponse(e,r,s);return n||await e._updateCurrentUser(a.user),a}async function na(e,t){return ta(gs(e),t)}async function ra(e){const t=gs(e);t._getPasswordPolicyInternal()&&await t._updatePasswordPolicy()}function sa(e,t){return Nr(e,"POST","/v2/accounts/mfaEnrollment:start",Tr(e,t))}new WeakMap;const aa="__sak";class ia{constructor(e,t){this.storageRetriever=e,this.type=t}_isAvailable(){try{return this.storage?(this.storage.setItem(aa,"1"),this.storage.removeItem(aa),Promise.resolve(!0)):Promise.resolve(!1)}catch(e){return Promise.resolve(!1)}}_set(e,t){return this.storage.setItem(e,JSON.stringify(t)),Promise.resolve()}_get(e){const t=this.storage.getItem(e);return Promise.resolve(t?JSON.parse(t):null)}_remove(e){return this.storage.removeItem(e),Promise.resolve()}get storage(){return this.storageRetriever()}}class oa extends ia{constructor(){super((()=>window.localStorage),"LOCAL"),this.boundEventHandler=(e,t)=>this.onStorageEvent(e,t),this.listeners={},this.localCache={},this.pollTimer=null,this.fallbackToPolling=hs(),this._shouldAllowMigration=!0}forAllChangedKeys(e){for(const t of Object.keys(this.listeners)){const n=this.storage.getItem(t),r=this.localCache[t];n!==r&&e(t,r,n)}}onStorageEvent(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!e.key)return void this.forAllChangedKeys(((e,t,n)=>{this.notifyListeners(e,n)}));const n=e.key;t?this.detachListener():this.stopPolling();const r=()=>{const e=this.storage.getItem(n);(t||this.localCache[n]!==e)&&this.notifyListeners(n,e)},s=this.storage.getItem(n);cs()&&s!==e.newValue&&e.newValue!==e.oldValue?setTimeout(r,10):r()}notifyListeners(e,t){this.localCache[e]=t;const n=this.listeners[e];if(n)for(const r of Array.from(n))r(t?JSON.parse(t):t)}startPolling(){this.stopPolling(),this.pollTimer=setInterval((()=>{this.forAllChangedKeys(((e,t,n)=>{this.onStorageEvent(new StorageEvent("storage",{key:e,oldValue:t,newValue:n}),!0)}))}),1e3)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}attachListener(){window.addEventListener("storage",this.boundEventHandler)}detachListener(){window.removeEventListener("storage",this.boundEventHandler)}_addListener(e,t){0===Object.keys(this.listeners).length&&(this.fallbackToPolling?this.startPolling():this.attachListener()),this.listeners[e]||(this.listeners[e]=new Set,this.localCache[e]=this.storage.getItem(e)),this.listeners[e].add(t)}_removeListener(e,t){this.listeners[e]&&(this.listeners[e].delete(t),0===this.listeners[e].size&&delete this.listeners[e]),0===Object.keys(this.listeners).length&&(this.detachListener(),this.stopPolling())}async _set(e,t){await super._set(e,t),this.localCache[e]=JSON.stringify(t)}async _get(e){const t=await super._get(e);return this.localCache[e]=JSON.stringify(t),t}async _remove(e){await super._remove(e),delete this.localCache[e]}}oa.type="LOCAL";const la=oa;class ua extends ia{constructor(){super((()=>window.sessionStorage),"SESSION")}_addListener(e,t){}_removeListener(e,t){}}ua.type="SESSION";const ca=ua;class ha{constructor(e){this.eventTarget=e,this.handlersMap={},this.boundEventHandler=this.handleEvent.bind(this)}static _getInstance(e){const t=this.receivers.find((t=>t.isListeningto(e)));if(t)return t;const n=new ha(e);return this.receivers.push(n),n}isListeningto(e){return this.eventTarget===e}async handleEvent(e){const t=e,{eventId:n,eventType:r,data:s}=t.data,a=this.handlersMap[r];if(!(null===a||void 0===a?void 0:a.size))return;t.ports[0].postMessage({status:"ack",eventId:n,eventType:r});const i=Array.from(a).map((async e=>e(t.origin,s))),o=await function(e){return Promise.all(e.map((async e=>{try{return{fulfilled:!0,value:await e}}catch(t){return{fulfilled:!1,reason:t}}})))}(i);t.ports[0].postMessage({status:"done",eventId:n,eventType:r,response:o})}_subscribe(e,t){0===Object.keys(this.handlersMap).length&&this.eventTarget.addEventListener("message",this.boundEventHandler),this.handlersMap[e]||(this.handlersMap[e]=new Set),this.handlersMap[e].add(t)}_unsubscribe(e,t){this.handlersMap[e]&&t&&this.handlersMap[e].delete(t),t&&0!==this.handlersMap[e].size||delete this.handlersMap[e],0===Object.keys(this.handlersMap).length&&this.eventTarget.removeEventListener("message",this.boundEventHandler)}}function da(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,n="";for(let r=0;r<t;r++)n+=Math.floor(10*Math.random());return e+n}ha.receivers=[];class pa{constructor(e){this.target=e,this.handlers=new Set}removeMessageHandler(e){e.messageChannel&&(e.messageChannel.port1.removeEventListener("message",e.onMessage),e.messageChannel.port1.close()),this.handlers.delete(e)}async _send(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:50;const r="undefined"!==typeof MessageChannel?new MessageChannel:null;if(!r)throw new Error("connection_unavailable");let s,a;return new Promise(((i,o)=>{const l=da("",20);r.port1.start();const u=setTimeout((()=>{o(new Error("unsupported_event"))}),n);a={messageChannel:r,onMessage(e){const t=e;if(t.data.eventId===l)switch(t.data.status){case"ack":clearTimeout(u),s=setTimeout((()=>{o(new Error("timeout"))}),3e3);break;case"done":clearTimeout(s),i(t.data.response);break;default:clearTimeout(u),clearTimeout(s),o(new Error("invalid_response"))}}},this.handlers.add(a),r.port1.addEventListener("message",a.onMessage),this.target.postMessage({eventType:e,eventId:l,data:t},[r.port2])})).finally((()=>{a&&this.removeMessageHandler(a)}))}}function fa(){return window}function ma(){return"undefined"!==typeof fa().WorkerGlobalScope&&"function"===typeof fa().importScripts}const ga="firebaseLocalStorageDb",ya="firebaseLocalStorage",ba="fbase_key";class va{constructor(e){this.request=e}toPromise(){return new Promise(((e,t)=>{this.request.addEventListener("success",(()=>{e(this.request.result)})),this.request.addEventListener("error",(()=>{t(this.request.error)}))}))}}function wa(e,t){return e.transaction([ya],t?"readwrite":"readonly").objectStore(ya)}function xa(){const e=indexedDB.open(ga,1);return new Promise(((t,n)=>{e.addEventListener("error",(()=>{n(e.error)})),e.addEventListener("upgradeneeded",(()=>{const t=e.result;try{t.createObjectStore(ya,{keyPath:ba})}catch(t5){n(t5)}})),e.addEventListener("success",(async()=>{const n=e.result;n.objectStoreNames.contains(ya)?t(n):(n.close(),await function(){const e=indexedDB.deleteDatabase(ga);return new va(e).toPromise()}(),t(await xa()))}))}))}async function ka(e,t,n){const r=wa(e,!0).put({[ba]:t,value:n});return new va(r).toPromise()}function Sa(e,t){const n=wa(e,!0).delete(t);return new va(n).toPromise()}class Ia{constructor(){this.type="LOCAL",this._shouldAllowMigration=!0,this.listeners={},this.localCache={},this.pollTimer=null,this.pendingWrites=0,this.receiver=null,this.sender=null,this.serviceWorkerReceiverAvailable=!1,this.activeServiceWorker=null,this._workerInitializationPromise=this.initializeServiceWorkerMessaging().then((()=>{}),(()=>{}))}async _openDb(){return this.db||(this.db=await xa()),this.db}async _withRetries(e){let t=0;for(;;)try{const t=await this._openDb();return await e(t)}catch(t5){if(t++>3)throw t5;this.db&&(this.db.close(),this.db=void 0)}}async initializeServiceWorkerMessaging(){return ma()?this.initializeReceiver():this.initializeSender()}async initializeReceiver(){this.receiver=ha._getInstance(ma()?self:null),this.receiver._subscribe("keyChanged",(async(e,t)=>({keyProcessed:(await this._poll()).includes(t.key)}))),this.receiver._subscribe("ping",(async(e,t)=>["keyChanged"]))}async initializeSender(){var e,t;if(this.activeServiceWorker=await async function(){if(!(null===navigator||void 0===navigator?void 0:navigator.serviceWorker))return null;try{return(await navigator.serviceWorker.ready).active}catch(e){return null}}(),!this.activeServiceWorker)return;this.sender=new pa(this.activeServiceWorker);const n=await this.sender._send("ping",{},800);n&&(null===(e=n[0])||void 0===e?void 0:e.fulfilled)&&(null===(t=n[0])||void 0===t?void 0:t.value.includes("keyChanged"))&&(this.serviceWorkerReceiverAvailable=!0)}async notifyServiceWorker(e){if(this.sender&&this.activeServiceWorker&&function(){var e;return(null===(e=null===navigator||void 0===navigator?void 0:navigator.serviceWorker)||void 0===e?void 0:e.controller)||null}()===this.activeServiceWorker)try{await this.sender._send("keyChanged",{key:e},this.serviceWorkerReceiverAvailable?800:50)}catch(t){}}async _isAvailable(){try{if(!indexedDB)return!1;const e=await xa();return await ka(e,aa,"1"),await Sa(e,aa),!0}catch(e){}return!1}async _withPendingWrite(e){this.pendingWrites++;try{await e()}finally{this.pendingWrites--}}async _set(e,t){return this._withPendingWrite((async()=>(await this._withRetries((n=>ka(n,e,t))),this.localCache[e]=t,this.notifyServiceWorker(e))))}async _get(e){const t=await this._withRetries((t=>async function(e,t){const n=wa(e,!1).get(t),r=await new va(n).toPromise();return void 0===r?null:r.value}(t,e)));return this.localCache[e]=t,t}async _remove(e){return this._withPendingWrite((async()=>(await this._withRetries((t=>Sa(t,e))),delete this.localCache[e],this.notifyServiceWorker(e))))}async _poll(){const e=await this._withRetries((e=>{const t=wa(e,!1).getAll();return new va(t).toPromise()}));if(!e)return[];if(0!==this.pendingWrites)return[];const t=[],n=new Set;if(0!==e.length)for(const{fbase_key:r,value:s}of e)n.add(r),JSON.stringify(this.localCache[r])!==JSON.stringify(s)&&(this.notifyListeners(r,s),t.push(r));for(const r of Object.keys(this.localCache))this.localCache[r]&&!n.has(r)&&(this.notifyListeners(r,null),t.push(r));return t}notifyListeners(e,t){this.localCache[e]=t;const n=this.listeners[e];if(n)for(const r of Array.from(n))r(t)}startPolling(){this.stopPolling(),this.pollTimer=setInterval((async()=>this._poll()),800)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}_addListener(e,t){0===Object.keys(this.listeners).length&&this.startPolling(),this.listeners[e]||(this.listeners[e]=new Set,this._get(e)),this.listeners[e].add(t)}_removeListener(e,t){this.listeners[e]&&(this.listeners[e].delete(t),0===this.listeners[e].size&&delete this.listeners[e]),0===Object.keys(this.listeners).length&&this.stopPolling()}}Ia.type="LOCAL";const Ta=Ia;function Na(e,t){return Nr(e,"POST","/v2/accounts/mfaSignIn:start",Tr(e,t))}ws("rcb"),new wr(3e4,6e4);const Ea="recaptcha";async function Ca(e,t,n){var r;if(!e._getRecaptchaConfig())try{await Es(e)}catch(s){console.log("Failed to initialize reCAPTCHA Enterprise config. Triggering the reCAPTCHA v2 verification.")}try{let s;if(s="string"===typeof t?{phoneNumber:t}:t,"session"in s){const t=s.session;if("phoneNumber"in s){pr("enroll"===t.type,e,"internal-error");const r={idToken:t.credential,phoneEnrollmentInfo:{phoneNumber:s.phoneNumber,clientType:"CLIENT_TYPE_WEB"}},a=Ns(e,r,"mfaSmsEnrollment",(async(e,t)=>{if(t.phoneEnrollmentInfo.captchaResponse===Ss){pr((null===n||void 0===n?void 0:n.type)===Ea,e,"argument-error");return sa(e,await _a(e,t,n))}return sa(e,t)}),"PHONE_PROVIDER");return(await a.catch((e=>Promise.reject(e)))).phoneSessionInfo.sessionInfo}{pr("signin"===t.type,e,"internal-error");const a=(null===(r=s.multiFactorHint)||void 0===r?void 0:r.uid)||s.multiFactorUid;pr(a,e,"missing-multi-factor-info");const i={mfaPendingCredential:t.credential,mfaEnrollmentId:a,phoneSignInInfo:{clientType:"CLIENT_TYPE_WEB"}},o=Ns(e,i,"mfaSmsSignIn",(async(e,t)=>{if(t.phoneSignInInfo.captchaResponse===Ss){pr((null===n||void 0===n?void 0:n.type)===Ea,e,"argument-error");return Na(e,await _a(e,t,n))}return Na(e,t)}),"PHONE_PROVIDER");return(await o.catch((e=>Promise.reject(e)))).phoneResponseInfo.sessionInfo}}{const t={phoneNumber:s.phoneNumber,clientType:"CLIENT_TYPE_WEB"},r=Ns(e,t,"sendVerificationCode",(async(e,t)=>{if(t.captchaResponse===Ss){pr((null===n||void 0===n?void 0:n.type)===Ea,e,"argument-error");return Ms(e,await _a(e,t,n))}return Ms(e,t)}),"PHONE_PROVIDER");return(await r.catch((e=>Promise.reject(e)))).sessionInfo}}finally{null===n||void 0===n||n._reset()}}async function _a(e,t,n){pr(n.type===Ea,e,"argument-error");const r=await n.verify();pr("string"===typeof r,e,"argument-error");const s=Object.assign({},t);if("phoneEnrollmentInfo"in s){const e=s.phoneEnrollmentInfo.phoneNumber,t=s.phoneEnrollmentInfo.captchaResponse,n=s.phoneEnrollmentInfo.clientType,a=s.phoneEnrollmentInfo.recaptchaVersion;return Object.assign(s,{phoneEnrollmentInfo:{phoneNumber:e,recaptchaToken:r,captchaResponse:t,clientType:n,recaptchaVersion:a}}),s}if("phoneSignInInfo"in s){const e=s.phoneSignInInfo.captchaResponse,t=s.phoneSignInInfo.clientType,n=s.phoneSignInInfo.recaptchaVersion;return Object.assign(s,{phoneSignInInfo:{recaptchaToken:r,captchaResponse:e,clientType:t,recaptchaVersion:n}}),s}return Object.assign(s,{recaptchaToken:r}),s}class Aa{constructor(e){this.providerId=Aa.PROVIDER_ID,this.auth=gs(e)}verifyPhoneNumber(e,t){return Ca(this.auth,e,Nt(t))}static credential(e,t){return zs._fromVerification(e,t)}static credentialFromResult(e){const t=e;return Aa.credentialFromTaggedObject(t)}static credentialFromError(e){return Aa.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject(e){let{_tokenResponse:t}=e;if(!t)return null;const{phoneNumber:n,temporaryProof:r}=t;return n&&r?zs._fromTokenResponse(n,r):null}}function Ra(e,t){return t?Yr(t):(pr(e._popupRedirectResolver,e,"argument-error"),e._popupRedirectResolver)}Aa.PROVIDER_ID="phone",Aa.PHONE_SIGN_IN_METHOD="phone";class $a extends Rs{constructor(e){super("custom","custom"),this.params=e}_getIdTokenResponse(e){return Fs(e,this._buildIdpRequest())}_linkToIdToken(e,t){return Fs(e,this._buildIdpRequest(t))}_getReauthenticationResolver(e){return Fs(e,this._buildIdpRequest())}_buildIdpRequest(e){const t={requestUri:this.params.requestUri,sessionId:this.params.sessionId,postBody:this.params.postBody,tenantId:this.params.tenantId,pendingToken:this.params.pendingToken,returnSecureToken:!0,returnIdpCredential:!0};return e&&(t.idToken=e),t}}function Oa(e){return ta(e.auth,new $a(e),e.bypassAuthState)}function Da(e){const{auth:t,user:n}=e;return pr(n,t,"internal-error"),ea(n,new $a(e),e.bypassAuthState)}async function Fa(e){const{auth:t,user:n}=e;return pr(n,t,"internal-error"),Zs(n,new $a(e),e.bypassAuthState)}class La{constructor(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.auth=e,this.resolver=n,this.user=r,this.bypassAuthState=s,this.pendingPromise=null,this.eventManager=null,this.filter=Array.isArray(t)?t:[t]}execute(){return new Promise((async(e,t)=>{this.pendingPromise={resolve:e,reject:t};try{this.eventManager=await this.resolver._initialize(this.auth),await this.onExecution(),this.eventManager.registerConsumer(this)}catch(t5){this.reject(t5)}}))}async onAuthEvent(e){const{urlResponse:t,sessionId:n,postBody:r,tenantId:s,error:a,type:i}=e;if(a)return void this.reject(a);const o={auth:this.auth,requestUri:t,sessionId:n,tenantId:s||void 0,postBody:r||void 0,user:this.user,bypassAuthState:this.bypassAuthState};try{this.resolve(await this.getIdpTask(i)(o))}catch(t5){this.reject(t5)}}onError(e){this.reject(e)}getIdpTask(e){switch(e){case"signInViaPopup":case"signInViaRedirect":return Oa;case"linkViaPopup":case"linkViaRedirect":return Fa;case"reauthViaPopup":case"reauthViaRedirect":return Da;default:lr(this.auth,"internal-error")}}resolve(e){mr(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.resolve(e),this.unregisterAndCleanUp()}reject(e){mr(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.reject(e),this.unregisterAndCleanUp()}unregisterAndCleanUp(){this.eventManager&&this.eventManager.unregisterConsumer(this),this.pendingPromise=null,this.cleanUp()}}const Ma=new wr(2e3,1e4);class Pa extends La{constructor(e,t,n,r,s){super(e,t,r,s),this.provider=n,this.authWindow=null,this.pollId=null,Pa.currentPopupAction&&Pa.currentPopupAction.cancel(),Pa.currentPopupAction=this}async executeNotNull(){const e=await this.execute();return pr(e,this.auth,"internal-error"),e}async onExecution(){mr(1===this.filter.length,"Popup operations only handle one event");const e=da();this.authWindow=await this.resolver._openPopup(this.auth,this.provider,this.filter[0],e),this.authWindow.associatedEvent=e,this.resolver._originValidation(this.auth).catch((e=>{this.reject(e)})),this.resolver._isIframeWebStorageSupported(this.auth,(e=>{e||this.reject(ur(this.auth,"web-storage-unsupported"))})),this.pollUserCancellation()}get eventId(){var e;return(null===(e=this.authWindow)||void 0===e?void 0:e.associatedEvent)||null}cancel(){this.reject(ur(this.auth,"cancelled-popup-request"))}cleanUp(){this.authWindow&&this.authWindow.close(),this.pollId&&window.clearTimeout(this.pollId),this.authWindow=null,this.pollId=null,Pa.currentPopupAction=null}pollUserCancellation(){const e=()=>{var t,n;(null===(n=null===(t=this.authWindow)||void 0===t?void 0:t.window)||void 0===n?void 0:n.closed)?this.pollId=window.setTimeout((()=>{this.pollId=null,this.reject(ur(this.auth,"popup-closed-by-user"))}),8e3):this.pollId=window.setTimeout(e,Ma.get())};e()}}Pa.currentPopupAction=null;const za=new Map;class Ba extends La{constructor(e,t){super(e,["signInViaRedirect","linkViaRedirect","reauthViaRedirect","unknown"],t,void 0,arguments.length>2&&void 0!==arguments[2]&&arguments[2]),this.eventId=null}async execute(){let e=za.get(this.auth._key());if(!e){try{const t=await async function(e,t){const n=Wa(t),r=Va(e);if(!await r._isAvailable())return!1;const s="true"===await r._get(n);return await r._remove(n),s}(this.resolver,this.auth),n=t?await super.execute():null;e=()=>Promise.resolve(n)}catch(t5){e=()=>Promise.reject(t5)}za.set(this.auth._key(),e)}return this.bypassAuthState||za.set(this.auth._key(),(()=>Promise.resolve(null))),e()}async onAuthEvent(e){if("signInViaRedirect"===e.type)return super.onAuthEvent(e);if("unknown"!==e.type){if(e.eventId){const t=await this.auth._redirectUserForId(e.eventId);if(t)return this.user=t,super.onAuthEvent(e);this.resolve(null)}}else this.resolve(null)}async onExecution(){}cleanUp(){}}function Ua(e,t){za.set(e._key(),t)}function Va(e){return Yr(e._redirectPersistence)}function Wa(e){return Zr("pendingRedirect",e.config.apiKey,e.name)}async function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(zn(e.app))return Promise.reject(hr(e));const r=gs(e),s=Ra(r,t),a=new Ba(r,s,n),i=await a.execute();return i&&!n&&(delete i.user._redirectEventId,await r._persistUserIfCurrent(i.user),await r._setRedirectUser(null,t)),i}class Ga{constructor(e){this.auth=e,this.cachedEventUids=new Set,this.consumers=new Set,this.queuedRedirectEvent=null,this.hasHandledPotentialRedirect=!1,this.lastProcessedEventTime=Date.now()}registerConsumer(e){this.consumers.add(e),this.queuedRedirectEvent&&this.isEventForConsumer(this.queuedRedirectEvent,e)&&(this.sendToConsumer(this.queuedRedirectEvent,e),this.saveEventToCache(this.queuedRedirectEvent),this.queuedRedirectEvent=null)}unregisterConsumer(e){this.consumers.delete(e)}onEvent(e){if(this.hasEventBeenHandled(e))return!1;let t=!1;return this.consumers.forEach((n=>{this.isEventForConsumer(e,n)&&(t=!0,this.sendToConsumer(e,n),this.saveEventToCache(e))})),this.hasHandledPotentialRedirect||!function(e){switch(e.type){case"signInViaRedirect":case"linkViaRedirect":case"reauthViaRedirect":return!0;case"unknown":return qa(e);default:return!1}}(e)||(this.hasHandledPotentialRedirect=!0,t||(this.queuedRedirectEvent=e,t=!0)),t}sendToConsumer(e,t){var n;if(e.error&&!qa(e)){const r=(null===(n=e.error.code)||void 0===n?void 0:n.split("auth/")[1])||"internal-error";t.onError(ur(this.auth,r))}else t.onAuthEvent(e)}isEventForConsumer(e,t){const n=null===t.eventId||!!e.eventId&&e.eventId===t.eventId;return t.filter.includes(e.type)&&n}hasEventBeenHandled(e){return Date.now()-this.lastProcessedEventTime>=6e5&&this.cachedEventUids.clear(),this.cachedEventUids.has(Ha(e))}saveEventToCache(e){this.cachedEventUids.add(Ha(e)),this.lastProcessedEventTime=Date.now()}}function Ha(e){return[e.type,e.eventId,e.sessionId,e.tenantId].filter((e=>e)).join("-")}function qa(e){let{type:t,error:n}=e;return"unknown"===t&&"auth/no-auth-event"===(null===n||void 0===n?void 0:n.code)}const Ka=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,Xa=/^https?/;async function Ya(e){if(e.config.emulator)return;const{authorizedDomains:t}=await async function(e){return Nr(e,"GET","/v1/projects",arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}(e);for(const r of t)try{if(Qa(r))return}catch(n){}lr(e,"unauthorized-domain")}function Qa(e){const t=gr(),{protocol:n,hostname:r}=new URL(t);if(e.startsWith("chrome-extension://")){const s=new URL(e);return""===s.hostname&&""===r?"chrome-extension:"===n&&e.replace("chrome-extension://","")===t.replace("chrome-extension://",""):"chrome-extension:"===n&&s.hostname===r}if(!Xa.test(n))return!1;if(Ka.test(e))return r===e;const s=e.replace(/\./g,"\\.");return new RegExp("^(.+\\."+s+"|"+s+")$","i").test(r)}const Ja=new wr(3e4,6e4);function Za(){const e=fa().___jsl;if(null===e||void 0===e?void 0:e.H)for(const t of Object.keys(e.H))if(e.H[t].r=e.H[t].r||[],e.H[t].L=e.H[t].L||[],e.H[t].r=[...e.H[t].L],e.CP)for(let n=0;n<e.CP.length;n++)e.CP[n]=null}function ei(e){return new Promise(((t,n)=>{var r,s,a;function i(){Za(),gapi.load("gapi.iframes",{callback:()=>{t(gapi.iframes.getContext())},ontimeout:()=>{Za(),n(ur(e,"network-request-failed"))},timeout:Ja.get()})}if(null===(s=null===(r=fa().gapi)||void 0===r?void 0:r.iframes)||void 0===s?void 0:s.Iframe)t(gapi.iframes.getContext());else{if(!(null===(a=fa().gapi)||void 0===a?void 0:a.load)){const t=ws("iframefcb");return fa()[t]=()=>{gapi.load?i():n(ur(e,"network-request-failed"))},vs(`${bs.gapiScript}?onload=${t}`).catch((e=>n(e)))}i()}})).catch((e=>{throw ti=null,e}))}let ti=null;const ni=new wr(5e3,15e3),ri={style:{position:"absolute",top:"-100px",width:"1px",height:"1px"},"aria-hidden":"true",tabindex:"-1"},si=new Map([["identitytoolkit.googleapis.com","p"],["staging-identitytoolkit.sandbox.googleapis.com","s"],["test-identitytoolkit.sandbox.googleapis.com","t"]]);function ai(e){const t=e.config;pr(t.authDomain,e,"auth-domain-config-required");const n=t.emulator?xr(t,"emulator/auth/iframe"):`https://${e.config.authDomain}/__/auth/iframe`,r={apiKey:t.apiKey,appName:e.name,v:Vn},s=si.get(e.config.apiHost);s&&(r.eid=s);const a=e._getFrameworks();return a.length&&(r.fw=a.join(",")),`${n}?${xt(r).slice(1)}`}async function ii(e){const t=await function(e){return ti=ti||ei(e),ti}(e),n=fa().gapi;return pr(n,e,"internal-error"),t.open({where:document.body,url:ai(e),messageHandlersFilter:n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:ri,dontclear:!0},(t=>new Promise((async(n,r)=>{await t.restyle({setHideOnLeave:!1});const s=ur(e,"network-request-failed"),a=fa().setTimeout((()=>{r(s)}),ni.get());function i(){fa().clearTimeout(a),n(t)}t.ping(i).then(i,(()=>{r(s)}))}))))}const oi={location:"yes",resizable:"yes",statusbar:"yes",toolbar:"no"};class li{constructor(e){this.window=e,this.associatedEvent=null}close(){if(this.window)try{this.window.close()}catch(t5){}}}function ui(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:500,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:600;const a=Math.max((window.screen.availHeight-s)/2,0).toString(),i=Math.max((window.screen.availWidth-r)/2,0).toString();let o="";const l=Object.assign(Object.assign({},oi),{width:r.toString(),height:s.toString(),top:a,left:i}),u=pt().toLowerCase();n&&(o=ss(u)?"_blank":n),ns(u)&&(t=t||"http://localhost",l.scrollbars="yes");const c=Object.entries(l).reduce(((e,t)=>{let[n,r]=t;return`${e}${n}=${r},`}),"");if(function(){var e;return us(arguments.length>0&&void 0!==arguments[0]?arguments[0]:pt())&&!!(null===(e=window.navigator)||void 0===e?void 0:e.standalone)}(u)&&"_self"!==o)return function(e,t){const n=document.createElement("a");n.href=e,n.target=t;const r=document.createEvent("MouseEvent");r.initMouseEvent("click",!0,!0,window,1,0,0,0,0,!1,!1,!1,!1,1,null),n.dispatchEvent(r)}(t||"",o),new li(null);const h=window.open(t||"",o,c);pr(h,e,"popup-blocked");try{h.focus()}catch(t5){}return new li(h)}const ci="__/auth/handler",hi="emulator/auth/handler",di=encodeURIComponent("fac");async function pi(e,t,n,r,s,a){pr(e.config.authDomain,e,"auth-domain-config-required"),pr(e.config.apiKey,e,"invalid-api-key");const i={apiKey:e.config.apiKey,appName:e.name,authType:n,redirectUrl:r,v:Vn,eventId:s};if(t instanceof Vs){t.setDefaultLanguage(e.languageCode),i.providerId=t.providerId||"",function(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}(t.getCustomParameters())||(i.customParameters=JSON.stringify(t.getCustomParameters()));for(const[e,t]of Object.entries(a||{}))i[e]=t}if(t instanceof Ws){const e=t.getScopes().filter((e=>""!==e));e.length>0&&(i.scopes=e.join(","))}e.tenantId&&(i.tid=e.tenantId);const o=i;for(const c of Object.keys(o))void 0===o[c]&&delete o[c];const l=await e._getAppCheckToken(),u=l?`#${di}=${encodeURIComponent(l)}`:"";return`${function(e){let{config:t}=e;if(!t.emulator)return`https://${t.authDomain}/${ci}`;return xr(t,hi)}(e)}?${xt(o).slice(1)}${u}`}const fi="webStorageSupport";const mi=class{constructor(){this.eventManagers={},this.iframes={},this.originValidationPromises={},this._redirectPersistence=ca,this._completeRedirectFn=ja,this._overrideRedirectResult=Ua}async _openPopup(e,t,n,r){var s;mr(null===(s=this.eventManagers[e._key()])||void 0===s?void 0:s.manager,"_initialize() not called before _openPopup()");return ui(e,await pi(e,t,n,gr(),r),da())}async _openRedirect(e,t,n,r){await this._originValidation(e);return function(e){fa().location.href=e}(await pi(e,t,n,gr(),r)),new Promise((()=>{}))}_initialize(e){const t=e._key();if(this.eventManagers[t]){const{manager:e,promise:n}=this.eventManagers[t];return e?Promise.resolve(e):(mr(n,"If manager is not set, promise should be"),n)}const n=this.initAndGetManager(e);return this.eventManagers[t]={promise:n},n.catch((()=>{delete this.eventManagers[t]})),n}async initAndGetManager(e){const t=await ii(e),n=new Ga(e);return t.register("authEvent",(t=>{pr(null===t||void 0===t?void 0:t.authEvent,e,"invalid-auth-event");return{status:n.onEvent(t.authEvent)?"ACK":"ERROR"}}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),this.eventManagers[e._key()]={manager:n},this.iframes[e._key()]=t,n}_isIframeWebStorageSupported(e,t){this.iframes[e._key()].send(fi,{type:fi},(n=>{var r;const s=null===(r=null===n||void 0===n?void 0:n[0])||void 0===r?void 0:r[fi];void 0!==s&&t(!!s),lr(e,"internal-error")}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(e){const t=e._key();return this.originValidationPromises[t]||(this.originValidationPromises[t]=Ya(e)),this.originValidationPromises[t]}get _shouldInitProactively(){return hs()||rs()||us()}};var gi="@firebase/auth",yi="1.8.0";class bi{constructor(e){this.auth=e,this.internalListeners=new Map}getUid(){var e;return this.assertAuthConfigured(),(null===(e=this.auth.currentUser)||void 0===e?void 0:e.uid)||null}async getToken(e){if(this.assertAuthConfigured(),await this.auth._initializationPromise,!this.auth.currentUser)return null;return{accessToken:await this.auth.currentUser.getIdToken(e)}}addAuthTokenListener(e){if(this.assertAuthConfigured(),this.internalListeners.has(e))return;const t=this.auth.onIdTokenChanged((t=>{e((null===t||void 0===t?void 0:t.stsTokenManager.accessToken)||null)}));this.internalListeners.set(e,t),this.updateProactiveRefresh()}removeAuthTokenListener(e){this.assertAuthConfigured();const t=this.internalListeners.get(e);t&&(this.internalListeners.delete(e),t(),this.updateProactiveRefresh())}assertAuthConfigured(){pr(this.auth._initializationPromise,"dependent-sdk-initialized-before-auth")}updateProactiveRefresh(){this.internalListeners.size>0?this.auth._startProactiveRefresh():this.auth._stopProactiveRefresh()}}const vi=ht("authIdTokenMaxAge")||300;let wi=null;var xi;!function(e){bs=e}({loadJS:e=>new Promise(((t,n)=>{const r=document.createElement("script");r.setAttribute("src",e),r.onload=t,r.onerror=e=>{const t=ur("internal-error");t.customData=e,n(t)},r.type="text/javascript",r.charset="UTF-8",function(){var e,t;return null!==(t=null===(e=document.getElementsByTagName("head"))||void 0===e?void 0:e[0])&&void 0!==t?t:document}().appendChild(r)})),gapiScript:"https://apis.google.com/js/api.js",recaptchaV2Script:"https://www.google.com/recaptcha/api.js",recaptchaEnterpriseScript:"https://www.google.com/recaptcha/enterprise.js?render="}),xi="Browser",Mn(new Et("auth",((e,t)=>{let{options:n}=t;const r=e.getProvider("app").getImmediate(),s=e.getProvider("heartbeat"),a=e.getProvider("app-check-internal"),{apiKey:i,authDomain:o}=r.options;pr(i&&!i.includes(":"),"invalid-api-key",{appName:r.name});const l={apiKey:i,authDomain:o,clientPlatform:xi,apiHost:"identitytoolkit.googleapis.com",tokenApiHost:"securetoken.googleapis.com",apiScheme:"https",sdkClientVersion:ds(xi)},u=new ms(r,s,a,l);return function(e,t){const n=(null===t||void 0===t?void 0:t.persistence)||[],r=(Array.isArray(n)?n:[n]).map(Yr);(null===t||void 0===t?void 0:t.errorMap)&&e._updateErrorMap(t.errorMap),e._initializeWithPersistence(r,null===t||void 0===t?void 0:t.popupRedirectResolver)}(u,n),u}),"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback(((e,t,n)=>{e.getProvider("auth-internal").initialize()}))),Mn(new Et("auth-internal",(e=>(e=>new bi(e))(gs(e.getProvider("auth").getImmediate()))),"PRIVATE").setInstantiationMode("EXPLICIT")),Gn(gi,yi,function(e){switch(e){case"Node":return"node";case"ReactNative":return"rn";case"Worker":return"webworker";case"Cordova":return"cordova";case"WebExtension":return"web-extension";default:return}}(xi)),Gn(gi,yi,"esm2017");Gn("firebase","11.0.1","app");var ki,Si,Ii="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},Ti={};(function(){var e;function t(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.B=Array(this.blockSize),this.o=this.h=0,this.s()}function n(e,t,n){n||(n=0);var r=Array(16);if("string"===typeof t)for(var s=0;16>s;++s)r[s]=t.charCodeAt(n++)|t.charCodeAt(n++)<<8|t.charCodeAt(n++)<<16|t.charCodeAt(n++)<<24;else for(s=0;16>s;++s)r[s]=t[n++]|t[n++]<<8|t[n++]<<16|t[n++]<<24;t=e.g[0],n=e.g[1],s=e.g[2];var a=e.g[3],i=t+(a^n&(s^a))+r[0]+3614090360&4294967295;i=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=(n=(s=(a=(t=n+(i<<7&4294967295|i>>>25))+((i=a+(s^t&(n^s))+r[1]+3905402710&4294967295)<<12&4294967295|i>>>20))+((i=s+(n^a&(t^n))+r[2]+606105819&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^s&(a^t))+r[3]+3250441966&4294967295)<<22&4294967295|i>>>10))+((i=t+(a^n&(s^a))+r[4]+4118548399&4294967295)<<7&4294967295|i>>>25))+((i=a+(s^t&(n^s))+r[5]+1200080426&4294967295)<<12&4294967295|i>>>20))+((i=s+(n^a&(t^n))+r[6]+2821735955&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^s&(a^t))+r[7]+4249261313&4294967295)<<22&4294967295|i>>>10))+((i=t+(a^n&(s^a))+r[8]+1770035416&4294967295)<<7&4294967295|i>>>25))+((i=a+(s^t&(n^s))+r[9]+2336552879&4294967295)<<12&4294967295|i>>>20))+((i=s+(n^a&(t^n))+r[10]+4294925233&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^s&(a^t))+r[11]+2304563134&4294967295)<<22&4294967295|i>>>10))+((i=t+(a^n&(s^a))+r[12]+1804603682&4294967295)<<7&4294967295|i>>>25))+((i=a+(s^t&(n^s))+r[13]+4254626195&4294967295)<<12&4294967295|i>>>20))+((i=s+(n^a&(t^n))+r[14]+2792965006&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^s&(a^t))+r[15]+1236535329&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^a&(n^s))+r[1]+4129170786&4294967295)<<5&4294967295|i>>>27))+((i=a+(n^s&(t^n))+r[6]+3225465664&4294967295)<<9&4294967295|i>>>23))+((i=s+(t^n&(a^t))+r[11]+643717713&4294967295)<<14&4294967295|i>>>18))+((i=n+(a^t&(s^a))+r[0]+3921069994&4294967295)<<20&4294967295|i>>>12))+((i=t+(s^a&(n^s))+r[5]+3593408605&4294967295)<<5&4294967295|i>>>27))+((i=a+(n^s&(t^n))+r[10]+38016083&4294967295)<<9&4294967295|i>>>23))+((i=s+(t^n&(a^t))+r[15]+3634488961&4294967295)<<14&4294967295|i>>>18))+((i=n+(a^t&(s^a))+r[4]+3889429448&4294967295)<<20&4294967295|i>>>12))+((i=t+(s^a&(n^s))+r[9]+568446438&4294967295)<<5&4294967295|i>>>27))+((i=a+(n^s&(t^n))+r[14]+3275163606&4294967295)<<9&4294967295|i>>>23))+((i=s+(t^n&(a^t))+r[3]+4107603335&4294967295)<<14&4294967295|i>>>18))+((i=n+(a^t&(s^a))+r[8]+1163531501&4294967295)<<20&4294967295|i>>>12))+((i=t+(s^a&(n^s))+r[13]+2850285829&4294967295)<<5&4294967295|i>>>27))+((i=a+(n^s&(t^n))+r[2]+4243563512&4294967295)<<9&4294967295|i>>>23))+((i=s+(t^n&(a^t))+r[7]+1735328473&4294967295)<<14&4294967295|i>>>18))+((i=n+(a^t&(s^a))+r[12]+2368359562&4294967295)<<20&4294967295|i>>>12))+((i=t+(n^s^a)+r[5]+4294588738&4294967295)<<4&4294967295|i>>>28))+((i=a+(t^n^s)+r[8]+2272392833&4294967295)<<11&4294967295|i>>>21))+((i=s+(a^t^n)+r[11]+1839030562&4294967295)<<16&4294967295|i>>>16))+((i=n+(s^a^t)+r[14]+4259657740&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^s^a)+r[1]+2763975236&4294967295)<<4&4294967295|i>>>28))+((i=a+(t^n^s)+r[4]+1272893353&4294967295)<<11&4294967295|i>>>21))+((i=s+(a^t^n)+r[7]+4139469664&4294967295)<<16&4294967295|i>>>16))+((i=n+(s^a^t)+r[10]+3200236656&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^s^a)+r[13]+681279174&4294967295)<<4&4294967295|i>>>28))+((i=a+(t^n^s)+r[0]+3936430074&4294967295)<<11&4294967295|i>>>21))+((i=s+(a^t^n)+r[3]+3572445317&4294967295)<<16&4294967295|i>>>16))+((i=n+(s^a^t)+r[6]+76029189&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^s^a)+r[9]+3654602809&4294967295)<<4&4294967295|i>>>28))+((i=a+(t^n^s)+r[12]+3873151461&4294967295)<<11&4294967295|i>>>21))+((i=s+(a^t^n)+r[15]+530742520&4294967295)<<16&4294967295|i>>>16))+((i=n+(s^a^t)+r[2]+3299628645&4294967295)<<23&4294967295|i>>>9))+((i=t+(s^(n|~a))+r[0]+4096336452&4294967295)<<6&4294967295|i>>>26))+((i=a+(n^(t|~s))+r[7]+1126891415&4294967295)<<10&4294967295|i>>>22))+((i=s+(t^(a|~n))+r[14]+2878612391&4294967295)<<15&4294967295|i>>>17))+((i=n+(a^(s|~t))+r[5]+4237533241&4294967295)<<21&4294967295|i>>>11))+((i=t+(s^(n|~a))+r[12]+1700485571&4294967295)<<6&4294967295|i>>>26))+((i=a+(n^(t|~s))+r[3]+2399980690&4294967295)<<10&4294967295|i>>>22))+((i=s+(t^(a|~n))+r[10]+4293915773&4294967295)<<15&4294967295|i>>>17))+((i=n+(a^(s|~t))+r[1]+2240044497&4294967295)<<21&4294967295|i>>>11))+((i=t+(s^(n|~a))+r[8]+1873313359&4294967295)<<6&4294967295|i>>>26))+((i=a+(n^(t|~s))+r[15]+4264355552&4294967295)<<10&4294967295|i>>>22))+((i=s+(t^(a|~n))+r[6]+2734768916&4294967295)<<15&4294967295|i>>>17))+((i=n+(a^(s|~t))+r[13]+1309151649&4294967295)<<21&4294967295|i>>>11))+((a=(t=n+((i=t+(s^(n|~a))+r[4]+4149444226&4294967295)<<6&4294967295|i>>>26))+((i=a+(n^(t|~s))+r[11]+3174756917&4294967295)<<10&4294967295|i>>>22))^((s=a+((i=s+(t^(a|~n))+r[2]+718787259&4294967295)<<15&4294967295|i>>>17))|~t))+r[9]+3951481745&4294967295,e.g[0]=e.g[0]+t&4294967295,e.g[1]=e.g[1]+(s+(i<<21&4294967295|i>>>11))&4294967295,e.g[2]=e.g[2]+s&4294967295,e.g[3]=e.g[3]+a&4294967295}function r(e,t){this.h=t;for(var n=[],r=!0,s=e.length-1;0<=s;s--){var a=0|e[s];r&&a==t||(n[s]=a,r=!1)}this.g=n}!function(e,t){function n(){}n.prototype=t.prototype,e.D=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.C=function(e,n,r){for(var s=Array(arguments.length-2),a=2;a<arguments.length;a++)s[a-2]=arguments[a];return t.prototype[n].apply(e,s)}}(t,(function(){this.blockSize=-1})),t.prototype.s=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0},t.prototype.u=function(e,t){void 0===t&&(t=e.length);for(var r=t-this.blockSize,s=this.B,a=this.h,i=0;i<t;){if(0==a)for(;i<=r;)n(this,e,i),i+=this.blockSize;if("string"===typeof e){for(;i<t;)if(s[a++]=e.charCodeAt(i++),a==this.blockSize){n(this,s),a=0;break}}else for(;i<t;)if(s[a++]=e[i++],a==this.blockSize){n(this,s),a=0;break}}this.h=a,this.o+=t},t.prototype.v=function(){var e=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);e[0]=128;for(var t=1;t<e.length-8;++t)e[t]=0;var n=8*this.o;for(t=e.length-8;t<e.length;++t)e[t]=255&n,n/=256;for(this.u(e),e=Array(16),t=n=0;4>t;++t)for(var r=0;32>r;r+=8)e[n++]=this.g[t]>>>r&255;return e};var s={};function a(e){return-128<=e&&128>e?function(e,t){var n=s;return Object.prototype.hasOwnProperty.call(n,e)?n[e]:n[e]=t(e)}(e,(function(e){return new r([0|e],0>e?-1:0)})):new r([0|e],0>e?-1:0)}function i(e){if(isNaN(e)||!isFinite(e))return o;if(0>e)return d(i(-e));for(var t=[],n=1,s=0;e>=n;s++)t[s]=e/n|0,n*=4294967296;return new r(t,0)}var o=a(0),l=a(1),u=a(16777216);function c(e){if(0!=e.h)return!1;for(var t=0;t<e.g.length;t++)if(0!=e.g[t])return!1;return!0}function h(e){return-1==e.h}function d(e){for(var t=e.g.length,n=[],s=0;s<t;s++)n[s]=~e.g[s];return new r(n,~e.h).add(l)}function p(e,t){return e.add(d(t))}function f(e,t){for(;(65535&e[t])!=e[t];)e[t+1]+=e[t]>>>16,e[t]&=65535,t++}function m(e,t){this.g=e,this.h=t}function g(e,t){if(c(t))throw Error("division by zero");if(c(e))return new m(o,o);if(h(e))return t=g(d(e),t),new m(d(t.g),d(t.h));if(h(t))return t=g(e,d(t)),new m(d(t.g),t.h);if(30<e.g.length){if(h(e)||h(t))throw Error("slowDivide_ only works with positive integers.");for(var n=l,r=t;0>=r.l(e);)n=y(n),r=y(r);var s=b(n,1),a=b(r,1);for(r=b(r,2),n=b(n,2);!c(r);){var u=a.add(r);0>=u.l(e)&&(s=s.add(n),a=u),r=b(r,1),n=b(n,1)}return t=p(e,s.j(t)),new m(s,t)}for(s=o;0<=e.l(t);){for(n=Math.max(1,Math.floor(e.m()/t.m())),r=48>=(r=Math.ceil(Math.log(n)/Math.LN2))?1:Math.pow(2,r-48),u=(a=i(n)).j(t);h(u)||0<u.l(e);)u=(a=i(n-=r)).j(t);c(a)&&(a=l),s=s.add(a),e=p(e,u)}return new m(s,e)}function y(e){for(var t=e.g.length+1,n=[],s=0;s<t;s++)n[s]=e.i(s)<<1|e.i(s-1)>>>31;return new r(n,e.h)}function b(e,t){var n=t>>5;t%=32;for(var s=e.g.length-n,a=[],i=0;i<s;i++)a[i]=0<t?e.i(i+n)>>>t|e.i(i+n+1)<<32-t:e.i(i+n);return new r(a,e.h)}(e=r.prototype).m=function(){if(h(this))return-d(this).m();for(var e=0,t=1,n=0;n<this.g.length;n++){var r=this.i(n);e+=(0<=r?r:4294967296+r)*t,t*=4294967296}return e},e.toString=function(e){if(2>(e=e||10)||36<e)throw Error("radix out of range: "+e);if(c(this))return"0";if(h(this))return"-"+d(this).toString(e);for(var t=i(Math.pow(e,6)),n=this,r="";;){var s=g(n,t).g,a=((0<(n=p(n,s.j(t))).g.length?n.g[0]:n.h)>>>0).toString(e);if(c(n=s))return a+r;for(;6>a.length;)a="0"+a;r=a+r}},e.i=function(e){return 0>e?0:e<this.g.length?this.g[e]:this.h},e.l=function(e){return h(e=p(this,e))?-1:c(e)?0:1},e.abs=function(){return h(this)?d(this):this},e.add=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],s=0,a=0;a<=t;a++){var i=s+(65535&this.i(a))+(65535&e.i(a)),o=(i>>>16)+(this.i(a)>>>16)+(e.i(a)>>>16);s=o>>>16,i&=65535,o&=65535,n[a]=o<<16|i}return new r(n,-2147483648&n[n.length-1]?-1:0)},e.j=function(e){if(c(this)||c(e))return o;if(h(this))return h(e)?d(this).j(d(e)):d(d(this).j(e));if(h(e))return d(this.j(d(e)));if(0>this.l(u)&&0>e.l(u))return i(this.m()*e.m());for(var t=this.g.length+e.g.length,n=[],s=0;s<2*t;s++)n[s]=0;for(s=0;s<this.g.length;s++)for(var a=0;a<e.g.length;a++){var l=this.i(s)>>>16,p=65535&this.i(s),m=e.i(a)>>>16,g=65535&e.i(a);n[2*s+2*a]+=p*g,f(n,2*s+2*a),n[2*s+2*a+1]+=l*g,f(n,2*s+2*a+1),n[2*s+2*a+1]+=p*m,f(n,2*s+2*a+1),n[2*s+2*a+2]+=l*m,f(n,2*s+2*a+2)}for(s=0;s<t;s++)n[s]=n[2*s+1]<<16|n[2*s];for(s=t;s<2*t;s++)n[s]=0;return new r(n,0)},e.A=function(e){return g(this,e).h},e.and=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],s=0;s<t;s++)n[s]=this.i(s)&e.i(s);return new r(n,this.h&e.h)},e.or=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],s=0;s<t;s++)n[s]=this.i(s)|e.i(s);return new r(n,this.h|e.h)},e.xor=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],s=0;s<t;s++)n[s]=this.i(s)^e.i(s);return new r(n,this.h^e.h)},t.prototype.digest=t.prototype.v,t.prototype.reset=t.prototype.s,t.prototype.update=t.prototype.u,Si=Ti.Md5=t,r.prototype.add=r.prototype.add,r.prototype.multiply=r.prototype.j,r.prototype.modulo=r.prototype.A,r.prototype.compare=r.prototype.l,r.prototype.toNumber=r.prototype.m,r.prototype.toString=r.prototype.toString,r.prototype.getBits=r.prototype.i,r.fromNumber=i,r.fromString=function e(t,n){if(0==t.length)throw Error("number format error: empty string");if(2>(n=n||10)||36<n)throw Error("radix out of range: "+n);if("-"==t.charAt(0))return d(e(t.substring(1),n));if(0<=t.indexOf("-"))throw Error('number format error: interior "-" character');for(var r=i(Math.pow(n,8)),s=o,a=0;a<t.length;a+=8){var l=Math.min(8,t.length-a),u=parseInt(t.substring(a,a+l),n);8>l?(l=i(Math.pow(n,l)),s=s.j(l).add(i(u))):s=(s=s.j(r)).add(i(u))}return s},ki=Ti.Integer=r}).apply("undefined"!==typeof Ii?Ii:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});var Ni,Ei,Ci,_i,Ai,Ri,$i,Oi,Di="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},Fi={};(function(){var e,t="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var n=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof Di&&Di];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);!function(e,r){if(r)e:{var s=n;e=e.split(".");for(var a=0;a<e.length-1;a++){var i=e[a];if(!(i in s))break e;s=s[i]}(r=r(a=s[e=e[e.length-1]]))!=a&&null!=r&&t(s,e,{configurable:!0,writable:!0,value:r})}}("Array.prototype.values",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,s={next:function(){if(!r&&n<e.length){var s=n++;return{value:t(s,e[s]),done:!1}}return r=!0,{done:!0,value:void 0}}};return s[Symbol.iterator]=function(){return s},s}(this,(function(e,t){return t}))}}));var r=r||{},s=this||self;function a(e){var t=typeof e;return"array"==(t="object"!=t?t:e?Array.isArray(e)?"array":t:"null")||"object"==t&&"number"==typeof e.length}function i(e){var t=typeof e;return"object"==t&&null!=e||"function"==t}function o(e,t,n){return e.call.apply(e.bind,arguments)}function l(e,t,n){if(!e)throw Error();if(2<arguments.length){var r=Array.prototype.slice.call(arguments,2);return function(){var n=Array.prototype.slice.call(arguments);return Array.prototype.unshift.apply(n,r),e.apply(t,n)}}return function(){return e.apply(t,arguments)}}function u(e,t,n){return(u=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?o:l).apply(null,arguments)}function c(e,t){var n=Array.prototype.slice.call(arguments,1);return function(){var t=n.slice();return t.push.apply(t,arguments),e.apply(this,t)}}function h(e,t){function n(){}n.prototype=t.prototype,e.aa=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.Qb=function(e,n,r){for(var s=Array(arguments.length-2),a=2;a<arguments.length;a++)s[a-2]=arguments[a];return t.prototype[n].apply(e,s)}}function d(e){const t=e.length;if(0<t){const n=Array(t);for(let r=0;r<t;r++)n[r]=e[r];return n}return[]}function p(e,t){for(let n=1;n<arguments.length;n++){const t=arguments[n];if(a(t)){const n=e.length||0,r=t.length||0;e.length=n+r;for(let s=0;s<r;s++)e[n+s]=t[s]}else e.push(t)}}function f(e){return/^[\s\xa0]*$/.test(e)}function m(){var e=s.navigator;return e&&(e=e.userAgent)?e:""}function g(e){return g[" "](e),e}g[" "]=function(){};var y=-1!=m().indexOf("Gecko")&&!(-1!=m().toLowerCase().indexOf("webkit")&&-1==m().indexOf("Edge"))&&!(-1!=m().indexOf("Trident")||-1!=m().indexOf("MSIE"))&&-1==m().indexOf("Edge");function b(e,t,n){for(const r in e)t.call(n,e[r],r,e)}function v(e){const t={};for(const n in e)t[n]=e[n];return t}const w="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function x(e,t){let n,r;for(let s=1;s<arguments.length;s++){for(n in r=arguments[s],r)e[n]=r[n];for(let t=0;t<w.length;t++)n=w[t],Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}}function k(e){var t=1;e=e.split(":");const n=[];for(;0<t&&e.length;)n.push(e.shift()),t--;return e.length&&n.push(e.join(":")),n}function S(e){s.setTimeout((()=>{throw e}),0)}function I(){var e=_;let t=null;return e.g&&(t=e.g,e.g=e.g.next,e.g||(e.h=null),t.next=null),t}var T=new class{constructor(e,t){this.i=e,this.j=t,this.h=0,this.g=null}get(){let e;return 0<this.h?(this.h--,e=this.g,this.g=e.next,e.next=null):e=this.i(),e}}((()=>new N),(e=>e.reset()));class N{constructor(){this.next=this.g=this.h=null}set(e,t){this.h=e,this.g=t,this.next=null}reset(){this.next=this.g=this.h=null}}let E,C=!1,_=new class{constructor(){this.h=this.g=null}add(e,t){const n=T.get();n.set(e,t),this.h?this.h.next=n:this.g=n,this.h=n}},A=()=>{const e=s.Promise.resolve(void 0);E=()=>{e.then(R)}};var R=()=>{for(var e;e=I();){try{e.h.call(e.g)}catch(n){S(n)}var t=T;t.j(e),100>t.h&&(t.h++,e.next=t.g,t.g=e)}C=!1};function $(){this.s=this.s,this.C=this.C}function O(e,t){this.type=e,this.g=this.target=t,this.defaultPrevented=!1}$.prototype.s=!1,$.prototype.ma=function(){this.s||(this.s=!0,this.N())},$.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()},O.prototype.h=function(){this.defaultPrevented=!0};var D=function(){if(!s.addEventListener||!Object.defineProperty)return!1;var e=!1,t=Object.defineProperty({},"passive",{get:function(){e=!0}});try{const e=()=>{};s.addEventListener("test",e,t),s.removeEventListener("test",e,t)}catch(n){}return e}();function F(e,t){if(O.call(this,e?e.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,e){var n=this.type=e.type,r=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:null;if(this.target=e.target||e.srcElement,this.g=t,t=e.relatedTarget){if(y){e:{try{g(t.nodeName);var s=!0;break e}catch(a){}s=!1}s||(t=null)}}else"mouseover"==n?t=e.fromElement:"mouseout"==n&&(t=e.toElement);this.relatedTarget=t,r?(this.clientX=void 0!==r.clientX?r.clientX:r.pageX,this.clientY=void 0!==r.clientY?r.clientY:r.pageY,this.screenX=r.screenX||0,this.screenY=r.screenY||0):(this.clientX=void 0!==e.clientX?e.clientX:e.pageX,this.clientY=void 0!==e.clientY?e.clientY:e.pageY,this.screenX=e.screenX||0,this.screenY=e.screenY||0),this.button=e.button,this.key=e.key||"",this.ctrlKey=e.ctrlKey,this.altKey=e.altKey,this.shiftKey=e.shiftKey,this.metaKey=e.metaKey,this.pointerId=e.pointerId||0,this.pointerType="string"===typeof e.pointerType?e.pointerType:L[e.pointerType]||"",this.state=e.state,this.i=e,e.defaultPrevented&&F.aa.h.call(this)}}h(F,O);var L={2:"touch",3:"pen",4:"mouse"};F.prototype.h=function(){F.aa.h.call(this);var e=this.i;e.preventDefault?e.preventDefault():e.returnValue=!1};var M="closure_listenable_"+(1e6*Math.random()|0),P=0;function z(e,t,n,r,s){this.listener=e,this.proxy=null,this.src=t,this.type=n,this.capture=!!r,this.ha=s,this.key=++P,this.da=this.fa=!1}function B(e){e.da=!0,e.listener=null,e.proxy=null,e.src=null,e.ha=null}function U(e){this.src=e,this.g={},this.h=0}function V(e,t){var n=t.type;if(n in e.g){var r,s=e.g[n],a=Array.prototype.indexOf.call(s,t,void 0);(r=0<=a)&&Array.prototype.splice.call(s,a,1),r&&(B(t),0==e.g[n].length&&(delete e.g[n],e.h--))}}function W(e,t,n,r){for(var s=0;s<e.length;++s){var a=e[s];if(!a.da&&a.listener==t&&a.capture==!!n&&a.ha==r)return s}return-1}U.prototype.add=function(e,t,n,r,s){var a=e.toString();(e=this.g[a])||(e=this.g[a]=[],this.h++);var i=W(e,t,r,s);return-1<i?(t=e[i],n||(t.fa=!1)):((t=new z(t,this.src,a,!!r,s)).fa=n,e.push(t)),t};var j="closure_lm_"+(1e6*Math.random()|0),G={};function H(e,t,n,r,s){if(r&&r.once)return K(e,t,n,r,s);if(Array.isArray(t)){for(var a=0;a<t.length;a++)H(e,t[a],n,r,s);return null}return n=te(n),e&&e[M]?e.K(t,n,i(r)?!!r.capture:!!r,s):q(e,t,n,!1,r,s)}function q(e,t,n,r,s,a){if(!t)throw Error("Invalid event type");var o=i(s)?!!s.capture:!!s,l=Z(e);if(l||(e[j]=l=new U(e)),(n=l.add(t,n,r,o,a)).proxy)return n;if(r=function(){function e(n){return t.call(e.src,e.listener,n)}const t=J;return e}(),n.proxy=r,r.src=e,r.listener=n,e.addEventListener)D||(s=o),void 0===s&&(s=!1),e.addEventListener(t.toString(),r,s);else if(e.attachEvent)e.attachEvent(Q(t.toString()),r);else{if(!e.addListener||!e.removeListener)throw Error("addEventListener and attachEvent are unavailable.");e.addListener(r)}return n}function K(e,t,n,r,s){if(Array.isArray(t)){for(var a=0;a<t.length;a++)K(e,t[a],n,r,s);return null}return n=te(n),e&&e[M]?e.L(t,n,i(r)?!!r.capture:!!r,s):q(e,t,n,!0,r,s)}function X(e,t,n,r,s){if(Array.isArray(t))for(var a=0;a<t.length;a++)X(e,t[a],n,r,s);else r=i(r)?!!r.capture:!!r,n=te(n),e&&e[M]?(e=e.i,(t=String(t).toString())in e.g&&(-1<(n=W(a=e.g[t],n,r,s))&&(B(a[n]),Array.prototype.splice.call(a,n,1),0==a.length&&(delete e.g[t],e.h--)))):e&&(e=Z(e))&&(t=e.g[t.toString()],e=-1,t&&(e=W(t,n,r,s)),(n=-1<e?t[e]:null)&&Y(n))}function Y(e){if("number"!==typeof e&&e&&!e.da){var t=e.src;if(t&&t[M])V(t.i,e);else{var n=e.type,r=e.proxy;t.removeEventListener?t.removeEventListener(n,r,e.capture):t.detachEvent?t.detachEvent(Q(n),r):t.addListener&&t.removeListener&&t.removeListener(r),(n=Z(t))?(V(n,e),0==n.h&&(n.src=null,t[j]=null)):B(e)}}}function Q(e){return e in G?G[e]:G[e]="on"+e}function J(e,t){if(e.da)e=!0;else{t=new F(t,this);var n=e.listener,r=e.ha||e.src;e.fa&&Y(e),e=n.call(r,t)}return e}function Z(e){return(e=e[j])instanceof U?e:null}var ee="__closure_events_fn_"+(1e9*Math.random()>>>0);function te(e){return"function"===typeof e?e:(e[ee]||(e[ee]=function(t){return e.handleEvent(t)}),e[ee])}function ne(){$.call(this),this.i=new U(this),this.M=this,this.F=null}function re(e,t){var n,r=e.F;if(r)for(n=[];r;r=r.F)n.push(r);if(e=e.M,r=t.type||t,"string"===typeof t)t=new O(t,e);else if(t instanceof O)t.target=t.target||e;else{var s=t;x(t=new O(r,e),s)}if(s=!0,n)for(var a=n.length-1;0<=a;a--){var i=t.g=n[a];s=se(i,r,!0,t)&&s}if(s=se(i=t.g=e,r,!0,t)&&s,s=se(i,r,!1,t)&&s,n)for(a=0;a<n.length;a++)s=se(i=t.g=n[a],r,!1,t)&&s}function se(e,t,n,r){if(!(t=e.i.g[String(t)]))return!0;t=t.concat();for(var s=!0,a=0;a<t.length;++a){var i=t[a];if(i&&!i.da&&i.capture==n){var o=i.listener,l=i.ha||i.src;i.fa&&V(e.i,i),s=!1!==o.call(l,r)&&s}}return s&&!r.defaultPrevented}function ae(e,t,n){if("function"===typeof e)n&&(e=u(e,n));else{if(!e||"function"!=typeof e.handleEvent)throw Error("Invalid listener argument");e=u(e.handleEvent,e)}return 2147483647<Number(t)?-1:s.setTimeout(e,t||0)}function ie(e){e.g=ae((()=>{e.g=null,e.i&&(e.i=!1,ie(e))}),e.l);const t=e.h;e.h=null,e.m.apply(null,t)}h(ne,$),ne.prototype[M]=!0,ne.prototype.removeEventListener=function(e,t,n,r){X(this,e,t,n,r)},ne.prototype.N=function(){if(ne.aa.N.call(this),this.i){var e,t=this.i;for(e in t.g){for(var n=t.g[e],r=0;r<n.length;r++)B(n[r]);delete t.g[e],t.h--}}this.F=null},ne.prototype.K=function(e,t,n,r){return this.i.add(String(e),t,!1,n,r)},ne.prototype.L=function(e,t,n,r){return this.i.add(String(e),t,!0,n,r)};class oe extends ${constructor(e,t){super(),this.m=e,this.l=t,this.h=null,this.i=!1,this.g=null}j(e){this.h=arguments,this.g?this.i=!0:ie(this)}N(){super.N(),this.g&&(s.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function le(e){$.call(this),this.h=e,this.g={}}h(le,$);var ue=[];function ce(e){b(e.g,(function(e,t){this.g.hasOwnProperty(t)&&Y(e)}),e),e.g={}}le.prototype.N=function(){le.aa.N.call(this),ce(this)},le.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var he=s.JSON.stringify,de=s.JSON.parse,pe=class{stringify(e){return s.JSON.stringify(e,void 0)}parse(e){return s.JSON.parse(e,void 0)}};function fe(){}function me(e){return e.h||(e.h=e.i())}function ge(){}fe.prototype.h=null;var ye={OPEN:"a",kb:"b",Ja:"c",wb:"d"};function be(){O.call(this,"d")}function ve(){O.call(this,"c")}h(be,O),h(ve,O);var we={},xe=null;function ke(){return xe=xe||new ne}function Se(e){O.call(this,we.La,e)}function Ie(e){const t=ke();re(t,new Se(t))}function Te(e,t){O.call(this,we.STAT_EVENT,e),this.stat=t}function Ne(e){const t=ke();re(t,new Te(t,e))}function Ee(e,t){O.call(this,we.Ma,e),this.size=t}function Ce(e,t){if("function"!==typeof e)throw Error("Fn must not be null and must be a function");return s.setTimeout((function(){e()}),t)}function _e(){this.g=!0}function Ae(e,t,n,r){e.info((function(){return"XMLHTTP TEXT ("+t+"): "+function(e,t){if(!e.g)return t;if(!t)return null;try{var n=JSON.parse(t);if(n)for(e=0;e<n.length;e++)if(Array.isArray(n[e])){var r=n[e];if(!(2>r.length)){var s=r[1];if(Array.isArray(s)&&!(1>s.length)){var a=s[0];if("noop"!=a&&"stop"!=a&&"close"!=a)for(var i=1;i<s.length;i++)s[i]=""}}}return he(n)}catch(o){return t}}(e,n)+(r?" "+r:"")}))}we.La="serverreachability",h(Se,O),we.STAT_EVENT="statevent",h(Te,O),we.Ma="timingevent",h(Ee,O),_e.prototype.xa=function(){this.g=!1},_e.prototype.info=function(){};var Re,$e={NO_ERROR:0,gb:1,tb:2,sb:3,nb:4,rb:5,ub:6,Ia:7,TIMEOUT:8,xb:9},Oe={lb:"complete",Hb:"success",Ja:"error",Ia:"abort",zb:"ready",Ab:"readystatechange",TIMEOUT:"timeout",vb:"incrementaldata",yb:"progress",ob:"downloadprogress",Pb:"uploadprogress"};function De(){}function Fe(e,t,n,r){this.j=e,this.i=t,this.l=n,this.R=r||1,this.U=new le(this),this.I=45e3,this.H=null,this.o=!1,this.m=this.A=this.v=this.L=this.F=this.S=this.B=null,this.D=[],this.g=null,this.C=0,this.s=this.u=null,this.X=-1,this.J=!1,this.O=0,this.M=null,this.W=this.K=this.T=this.P=!1,this.h=new Le}function Le(){this.i=null,this.g="",this.h=!1}h(De,fe),De.prototype.g=function(){return new XMLHttpRequest},De.prototype.i=function(){return{}},Re=new De;var Me={},Pe={};function ze(e,t,n){e.L=1,e.v=ht(it(t)),e.m=n,e.P=!0,Be(e,null)}function Be(e,t){e.F=Date.now(),We(e),e.A=it(e.v);var n=e.A,r=e.R;Array.isArray(r)||(r=[String(r)]),Tt(n.i,"t",r),e.C=0,n=e.j.J,e.h=new Le,e.g=pn(e.j,n?t:null,!e.m),0<e.O&&(e.M=new oe(u(e.Y,e,e.g),e.O)),t=e.U,n=e.g,r=e.ca;var s="readystatechange";Array.isArray(s)||(s&&(ue[0]=s.toString()),s=ue);for(var a=0;a<s.length;a++){var i=H(n,s[a],r||t.handleEvent,!1,t.h||t);if(!i)break;t.g[i.key]=i}t=e.H?v(e.H):{},e.m?(e.u||(e.u="POST"),t["Content-Type"]="application/x-www-form-urlencoded",e.g.ea(e.A,e.u,e.m,t)):(e.u="GET",e.g.ea(e.A,e.u,null,t)),Ie(),function(e,t,n,r,s,a){e.info((function(){if(e.g)if(a)for(var i="",o=a.split("&"),l=0;l<o.length;l++){var u=o[l].split("=");if(1<u.length){var c=u[0];u=u[1];var h=c.split("_");i=2<=h.length&&"type"==h[1]?i+(c+"=")+u+"&":i+(c+"=redacted&")}}else i=null;else i=a;return"XMLHTTP REQ ("+r+") [attempt "+s+"]: "+t+"\n"+n+"\n"+i}))}(e.i,e.u,e.A,e.l,e.R,e.m)}function Ue(e){return!!e.g&&("GET"==e.u&&2!=e.L&&e.j.Ca)}function Ve(e,t){var n=e.C,r=t.indexOf("\n",n);return-1==r?Pe:(n=Number(t.substring(n,r)),isNaN(n)?Me:(r+=1)+n>t.length?Pe:(t=t.slice(r,r+n),e.C=r+n,t))}function We(e){e.S=Date.now()+e.I,je(e,e.I)}function je(e,t){if(null!=e.B)throw Error("WatchDog timer not null");e.B=Ce(u(e.ba,e),t)}function Ge(e){e.B&&(s.clearTimeout(e.B),e.B=null)}function He(e){0==e.j.G||e.J||ln(e.j,e)}function qe(e){Ge(e);var t=e.M;t&&"function"==typeof t.ma&&t.ma(),e.M=null,ce(e.U),e.g&&(t=e.g,e.g=null,t.abort(),t.ma())}function Ke(e,t){try{var n=e.j;if(0!=n.G&&(n.g==e||Ze(n.h,e)))if(!e.K&&Ze(n.h,e)&&3==n.G){try{var r=n.Da.g.parse(t)}catch(c){r=null}if(Array.isArray(r)&&3==r.length){var s=r;if(0==s[0]){e:if(!n.u){if(n.g){if(!(n.g.F+3e3<e.F))break e;on(n),Yt(n)}rn(n),Ne(18)}}else n.za=s[1],0<n.za-n.T&&37500>s[2]&&n.F&&0==n.v&&!n.C&&(n.C=Ce(u(n.Za,n),6e3));if(1>=Je(n.h)&&n.ca){try{n.ca()}catch(c){}n.ca=void 0}}else cn(n,11)}else if((e.K||n.g==e)&&on(n),!f(t))for(s=n.Da.g.parse(t),t=0;t<s.length;t++){let u=s[t];if(n.T=u[0],u=u[1],2==n.G)if("c"==u[0]){n.K=u[1],n.ia=u[2];const t=u[3];null!=t&&(n.la=t,n.j.info("VER="+n.la));const s=u[4];null!=s&&(n.Aa=s,n.j.info("SVER="+n.Aa));const c=u[5];null!=c&&"number"===typeof c&&0<c&&(r=1.5*c,n.L=r,n.j.info("backChannelRequestTimeoutMs_="+r)),r=n;const h=e.g;if(h){const e=h.g?h.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(e){var a=r.h;a.g||-1==e.indexOf("spdy")&&-1==e.indexOf("quic")&&-1==e.indexOf("h2")||(a.j=a.l,a.g=new Set,a.h&&(et(a,a.h),a.h=null))}if(r.D){const e=h.g?h.g.getResponseHeader("X-HTTP-Session-Id"):null;e&&(r.ya=e,ct(r.I,r.D,e))}}n.G=3,n.l&&n.l.ua(),n.ba&&(n.R=Date.now()-e.F,n.j.info("Handshake RTT: "+n.R+"ms"));var i=e;if((r=n).qa=dn(r,r.J?r.ia:null,r.W),i.K){tt(r.h,i);var o=i,l=r.L;l&&(o.I=l),o.B&&(Ge(o),We(o)),r.g=i}else nn(r);0<n.i.length&&Jt(n)}else"stop"!=u[0]&&"close"!=u[0]||cn(n,7);else 3==n.G&&("stop"==u[0]||"close"==u[0]?"stop"==u[0]?cn(n,7):Xt(n):"noop"!=u[0]&&n.l&&n.l.ta(u),n.v=0)}Ie()}catch(c){}}Fe.prototype.ca=function(e){e=e.target;const t=this.M;t&&3==Gt(e)?t.j():this.Y(e)},Fe.prototype.Y=function(e){try{if(e==this.g)e:{const d=Gt(this.g);var t=this.g.Ba();this.g.Z();if(!(3>d)&&(3!=d||this.g&&(this.h.h||this.g.oa()||Ht(this.g)))){this.J||4!=d||7==t||Ie(),Ge(this);var n=this.g.Z();this.X=n;t:if(Ue(this)){var r=Ht(this.g);e="";var a=r.length,i=4==Gt(this.g);if(!this.h.i){if("undefined"===typeof TextDecoder){qe(this),He(this);var o="";break t}this.h.i=new s.TextDecoder}for(t=0;t<a;t++)this.h.h=!0,e+=this.h.i.decode(r[t],{stream:!(i&&t==a-1)});r.length=0,this.h.g+=e,this.C=0,o=this.h.g}else o=this.g.oa();if(this.o=200==n,function(e,t,n,r,s,a,i){e.info((function(){return"XMLHTTP RESP ("+r+") [ attempt "+s+"]: "+t+"\n"+n+"\n"+a+" "+i}))}(this.i,this.u,this.A,this.l,this.R,d,n),this.o){if(this.T&&!this.K){t:{if(this.g){var l,u=this.g;if((l=u.g?u.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!f(l)){var c=l;break t}}c=null}if(!(n=c)){this.o=!1,this.s=3,Ne(12),qe(this),He(this);break e}Ae(this.i,this.l,n,"Initial handshake response via X-HTTP-Initial-Response"),this.K=!0,Ke(this,n)}if(this.P){let e;for(n=!0;!this.J&&this.C<o.length;){if(e=Ve(this,o),e==Pe){4==d&&(this.s=4,Ne(14),n=!1),Ae(this.i,this.l,null,"[Incomplete Response]");break}if(e==Me){this.s=4,Ne(15),Ae(this.i,this.l,o,"[Invalid Chunk]"),n=!1;break}Ae(this.i,this.l,e,null),Ke(this,e)}if(Ue(this)&&0!=this.C&&(this.h.g=this.h.g.slice(this.C),this.C=0),4!=d||0!=o.length||this.h.h||(this.s=1,Ne(16),n=!1),this.o=this.o&&n,n){if(0<o.length&&!this.W){this.W=!0;var h=this.j;h.g==this&&h.ba&&!h.M&&(h.j.info("Great, no buffering proxy detected. Bytes received: "+o.length),sn(h),h.M=!0,Ne(11))}}else Ae(this.i,this.l,o,"[Invalid Chunked Response]"),qe(this),He(this)}else Ae(this.i,this.l,o,null),Ke(this,o);4==d&&qe(this),this.o&&!this.J&&(4==d?ln(this.j,this):(this.o=!1,We(this)))}else(function(e){const t={};e=(e.g&&2<=Gt(e)&&e.g.getAllResponseHeaders()||"").split("\r\n");for(let r=0;r<e.length;r++){if(f(e[r]))continue;var n=k(e[r]);const s=n[0];if("string"!==typeof(n=n[1]))continue;n=n.trim();const a=t[s]||[];t[s]=a,a.push(n)}!function(e,t){for(const n in e)t.call(void 0,e[n],n,e)}(t,(function(e){return e.join(", ")}))})(this.g),400==n&&0<o.indexOf("Unknown SID")?(this.s=3,Ne(12)):(this.s=0,Ne(13)),qe(this),He(this)}}}catch(Li){}},Fe.prototype.cancel=function(){this.J=!0,qe(this)},Fe.prototype.ba=function(){this.B=null;const e=Date.now();0<=e-this.S?(function(e,t){e.info((function(){return"TIMEOUT: "+t}))}(this.i,this.A),2!=this.L&&(Ie(),Ne(17)),qe(this),this.s=2,He(this)):je(this,this.S-e)};var Xe=class{constructor(e,t){this.g=e,this.map=t}};function Ye(e){this.l=e||10,s.PerformanceNavigationTiming?e=0<(e=s.performance.getEntriesByType("navigation")).length&&("hq"==e[0].nextHopProtocol||"h2"==e[0].nextHopProtocol):e=!!(s.chrome&&s.chrome.loadTimes&&s.chrome.loadTimes()&&s.chrome.loadTimes().wasFetchedViaSpdy),this.j=e?this.l:1,this.g=null,1<this.j&&(this.g=new Set),this.h=null,this.i=[]}function Qe(e){return!!e.h||!!e.g&&e.g.size>=e.j}function Je(e){return e.h?1:e.g?e.g.size:0}function Ze(e,t){return e.h?e.h==t:!!e.g&&e.g.has(t)}function et(e,t){e.g?e.g.add(t):e.h=t}function tt(e,t){e.h&&e.h==t?e.h=null:e.g&&e.g.has(t)&&e.g.delete(t)}function nt(e){if(null!=e.h)return e.i.concat(e.h.D);if(null!=e.g&&0!==e.g.size){let t=e.i;for(const n of e.g.values())t=t.concat(n.D);return t}return d(e.i)}function rt(e,t){if(e.forEach&&"function"==typeof e.forEach)e.forEach(t,void 0);else if(a(e)||"string"===typeof e)Array.prototype.forEach.call(e,t,void 0);else for(var n=function(e){if(e.na&&"function"==typeof e.na)return e.na();if(!e.V||"function"!=typeof e.V){if("undefined"!==typeof Map&&e instanceof Map)return Array.from(e.keys());if(!("undefined"!==typeof Set&&e instanceof Set)){if(a(e)||"string"===typeof e){var t=[];e=e.length;for(var n=0;n<e;n++)t.push(n);return t}t=[],n=0;for(const r in e)t[n++]=r;return t}}}(e),r=function(e){if(e.V&&"function"==typeof e.V)return e.V();if("undefined"!==typeof Map&&e instanceof Map||"undefined"!==typeof Set&&e instanceof Set)return Array.from(e.values());if("string"===typeof e)return e.split("");if(a(e)){for(var t=[],n=e.length,r=0;r<n;r++)t.push(e[r]);return t}for(r in t=[],n=0,e)t[n++]=e[r];return t}(e),s=r.length,i=0;i<s;i++)t.call(void 0,r[i],n&&n[i],e)}Ye.prototype.cancel=function(){if(this.i=nt(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&0!==this.g.size){for(const e of this.g.values())e.cancel();this.g.clear()}};var st=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function at(e){if(this.g=this.o=this.j="",this.s=null,this.m=this.l="",this.h=!1,e instanceof at){this.h=e.h,ot(this,e.j),this.o=e.o,this.g=e.g,lt(this,e.s),this.l=e.l;var t=e.i,n=new xt;n.i=t.i,t.g&&(n.g=new Map(t.g),n.h=t.h),ut(this,n),this.m=e.m}else e&&(t=String(e).match(st))?(this.h=!1,ot(this,t[1]||"",!0),this.o=dt(t[2]||""),this.g=dt(t[3]||"",!0),lt(this,t[4]),this.l=dt(t[5]||"",!0),ut(this,t[6]||"",!0),this.m=dt(t[7]||"")):(this.h=!1,this.i=new xt(null,this.h))}function it(e){return new at(e)}function ot(e,t,n){e.j=n?dt(t,!0):t,e.j&&(e.j=e.j.replace(/:$/,""))}function lt(e,t){if(t){if(t=Number(t),isNaN(t)||0>t)throw Error("Bad port number "+t);e.s=t}else e.s=null}function ut(e,t,n){t instanceof xt?(e.i=t,function(e,t){t&&!e.j&&(kt(e),e.i=null,e.g.forEach((function(e,t){var n=t.toLowerCase();t!=n&&(St(this,t),Tt(this,n,e))}),e)),e.j=t}(e.i,e.h)):(n||(t=pt(t,vt)),e.i=new xt(t,e.h))}function ct(e,t,n){e.i.set(t,n)}function ht(e){return ct(e,"zx",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^Date.now()).toString(36)),e}function dt(e,t){return e?t?decodeURI(e.replace(/%25/g,"%2525")):decodeURIComponent(e):""}function pt(e,t,n){return"string"===typeof e?(e=encodeURI(e).replace(t,ft),n&&(e=e.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),e):null}function ft(e){return"%"+((e=e.charCodeAt(0))>>4&15).toString(16)+(15&e).toString(16)}at.prototype.toString=function(){var e=[],t=this.j;t&&e.push(pt(t,gt,!0),":");var n=this.g;return(n||"file"==t)&&(e.push("//"),(t=this.o)&&e.push(pt(t,gt,!0),"@"),e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),null!=(n=this.s)&&e.push(":",String(n))),(n=this.l)&&(this.g&&"/"!=n.charAt(0)&&e.push("/"),e.push(pt(n,"/"==n.charAt(0)?bt:yt,!0))),(n=this.i.toString())&&e.push("?",n),(n=this.m)&&e.push("#",pt(n,wt)),e.join("")};var mt,gt=/[#\/\?@]/g,yt=/[#\?:]/g,bt=/[#\?]/g,vt=/[#\?@]/g,wt=/#/g;function xt(e,t){this.h=this.g=null,this.i=e||null,this.j=!!t}function kt(e){e.g||(e.g=new Map,e.h=0,e.i&&function(e,t){if(e){e=e.split("&");for(var n=0;n<e.length;n++){var r=e[n].indexOf("="),s=null;if(0<=r){var a=e[n].substring(0,r);s=e[n].substring(r+1)}else a=e[n];t(a,s?decodeURIComponent(s.replace(/\+/g," ")):"")}}}(e.i,(function(t,n){e.add(decodeURIComponent(t.replace(/\+/g," ")),n)})))}function St(e,t){kt(e),t=Nt(e,t),e.g.has(t)&&(e.i=null,e.h-=e.g.get(t).length,e.g.delete(t))}function It(e,t){return kt(e),t=Nt(e,t),e.g.has(t)}function Tt(e,t,n){St(e,t),0<n.length&&(e.i=null,e.g.set(Nt(e,t),d(n)),e.h+=n.length)}function Nt(e,t){return t=String(t),e.j&&(t=t.toLowerCase()),t}function Et(e,t,n,r,s){try{s&&(s.onload=null,s.onerror=null,s.onabort=null,s.ontimeout=null),r(n)}catch(a){}}function Ct(){this.g=new pe}function _t(e,t,n){const r=n||"";try{rt(e,(function(e,n){let s=e;i(e)&&(s=he(e)),t.push(r+n+"="+encodeURIComponent(s))}))}catch(t5){throw t.push(r+"type="+encodeURIComponent("_badmap")),t5}}function At(e){this.l=e.Ub||null,this.j=e.eb||!1}function Rt(e,t){ne.call(this),this.D=e,this.o=t,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.u=new Headers,this.h=null,this.B="GET",this.A="",this.g=!1,this.v=this.j=this.l=null}function $t(e){e.j.read().then(e.Pa.bind(e)).catch(e.ga.bind(e))}function Ot(e){e.readyState=4,e.l=null,e.j=null,e.v=null,Dt(e)}function Dt(e){e.onreadystatechange&&e.onreadystatechange.call(e)}function Ft(e){let t="";return b(e,(function(e,n){t+=n,t+=":",t+=e,t+="\r\n"})),t}function Lt(e,t,n){e:{for(r in n){var r=!1;break e}r=!0}r||(n=Ft(n),"string"===typeof e?null!=n&&encodeURIComponent(String(n)):ct(e,t,n))}function Mt(e){ne.call(this),this.headers=new Map,this.o=e||null,this.h=!1,this.v=this.g=null,this.D="",this.m=0,this.l="",this.j=this.B=this.u=this.A=!1,this.I=null,this.H="",this.J=!1}(e=xt.prototype).add=function(e,t){kt(this),this.i=null,e=Nt(this,e);var n=this.g.get(e);return n||this.g.set(e,n=[]),n.push(t),this.h+=1,this},e.forEach=function(e,t){kt(this),this.g.forEach((function(n,r){n.forEach((function(n){e.call(t,n,r,this)}),this)}),this)},e.na=function(){kt(this);const e=Array.from(this.g.values()),t=Array.from(this.g.keys()),n=[];for(let r=0;r<t.length;r++){const s=e[r];for(let e=0;e<s.length;e++)n.push(t[r])}return n},e.V=function(e){kt(this);let t=[];if("string"===typeof e)It(this,e)&&(t=t.concat(this.g.get(Nt(this,e))));else{e=Array.from(this.g.values());for(let n=0;n<e.length;n++)t=t.concat(e[n])}return t},e.set=function(e,t){return kt(this),this.i=null,It(this,e=Nt(this,e))&&(this.h-=this.g.get(e).length),this.g.set(e,[t]),this.h+=1,this},e.get=function(e,t){return e&&0<(e=this.V(e)).length?String(e[0]):t},e.toString=function(){if(this.i)return this.i;if(!this.g)return"";const e=[],t=Array.from(this.g.keys());for(var n=0;n<t.length;n++){var r=t[n];const a=encodeURIComponent(String(r)),i=this.V(r);for(r=0;r<i.length;r++){var s=a;""!==i[r]&&(s+="="+encodeURIComponent(String(i[r]))),e.push(s)}}return this.i=e.join("&")},h(At,fe),At.prototype.g=function(){return new Rt(this.l,this.j)},At.prototype.i=(mt={},function(){return mt}),h(Rt,ne),(e=Rt.prototype).open=function(e,t){if(0!=this.readyState)throw this.abort(),Error("Error reopening a connection");this.B=e,this.A=t,this.readyState=1,Dt(this)},e.send=function(e){if(1!=this.readyState)throw this.abort(),Error("need to call open() first. ");this.g=!0;const t={headers:this.u,method:this.B,credentials:this.m,cache:void 0};e&&(t.body=e),(this.D||s).fetch(new Request(this.A,t)).then(this.Sa.bind(this),this.ga.bind(this))},e.abort=function(){this.response=this.responseText="",this.u=new Headers,this.status=0,this.j&&this.j.cancel("Request was aborted.").catch((()=>{})),1<=this.readyState&&this.g&&4!=this.readyState&&(this.g=!1,Ot(this)),this.readyState=0},e.Sa=function(e){if(this.g&&(this.l=e,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=e.headers,this.readyState=2,Dt(this)),this.g&&(this.readyState=3,Dt(this),this.g)))if("arraybuffer"===this.responseType)e.arrayBuffer().then(this.Qa.bind(this),this.ga.bind(this));else if("undefined"!==typeof s.ReadableStream&&"body"in e){if(this.j=e.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.v=new TextDecoder;$t(this)}else e.text().then(this.Ra.bind(this),this.ga.bind(this))},e.Pa=function(e){if(this.g){if(this.o&&e.value)this.response.push(e.value);else if(!this.o){var t=e.value?e.value:new Uint8Array(0);(t=this.v.decode(t,{stream:!e.done}))&&(this.response=this.responseText+=t)}e.done?Ot(this):Dt(this),3==this.readyState&&$t(this)}},e.Ra=function(e){this.g&&(this.response=this.responseText=e,Ot(this))},e.Qa=function(e){this.g&&(this.response=e,Ot(this))},e.ga=function(){this.g&&Ot(this)},e.setRequestHeader=function(e,t){this.u.append(e,t)},e.getResponseHeader=function(e){return this.h&&this.h.get(e.toLowerCase())||""},e.getAllResponseHeaders=function(){if(!this.h)return"";const e=[],t=this.h.entries();for(var n=t.next();!n.done;)n=n.value,e.push(n[0]+": "+n[1]),n=t.next();return e.join("\r\n")},Object.defineProperty(Rt.prototype,"withCredentials",{get:function(){return"include"===this.m},set:function(e){this.m=e?"include":"same-origin"}}),h(Mt,ne);var Pt=/^https?$/i,zt=["POST","PUT"];function Bt(e,t){e.h=!1,e.g&&(e.j=!0,e.g.abort(),e.j=!1),e.l=t,e.m=5,Ut(e),Wt(e)}function Ut(e){e.A||(e.A=!0,re(e,"complete"),re(e,"error"))}function Vt(e){if(e.h&&"undefined"!=typeof r&&(!e.v[1]||4!=Gt(e)||2!=e.Z()))if(e.u&&4==Gt(e))ae(e.Ea,0,e);else if(re(e,"readystatechange"),4==Gt(e)){e.h=!1;try{const r=e.Z();e:switch(r){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var t=!0;break e;default:t=!1}var n;if(!(n=t)){var a;if(a=0===r){var i=String(e.D).match(st)[1]||null;!i&&s.self&&s.self.location&&(i=s.self.location.protocol.slice(0,-1)),a=!Pt.test(i?i.toLowerCase():"")}n=a}if(n)re(e,"complete"),re(e,"success");else{e.m=6;try{var o=2<Gt(e)?e.g.statusText:""}catch(l){o=""}e.l=o+" ["+e.Z()+"]",Ut(e)}}finally{Wt(e)}}}function Wt(e,t){if(e.g){jt(e);const n=e.g,r=e.v[0]?()=>{}:null;e.g=null,e.v=null,t||re(e,"ready");try{n.onreadystatechange=r}catch(t5){}}}function jt(e){e.I&&(s.clearTimeout(e.I),e.I=null)}function Gt(e){return e.g?e.g.readyState:0}function Ht(e){try{if(!e.g)return null;if("response"in e.g)return e.g.response;switch(e.H){case"":case"text":return e.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in e.g)return e.g.mozResponseArrayBuffer}return null}catch(zi){return null}}function qt(e,t,n){return n&&n.internalChannelParams&&n.internalChannelParams[e]||t}function Kt(e){this.Aa=0,this.i=[],this.j=new _e,this.ia=this.qa=this.I=this.W=this.g=this.ya=this.D=this.H=this.m=this.S=this.o=null,this.Ya=this.U=0,this.Va=qt("failFast",!1,e),this.F=this.C=this.u=this.s=this.l=null,this.X=!0,this.za=this.T=-1,this.Y=this.v=this.B=0,this.Ta=qt("baseRetryDelayMs",5e3,e),this.cb=qt("retryDelaySeedMs",1e4,e),this.Wa=qt("forwardChannelMaxRetries",2,e),this.wa=qt("forwardChannelRequestTimeoutMs",2e4,e),this.pa=e&&e.xmlHttpFactory||void 0,this.Xa=e&&e.Tb||void 0,this.Ca=e&&e.useFetchStreams||!1,this.L=void 0,this.J=e&&e.supportsCrossDomainXhr||!1,this.K="",this.h=new Ye(e&&e.concurrentRequestLimit),this.Da=new Ct,this.P=e&&e.fastHandshake||!1,this.O=e&&e.encodeInitMessageHeaders||!1,this.P&&this.O&&(this.O=!1),this.Ua=e&&e.Rb||!1,e&&e.xa&&this.j.xa(),e&&e.forceLongPolling&&(this.X=!1),this.ba=!this.P&&this.X&&e&&e.detectBufferingProxy||!1,this.ja=void 0,e&&e.longPollingTimeout&&0<e.longPollingTimeout&&(this.ja=e.longPollingTimeout),this.ca=void 0,this.R=0,this.M=!1,this.ka=this.A=null}function Xt(e){if(Qt(e),3==e.G){var t=e.U++,n=it(e.I);if(ct(n,"SID",e.K),ct(n,"RID",t),ct(n,"TYPE","terminate"),en(e,n),(t=new Fe(e,e.j,t)).L=2,t.v=ht(it(n)),n=!1,s.navigator&&s.navigator.sendBeacon)try{n=s.navigator.sendBeacon(t.v.toString(),"")}catch(r){}!n&&s.Image&&((new Image).src=t.v,n=!0),n||(t.g=pn(t.j,null),t.g.ea(t.v)),t.F=Date.now(),We(t)}hn(e)}function Yt(e){e.g&&(sn(e),e.g.cancel(),e.g=null)}function Qt(e){Yt(e),e.u&&(s.clearTimeout(e.u),e.u=null),on(e),e.h.cancel(),e.s&&("number"===typeof e.s&&s.clearTimeout(e.s),e.s=null)}function Jt(e){if(!Qe(e.h)&&!e.s){e.s=!0;var t=e.Ga;E||A(),C||(E(),C=!0),_.add(t,e),e.B=0}}function Zt(e,t){var n;n=t?t.l:e.U++;const r=it(e.I);ct(r,"SID",e.K),ct(r,"RID",n),ct(r,"AID",e.T),en(e,r),e.m&&e.o&&Lt(r,e.m,e.o),n=new Fe(e,e.j,n,e.B+1),null===e.m&&(n.H=e.o),t&&(e.i=t.D.concat(e.i)),t=tn(e,n,1e3),n.I=Math.round(.5*e.wa)+Math.round(.5*e.wa*Math.random()),et(e.h,n),ze(n,r,t)}function en(e,t){e.H&&b(e.H,(function(e,n){ct(t,n,e)})),e.l&&rt({},(function(e,n){ct(t,n,e)}))}function tn(e,t,n){n=Math.min(e.i.length,n);var r=e.l?u(e.l.Na,e.l,e):null;e:{var s=e.i;let t=-1;for(;;){const e=["count="+n];-1==t?0<n?(t=s[0].g,e.push("ofs="+t)):t=0:e.push("ofs="+t);let a=!0;for(let i=0;i<n;i++){let n=s[i].g;const o=s[i].map;if(n-=t,0>n)t=Math.max(0,s[i].g-100),a=!1;else try{_t(o,e,"req"+n+"_")}catch(Li){r&&r(o)}}if(a){r=e.join("&");break e}}}return e=e.i.splice(0,n),t.D=e,r}function nn(e){if(!e.g&&!e.u){e.Y=1;var t=e.Fa;E||A(),C||(E(),C=!0),_.add(t,e),e.v=0}}function rn(e){return!(e.g||e.u||3<=e.v)&&(e.Y++,e.u=Ce(u(e.Fa,e),un(e,e.v)),e.v++,!0)}function sn(e){null!=e.A&&(s.clearTimeout(e.A),e.A=null)}function an(e){e.g=new Fe(e,e.j,"rpc",e.Y),null===e.m&&(e.g.H=e.o),e.g.O=0;var t=it(e.qa);ct(t,"RID","rpc"),ct(t,"SID",e.K),ct(t,"AID",e.T),ct(t,"CI",e.F?"0":"1"),!e.F&&e.ja&&ct(t,"TO",e.ja),ct(t,"TYPE","xmlhttp"),en(e,t),e.m&&e.o&&Lt(t,e.m,e.o),e.L&&(e.g.I=e.L);var n=e.g;e=e.ia,n.L=1,n.v=ht(it(t)),n.m=null,n.P=!0,Be(n,e)}function on(e){null!=e.C&&(s.clearTimeout(e.C),e.C=null)}function ln(e,t){var n=null;if(e.g==t){on(e),sn(e),e.g=null;var r=2}else{if(!Ze(e.h,t))return;n=t.D,tt(e.h,t),r=1}if(0!=e.G)if(t.o)if(1==r){n=t.m?t.m.length:0,t=Date.now()-t.F;var s=e.B;re(r=ke(),new Ee(r,n)),Jt(e)}else nn(e);else if(3==(s=t.s)||0==s&&0<t.X||!(1==r&&function(e,t){return!(Je(e.h)>=e.h.j-(e.s?1:0))&&(e.s?(e.i=t.D.concat(e.i),!0):!(1==e.G||2==e.G||e.B>=(e.Va?0:e.Wa))&&(e.s=Ce(u(e.Ga,e,t),un(e,e.B)),e.B++,!0))}(e,t)||2==r&&rn(e)))switch(n&&0<n.length&&(t=e.h,t.i=t.i.concat(n)),s){case 1:cn(e,5);break;case 4:cn(e,10);break;case 3:cn(e,6);break;default:cn(e,2)}}function un(e,t){let n=e.Ta+Math.floor(Math.random()*e.cb);return e.isActive()||(n*=2),n*t}function cn(e,t){if(e.j.info("Error code "+t),2==t){var n=u(e.fb,e),r=e.Xa;const t=!r;r=new at(r||"//www.google.com/images/cleardot.gif"),s.location&&"http"==s.location.protocol||ot(r,"https"),ht(r),t?function(e,t){const n=new _e;if(s.Image){const r=new Image;r.onload=c(Et,n,"TestLoadImage: loaded",!0,t,r),r.onerror=c(Et,n,"TestLoadImage: error",!1,t,r),r.onabort=c(Et,n,"TestLoadImage: abort",!1,t,r),r.ontimeout=c(Et,n,"TestLoadImage: timeout",!1,t,r),s.setTimeout((function(){r.ontimeout&&r.ontimeout()}),1e4),r.src=e}else t(!1)}(r.toString(),n):function(e,t){new _e;const n=new AbortController,r=setTimeout((()=>{n.abort(),Et(0,0,!1,t)}),1e4);fetch(e,{signal:n.signal}).then((e=>{clearTimeout(r),e.ok?Et(0,0,!0,t):Et(0,0,!1,t)})).catch((()=>{clearTimeout(r),Et(0,0,!1,t)}))}(r.toString(),n)}else Ne(2);e.G=0,e.l&&e.l.sa(t),hn(e),Qt(e)}function hn(e){if(e.G=0,e.ka=[],e.l){const t=nt(e.h);0==t.length&&0==e.i.length||(p(e.ka,t),p(e.ka,e.i),e.h.i.length=0,d(e.i),e.i.length=0),e.l.ra()}}function dn(e,t,n){var r=n instanceof at?it(n):new at(n);if(""!=r.g)t&&(r.g=t+"."+r.g),lt(r,r.s);else{var a=s.location;r=a.protocol,t=t?t+"."+a.hostname:a.hostname,a=+a.port;var i=new at(null);r&&ot(i,r),t&&(i.g=t),a&&lt(i,a),n&&(i.l=n),r=i}return n=e.D,t=e.ya,n&&t&&ct(r,n,t),ct(r,"VER",e.la),en(e,r),r}function pn(e,t,n){if(t&&!e.J)throw Error("Can't create secondary domain capable XhrIo object.");return(t=e.Ca&&!e.pa?new Mt(new At({eb:n})):new Mt(e.pa)).Ha(e.J),t}function fn(){}function mn(){}function gn(e,t){ne.call(this),this.g=new Kt(t),this.l=e,this.h=t&&t.messageUrlParams||null,e=t&&t.messageHeaders||null,t&&t.clientProtocolHeaderRequired&&(e?e["X-Client-Protocol"]="webchannel":e={"X-Client-Protocol":"webchannel"}),this.g.o=e,e=t&&t.initMessageHeaders||null,t&&t.messageContentType&&(e?e["X-WebChannel-Content-Type"]=t.messageContentType:e={"X-WebChannel-Content-Type":t.messageContentType}),t&&t.va&&(e?e["X-WebChannel-Client-Profile"]=t.va:e={"X-WebChannel-Client-Profile":t.va}),this.g.S=e,(e=t&&t.Sb)&&!f(e)&&(this.g.m=e),this.v=t&&t.supportsCrossDomainXhr||!1,this.u=t&&t.sendRawJson||!1,(t=t&&t.httpSessionIdParam)&&!f(t)&&(this.g.D=t,null!==(e=this.h)&&t in e&&(t in(e=this.h)&&delete e[t])),this.j=new vn(this)}function yn(e){be.call(this),e.__headers__&&(this.headers=e.__headers__,this.statusCode=e.__status__,delete e.__headers__,delete e.__status__);var t=e.__sm__;if(t){e:{for(const n in t){e=n;break e}e=void 0}(this.i=e)&&(e=this.i,t=null!==t&&e in t?t[e]:void 0),this.data=t}else this.data=e}function bn(){ve.call(this),this.status=1}function vn(e){this.g=e}(e=Mt.prototype).Ha=function(e){this.J=e},e.ea=function(e,t,n,r){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+e);t=t?t.toUpperCase():"GET",this.D=e,this.l="",this.m=0,this.A=!1,this.h=!0,this.g=this.o?this.o.g():Re.g(),this.v=this.o?me(this.o):me(Re),this.g.onreadystatechange=u(this.Ea,this);try{this.B=!0,this.g.open(t,String(e),!0),this.B=!1}catch(i){return void Bt(this,i)}if(e=n||"",n=new Map(this.headers),r)if(Object.getPrototypeOf(r)===Object.prototype)for(var a in r)n.set(a,r[a]);else{if("function"!==typeof r.keys||"function"!==typeof r.get)throw Error("Unknown input type for opt_headers: "+String(r));for(const e of r.keys())n.set(e,r.get(e))}r=Array.from(n.keys()).find((e=>"content-type"==e.toLowerCase())),a=s.FormData&&e instanceof s.FormData,!(0<=Array.prototype.indexOf.call(zt,t,void 0))||r||a||n.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[s,o]of n)this.g.setRequestHeader(s,o);this.H&&(this.g.responseType=this.H),"withCredentials"in this.g&&this.g.withCredentials!==this.J&&(this.g.withCredentials=this.J);try{jt(this),this.u=!0,this.g.send(e),this.u=!1}catch(i){Bt(this,i)}},e.abort=function(e){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.m=e||7,re(this,"complete"),re(this,"abort"),Wt(this))},e.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),Wt(this,!0)),Mt.aa.N.call(this)},e.Ea=function(){this.s||(this.B||this.u||this.j?Vt(this):this.bb())},e.bb=function(){Vt(this)},e.isActive=function(){return!!this.g},e.Z=function(){try{return 2<Gt(this)?this.g.status:-1}catch(mt){return-1}},e.oa=function(){try{return this.g?this.g.responseText:""}catch(mt){return""}},e.Oa=function(e){if(this.g){var t=this.g.responseText;return e&&0==t.indexOf(e)&&(t=t.substring(e.length)),de(t)}},e.Ba=function(){return this.m},e.Ka=function(){return"string"===typeof this.l?this.l:String(this.l)},(e=Kt.prototype).la=8,e.G=1,e.connect=function(e,t,n,r){Ne(0),this.W=e,this.H=t||{},n&&void 0!==r&&(this.H.OSID=n,this.H.OAID=r),this.F=this.X,this.I=dn(this,null,this.W),Jt(this)},e.Ga=function(e){if(this.s)if(this.s=null,1==this.G){if(!e){this.U=Math.floor(1e5*Math.random()),e=this.U++;const s=new Fe(this,this.j,e);let a=this.o;if(this.S&&(a?(a=v(a),x(a,this.S)):a=this.S),null!==this.m||this.O||(s.H=a,a=null),this.P)e:{for(var t=0,n=0;n<this.i.length;n++){var r=this.i[n];if(void 0===(r="__data__"in r.map&&"string"===typeof(r=r.map.__data__)?r.length:void 0))break;if(4096<(t+=r)){t=n;break e}if(4096===t||n===this.i.length-1){t=n+1;break e}}t=1e3}else t=1e3;t=tn(this,s,t),ct(n=it(this.I),"RID",e),ct(n,"CVER",22),this.D&&ct(n,"X-HTTP-Session-Id",this.D),en(this,n),a&&(this.O?t="headers="+encodeURIComponent(String(Ft(a)))+"&"+t:this.m&&Lt(n,this.m,a)),et(this.h,s),this.Ua&&ct(n,"TYPE","init"),this.P?(ct(n,"$req",t),ct(n,"SID","null"),s.T=!0,ze(s,n,null)):ze(s,n,t),this.G=2}}else 3==this.G&&(e?Zt(this,e):0==this.i.length||Qe(this.h)||Zt(this))},e.Fa=function(){if(this.u=null,an(this),this.ba&&!(this.M||null==this.g||0>=this.R)){var e=2*this.R;this.j.info("BP detection timer enabled: "+e),this.A=Ce(u(this.ab,this),e)}},e.ab=function(){this.A&&(this.A=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.M=!0,Ne(10),Yt(this),an(this))},e.Za=function(){null!=this.C&&(this.C=null,Yt(this),rn(this),Ne(19))},e.fb=function(e){e?(this.j.info("Successfully pinged google.com"),Ne(2)):(this.j.info("Failed to ping google.com"),Ne(1))},e.isActive=function(){return!!this.l&&this.l.isActive(this)},(e=fn.prototype).ua=function(){},e.ta=function(){},e.sa=function(){},e.ra=function(){},e.isActive=function(){return!0},e.Na=function(){},mn.prototype.g=function(e,t){return new gn(e,t)},h(gn,ne),gn.prototype.m=function(){this.g.l=this.j,this.v&&(this.g.J=!0),this.g.connect(this.l,this.h||void 0)},gn.prototype.close=function(){Xt(this.g)},gn.prototype.o=function(e){var t=this.g;if("string"===typeof e){var n={};n.__data__=e,e=n}else this.u&&((n={}).__data__=he(e),e=n);t.i.push(new Xe(t.Ya++,e)),3==t.G&&Jt(t)},gn.prototype.N=function(){this.g.l=null,delete this.j,Xt(this.g),delete this.g,gn.aa.N.call(this)},h(yn,be),h(bn,ve),h(vn,fn),vn.prototype.ua=function(){re(this.g,"a")},vn.prototype.ta=function(e){re(this.g,new yn(e))},vn.prototype.sa=function(e){re(this.g,new bn)},vn.prototype.ra=function(){re(this.g,"b")},mn.prototype.createWebChannel=mn.prototype.g,gn.prototype.send=gn.prototype.o,gn.prototype.open=gn.prototype.m,gn.prototype.close=gn.prototype.close,Oi=Fi.createWebChannelTransport=function(){return new mn},$i=Fi.getStatEventTarget=function(){return ke()},Ri=Fi.Event=we,Ai=Fi.Stat={mb:0,pb:1,qb:2,Jb:3,Ob:4,Lb:5,Mb:6,Kb:7,Ib:8,Nb:9,PROXY:10,NOPROXY:11,Gb:12,Cb:13,Db:14,Bb:15,Eb:16,Fb:17,ib:18,hb:19,jb:20},$e.NO_ERROR=0,$e.TIMEOUT=8,$e.HTTP_ERROR=6,_i=Fi.ErrorCode=$e,Oe.COMPLETE="complete",Ci=Fi.EventType=Oe,ge.EventType=ye,ye.OPEN="a",ye.CLOSE="b",ye.ERROR="c",ye.MESSAGE="d",ne.prototype.listen=ne.prototype.K,Ei=Fi.WebChannel=ge,Fi.FetchXmlHttpFactory=At,Mt.prototype.listenOnce=Mt.prototype.L,Mt.prototype.getLastError=Mt.prototype.Ka,Mt.prototype.getLastErrorCode=Mt.prototype.Ba,Mt.prototype.getStatus=Mt.prototype.Z,Mt.prototype.getResponseJson=Mt.prototype.Oa,Mt.prototype.getResponseText=Mt.prototype.oa,Mt.prototype.send=Mt.prototype.ea,Mt.prototype.setWithCredentials=Mt.prototype.Ha,Ni=Fi.XhrIo=Mt}).apply("undefined"!==typeof Di?Di:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});const Li="@firebase/firestore";class Mi{constructor(e){this.uid=e}isAuthenticated(){return null!=this.uid}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(e){return e.uid===this.uid}}Mi.UNAUTHENTICATED=new Mi(null),Mi.GOOGLE_CREDENTIALS=new Mi("google-credentials-uid"),Mi.FIRST_PARTY=new Mi("first-party-uid"),Mi.MOCK_USER=new Mi("mock-user");let Pi="11.0.0";const zi=new Mt("@firebase/firestore");function Bi(){return zi.logLevel}function Ui(e){if(zi.logLevel<=$t.DEBUG){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(ji);zi.debug(`Firestore (${Pi}): ${e}`,...s)}}function Vi(e){if(zi.logLevel<=$t.ERROR){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(ji);zi.error(`Firestore (${Pi}): ${e}`,...s)}}function Wi(e){if(zi.logLevel<=$t.WARN){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(ji);zi.warn(`Firestore (${Pi}): ${e}`,...s)}}function ji(e){if("string"==typeof e)return e;try{return function(e){return JSON.stringify(e)}(e)}catch(t){return e}}function Gi(){const e=`FIRESTORE (${Pi}) INTERNAL ASSERTION FAILED: `+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected state");throw Vi(e),new Error(e)}function Hi(e,t){e||Gi()}function qi(e,t){return e}const Ki={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class Xi extends gt{constructor(e,t){super(e,t),this.code=e,this.message=t,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}class Yi{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}class Qi{constructor(e,t){this.user=t,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${e}`)}}class Ji{getToken(){return Promise.resolve(null)}invalidateToken(){}start(e,t){e.enqueueRetryable((()=>t(Mi.UNAUTHENTICATED)))}shutdown(){}}class Zi{constructor(e){this.token=e,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(e,t){this.changeListener=t,e.enqueueRetryable((()=>t(this.token.user)))}shutdown(){this.changeListener=null}}class eo{constructor(e){this.t=e,this.currentUser=Mi.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(e,t){Hi(void 0===this.o);let n=this.i;const r=e=>this.i!==n?(n=this.i,t(e)):Promise.resolve();let s=new Yi;this.o=()=>{this.i++,this.currentUser=this.u(),s.resolve(),s=new Yi,e.enqueueRetryable((()=>r(this.currentUser)))};const a=()=>{const t=s;e.enqueueRetryable((async()=>{await t.promise,await r(this.currentUser)}))},i=e=>{Ui("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=e,this.o&&(this.auth.addAuthTokenListener(this.o),a())};this.t.onInit((e=>i(e))),setTimeout((()=>{if(!this.auth){const e=this.t.getImmediate({optional:!0});e?i(e):(Ui("FirebaseAuthCredentialsProvider","Auth not yet detected"),s.resolve(),s=new Yi)}}),0),a()}getToken(){const e=this.i,t=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(t).then((t=>this.i!==e?(Ui("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):t?(Hi("string"==typeof t.accessToken),new Qi(t.accessToken,this.currentUser)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.o&&this.auth.removeAuthTokenListener(this.o),this.o=void 0}u(){const e=this.auth&&this.auth.getUid();return Hi(null===e||"string"==typeof e),new Mi(e)}}class to{constructor(e,t,n){this.l=e,this.h=t,this.P=n,this.type="FirstParty",this.user=Mi.FIRST_PARTY,this.I=new Map}T(){return this.P?this.P():null}get headers(){this.I.set("X-Goog-AuthUser",this.l);const e=this.T();return e&&this.I.set("Authorization",e),this.h&&this.I.set("X-Goog-Iam-Authorization-Token",this.h),this.I}}class no{constructor(e,t,n){this.l=e,this.h=t,this.P=n}getToken(){return Promise.resolve(new to(this.l,this.h,this.P))}start(e,t){e.enqueueRetryable((()=>t(Mi.FIRST_PARTY)))}shutdown(){}invalidateToken(){}}class ro{constructor(e){this.value=e,this.type="AppCheck",this.headers=new Map,e&&e.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class so{constructor(e){this.A=e,this.forceRefresh=!1,this.appCheck=null,this.R=null}start(e,t){Hi(void 0===this.o);const n=e=>{null!=e.error&&Ui("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);const n=e.token!==this.R;return this.R=e.token,Ui("FirebaseAppCheckTokenProvider",`Received ${n?"new":"existing"} token.`),n?t(e.token):Promise.resolve()};this.o=t=>{e.enqueueRetryable((()=>n(t)))};const r=e=>{Ui("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=e,this.o&&this.appCheck.addTokenListener(this.o)};this.A.onInit((e=>r(e))),setTimeout((()=>{if(!this.appCheck){const e=this.A.getImmediate({optional:!0});e?r(e):Ui("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}}),0)}getToken(){const e=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(e).then((e=>e?(Hi("string"==typeof e.token),this.R=e.token,new ro(e.token)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.o&&this.appCheck.removeTokenListener(this.o),this.o=void 0}}function ao(e){const t="undefined"!=typeof self&&(self.crypto||self.msCrypto),n=new Uint8Array(e);if(t&&"function"==typeof t.getRandomValues)t.getRandomValues(n);else for(let r=0;r<e;r++)n[r]=Math.floor(256*Math.random());return n}class io{static newId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",t=62*Math.floor(256/62);let n="";for(;n.length<20;){const r=ao(40);for(let s=0;s<r.length;++s)n.length<20&&r[s]<t&&(n+=e.charAt(r[s]%62))}return n}}function oo(e,t){return e<t?-1:e>t?1:0}function lo(e,t,n){return e.length===t.length&&e.every(((e,r)=>n(e,t[r])))}class uo{constructor(e,t){if(this.seconds=e,this.nanoseconds=t,t<0)throw new Xi(Ki.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(t>=1e9)throw new Xi(Ki.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(e<-62135596800)throw new Xi(Ki.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e);if(e>=253402300800)throw new Xi(Ki.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e)}static now(){return uo.fromMillis(Date.now())}static fromDate(e){return uo.fromMillis(e.getTime())}static fromMillis(e){const t=Math.floor(e/1e3),n=Math.floor(1e6*(e-1e3*t));return new uo(t,n)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/1e6}_compareTo(e){return this.seconds===e.seconds?oo(this.nanoseconds,e.nanoseconds):oo(this.seconds,e.seconds)}isEqual(e){return e.seconds===this.seconds&&e.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{seconds:this.seconds,nanoseconds:this.nanoseconds}}valueOf(){const e=this.seconds- -62135596800;return String(e).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}class co{constructor(e){this.timestamp=e}static fromTimestamp(e){return new co(e)}static min(){return new co(new uo(0,0))}static max(){return new co(new uo(253402300799,999999999))}compareTo(e){return this.timestamp._compareTo(e.timestamp)}isEqual(e){return this.timestamp.isEqual(e.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}class ho{constructor(e,t,n){void 0===t?t=0:t>e.length&&Gi(),void 0===n?n=e.length-t:n>e.length-t&&Gi(),this.segments=e,this.offset=t,this.len=n}get length(){return this.len}isEqual(e){return 0===ho.comparator(this,e)}child(e){const t=this.segments.slice(this.offset,this.limit());return e instanceof ho?e.forEach((e=>{t.push(e)})):t.push(e),this.construct(t)}limit(){return this.offset+this.length}popFirst(e){return e=void 0===e?1:e,this.construct(this.segments,this.offset+e,this.length-e)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(e){return this.segments[this.offset+e]}isEmpty(){return 0===this.length}isPrefixOf(e){if(e.length<this.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}isImmediateParentOf(e){if(this.length+1!==e.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}forEach(e){for(let t=this.offset,n=this.limit();t<n;t++)e(this.segments[t])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(e,t){const n=Math.min(e.length,t.length);for(let r=0;r<n;r++){const n=e.get(r),s=t.get(r);if(n<s)return-1;if(n>s)return 1}return e.length<t.length?-1:e.length>t.length?1:0}}class po extends ho{construct(e,t,n){return new po(e,t,n)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const s of n){if(s.indexOf("//")>=0)throw new Xi(Ki.INVALID_ARGUMENT,`Invalid segment (${s}). Paths must not contain // in them.`);e.push(...s.split("/").filter((e=>e.length>0)))}return new po(e)}static emptyPath(){return new po([])}}const fo=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class mo extends ho{construct(e,t,n){return new mo(e,t,n)}static isValidIdentifier(e){return fo.test(e)}canonicalString(){return this.toArray().map((e=>(e=e.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),mo.isValidIdentifier(e)||(e="`"+e+"`"),e))).join(".")}toString(){return this.canonicalString()}isKeyField(){return 1===this.length&&"__name__"===this.get(0)}static keyField(){return new mo(["__name__"])}static fromServerFormat(e){const t=[];let n="",r=0;const s=()=>{if(0===n.length)throw new Xi(Ki.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);t.push(n),n=""};let a=!1;for(;r<e.length;){const t=e[r];if("\\"===t){if(r+1===e.length)throw new Xi(Ki.INVALID_ARGUMENT,"Path has trailing escape character: "+e);const t=e[r+1];if("\\"!==t&&"."!==t&&"`"!==t)throw new Xi(Ki.INVALID_ARGUMENT,"Path has invalid escape sequence: "+e);n+=t,r+=2}else"`"===t?(a=!a,r++):"."!==t||a?(n+=t,r++):(s(),r++)}if(s(),a)throw new Xi(Ki.INVALID_ARGUMENT,"Unterminated ` in path: "+e);return new mo(t)}static emptyPath(){return new mo([])}}class go{constructor(e){this.path=e}static fromPath(e){return new go(po.fromString(e))}static fromName(e){return new go(po.fromString(e).popFirst(5))}static empty(){return new go(po.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(e){return this.path.length>=2&&this.path.get(this.path.length-2)===e}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(e){return null!==e&&0===po.comparator(this.path,e.path)}toString(){return this.path.toString()}static comparator(e,t){return po.comparator(e.path,t.path)}static isDocumentKey(e){return e.length%2==0}static fromSegments(e){return new go(new po(e.slice()))}}class yo{constructor(e,t,n,r){this.indexId=e,this.collectionGroup=t,this.fields=n,this.indexState=r}}yo.UNKNOWN_ID=-1;function bo(e,t){const n=e.toTimestamp().seconds,r=e.toTimestamp().nanoseconds+1,s=co.fromTimestamp(1e9===r?new uo(n+1,0):new uo(n,r));return new wo(s,go.empty(),t)}function vo(e){return new wo(e.readTime,e.key,-1)}class wo{constructor(e,t,n){this.readTime=e,this.documentKey=t,this.largestBatchId=n}static min(){return new wo(co.min(),go.empty(),-1)}static max(){return new wo(co.max(),go.empty(),-1)}}function xo(e,t){let n=e.readTime.compareTo(t.readTime);return 0!==n?n:(n=go.comparator(e.documentKey,t.documentKey),0!==n?n:oo(e.largestBatchId,t.largestBatchId))}const ko="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class So{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(e){this.onCommittedListeners.push(e)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach((e=>e()))}}async function Io(e){if(e.code!==Ki.FAILED_PRECONDITION||e.message!==ko)throw e;Ui("LocalStore","Unexpectedly lost primary lease")}class To{constructor(e){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,e((e=>{this.isDone=!0,this.result=e,this.nextCallback&&this.nextCallback(e)}),(e=>{this.isDone=!0,this.error=e,this.catchCallback&&this.catchCallback(e)}))}catch(e){return this.next(void 0,e)}next(e,t){return this.callbackAttached&&Gi(),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(t,this.error):this.wrapSuccess(e,this.result):new To(((n,r)=>{this.nextCallback=t=>{this.wrapSuccess(e,t).next(n,r)},this.catchCallback=e=>{this.wrapFailure(t,e).next(n,r)}}))}toPromise(){return new Promise(((e,t)=>{this.next(e,t)}))}wrapUserFunction(e){try{const t=e();return t instanceof To?t:To.resolve(t)}catch(e){return To.reject(e)}}wrapSuccess(e,t){return e?this.wrapUserFunction((()=>e(t))):To.resolve(t)}wrapFailure(e,t){return e?this.wrapUserFunction((()=>e(t))):To.reject(t)}static resolve(e){return new To(((t,n)=>{t(e)}))}static reject(e){return new To(((t,n)=>{n(e)}))}static waitFor(e){return new To(((t,n)=>{let r=0,s=0,a=!1;e.forEach((e=>{++r,e.next((()=>{++s,a&&s===r&&t()}),(e=>n(e)))})),a=!0,s===r&&t()}))}static or(e){let t=To.resolve(!1);for(const n of e)t=t.next((e=>e?To.resolve(e):n()));return t}static forEach(e,t){const n=[];return e.forEach(((e,r)=>{n.push(t.call(this,e,r))})),this.waitFor(n)}static mapArray(e,t){return new To(((n,r)=>{const s=e.length,a=new Array(s);let i=0;for(let o=0;o<s;o++){const l=o;t(e[l]).next((e=>{a[l]=e,++i,i===s&&n(a)}),(e=>r(e)))}}))}static doWhile(e,t){return new To(((n,r)=>{const s=()=>{!0===e()?t().next((()=>{s()}),r):n()};s()}))}}function No(e){const t=e.match(/Android ([\d.]+)/i),n=t?t[1].split(".").slice(0,2).join("."):"-1";return Number(n)}function Eo(e){return"IndexedDbTransactionError"===e.name}class Co{constructor(e,t){this.previousValue=e,t&&(t.sequenceNumberHandler=e=>this.ie(e),this.se=e=>t.writeSequenceNumber(e))}ie(e){return this.previousValue=Math.max(e,this.previousValue),this.previousValue}next(){const e=++this.previousValue;return this.se&&this.se(e),e}}function _o(e){return null==e}function Ao(e){return 0===e&&1/e==-1/0}function Ro(e){return"number"==typeof e&&Number.isInteger(e)&&!Ao(e)&&e<=Number.MAX_SAFE_INTEGER&&e>=Number.MIN_SAFE_INTEGER}function $o(e){let t="";for(let n=0;n<e.length;n++)t.length>0&&(t=Do(t)),t=Oo(e.get(n),t);return Do(t)}function Oo(e,t){let n=t;const r=e.length;for(let s=0;s<r;s++){const t=e.charAt(s);switch(t){case"\0":n+="\x01\x10";break;case"\x01":n+="\x01\x11";break;default:n+=t}}return n}function Do(e){return e+"\x01\x01"}Co.oe=-1;const Fo=["mutationQueues","mutations","documentMutations","remoteDocuments","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries"],Lo=["mutationQueues","mutations","documentMutations","remoteDocumentsV14","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries","documentOverlays"],Mo=Lo,Po=[...Mo,"indexConfiguration","indexState","indexEntries"];function zo(e){let t=0;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t++;return t}function Bo(e,t){for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function Uo(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}class Vo{constructor(e,t){this.comparator=e,this.root=t||jo.EMPTY}insert(e,t){return new Vo(this.comparator,this.root.insert(e,t,this.comparator).copy(null,null,jo.BLACK,null,null))}remove(e){return new Vo(this.comparator,this.root.remove(e,this.comparator).copy(null,null,jo.BLACK,null,null))}get(e){let t=this.root;for(;!t.isEmpty();){const n=this.comparator(e,t.key);if(0===n)return t.value;n<0?t=t.left:n>0&&(t=t.right)}return null}indexOf(e){let t=0,n=this.root;for(;!n.isEmpty();){const r=this.comparator(e,n.key);if(0===r)return t+n.left.size;r<0?n=n.left:(t+=n.left.size+1,n=n.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(e){return this.root.inorderTraversal(e)}forEach(e){this.inorderTraversal(((t,n)=>(e(t,n),!1)))}toString(){const e=[];return this.inorderTraversal(((t,n)=>(e.push(`${t}:${n}`),!1))),`{${e.join(", ")}}`}reverseTraversal(e){return this.root.reverseTraversal(e)}getIterator(){return new Wo(this.root,null,this.comparator,!1)}getIteratorFrom(e){return new Wo(this.root,e,this.comparator,!1)}getReverseIterator(){return new Wo(this.root,null,this.comparator,!0)}getReverseIteratorFrom(e){return new Wo(this.root,e,this.comparator,!0)}}class Wo{constructor(e,t,n,r){this.isReverse=r,this.nodeStack=[];let s=1;for(;!e.isEmpty();)if(s=t?n(e.key,t):1,t&&r&&(s*=-1),s<0)e=this.isReverse?e.left:e.right;else{if(0===s){this.nodeStack.push(e);break}this.nodeStack.push(e),e=this.isReverse?e.right:e.left}}getNext(){let e=this.nodeStack.pop();const t={key:e.key,value:e.value};if(this.isReverse)for(e=e.left;!e.isEmpty();)this.nodeStack.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack.push(e),e=e.left;return t}hasNext(){return this.nodeStack.length>0}peek(){if(0===this.nodeStack.length)return null;const e=this.nodeStack[this.nodeStack.length-1];return{key:e.key,value:e.value}}}class jo{constructor(e,t,n,r,s){this.key=e,this.value=t,this.color=null!=n?n:jo.RED,this.left=null!=r?r:jo.EMPTY,this.right=null!=s?s:jo.EMPTY,this.size=this.left.size+1+this.right.size}copy(e,t,n,r,s){return new jo(null!=e?e:this.key,null!=t?t:this.value,null!=n?n:this.color,null!=r?r:this.left,null!=s?s:this.right)}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,t,n){let r=this;const s=n(e,r.key);return r=s<0?r.copy(null,null,null,r.left.insert(e,t,n),null):0===s?r.copy(null,t,null,null,null):r.copy(null,null,null,null,r.right.insert(e,t,n)),r.fixUp()}removeMin(){if(this.left.isEmpty())return jo.EMPTY;let e=this;return e.left.isRed()||e.left.left.isRed()||(e=e.moveRedLeft()),e=e.copy(null,null,null,e.left.removeMin(),null),e.fixUp()}remove(e,t){let n,r=this;if(t(e,r.key)<0)r.left.isEmpty()||r.left.isRed()||r.left.left.isRed()||(r=r.moveRedLeft()),r=r.copy(null,null,null,r.left.remove(e,t),null);else{if(r.left.isRed()&&(r=r.rotateRight()),r.right.isEmpty()||r.right.isRed()||r.right.left.isRed()||(r=r.moveRedRight()),0===t(e,r.key)){if(r.right.isEmpty())return jo.EMPTY;n=r.right.min(),r=r.copy(n.key,n.value,null,null,r.right.removeMin())}r=r.copy(null,null,null,null,r.right.remove(e,t))}return r.fixUp()}isRed(){return this.color}fixUp(){let e=this;return e.right.isRed()&&!e.left.isRed()&&(e=e.rotateLeft()),e.left.isRed()&&e.left.left.isRed()&&(e=e.rotateRight()),e.left.isRed()&&e.right.isRed()&&(e=e.colorFlip()),e}moveRedLeft(){let e=this.colorFlip();return e.right.left.isRed()&&(e=e.copy(null,null,null,null,e.right.rotateRight()),e=e.rotateLeft(),e=e.colorFlip()),e}moveRedRight(){let e=this.colorFlip();return e.left.left.isRed()&&(e=e.rotateRight(),e=e.colorFlip()),e}rotateLeft(){const e=this.copy(null,null,jo.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight(){const e=this.copy(null,null,jo.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip(){const e=this.left.copy(null,null,!this.left.color,null,null),t=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,t)}checkMaxDepth(){const e=this.check();return Math.pow(2,e)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw Gi();if(this.right.isRed())throw Gi();const e=this.left.check();if(e!==this.right.check())throw Gi();return e+(this.isRed()?0:1)}}jo.EMPTY=null,jo.RED=!0,jo.BLACK=!1,jo.EMPTY=new class{constructor(){this.size=0}get key(){throw Gi()}get value(){throw Gi()}get color(){throw Gi()}get left(){throw Gi()}get right(){throw Gi()}copy(e,t,n,r,s){return this}insert(e,t,n){return new jo(e,t)}remove(e,t){return this}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};class Go{constructor(e){this.comparator=e,this.data=new Vo(this.comparator)}has(e){return null!==this.data.get(e)}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(e){return this.data.indexOf(e)}forEach(e){this.data.inorderTraversal(((t,n)=>(e(t),!1)))}forEachInRange(e,t){const n=this.data.getIteratorFrom(e[0]);for(;n.hasNext();){const r=n.getNext();if(this.comparator(r.key,e[1])>=0)return;t(r.key)}}forEachWhile(e,t){let n;for(n=void 0!==t?this.data.getIteratorFrom(t):this.data.getIterator();n.hasNext();)if(!e(n.getNext().key))return}firstAfterOrEqual(e){const t=this.data.getIteratorFrom(e);return t.hasNext()?t.getNext().key:null}getIterator(){return new Ho(this.data.getIterator())}getIteratorFrom(e){return new Ho(this.data.getIteratorFrom(e))}add(e){return this.copy(this.data.remove(e).insert(e,!0))}delete(e){return this.has(e)?this.copy(this.data.remove(e)):this}isEmpty(){return this.data.isEmpty()}unionWith(e){let t=this;return t.size<e.size&&(t=e,e=this),e.forEach((e=>{t=t.add(e)})),t}isEqual(e){if(!(e instanceof Go))return!1;if(this.size!==e.size)return!1;const t=this.data.getIterator(),n=e.data.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(0!==this.comparator(e,r))return!1}return!0}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}toString(){const e=[];return this.forEach((t=>e.push(t))),"SortedSet("+e.toString()+")"}copy(e){const t=new Go(this.comparator);return t.data=e,t}}class Ho{constructor(e){this.iter=e}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}class qo{constructor(e){this.fields=e,e.sort(mo.comparator)}static empty(){return new qo([])}unionWith(e){let t=new Go(mo.comparator);for(const n of this.fields)t=t.add(n);for(const n of e)t=t.add(n);return new qo(t.toArray())}covers(e){for(const t of this.fields)if(t.isPrefixOf(e))return!0;return!1}isEqual(e){return lo(this.fields,e.fields,((e,t)=>e.isEqual(t)))}}class Ko extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}class Xo{constructor(e){this.binaryString=e}static fromBase64String(e){const t=function(e){try{return atob(e)}catch(e){throw"undefined"!=typeof DOMException&&e instanceof DOMException?new Ko("Invalid base64 string: "+e):e}}(e);return new Xo(t)}static fromUint8Array(e){const t=function(e){let t="";for(let n=0;n<e.length;++n)t+=String.fromCharCode(e[n]);return t}(e);return new Xo(t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.binaryString.length?{value:this.binaryString.charCodeAt(e++),done:!1}:{value:void 0,done:!0}}}toBase64(){return e=this.binaryString,btoa(e);var e}toUint8Array(){return function(e){const t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(e){return oo(this.binaryString,e.binaryString)}isEqual(e){return this.binaryString===e.binaryString}}Xo.EMPTY_BYTE_STRING=new Xo("");const Yo=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function Qo(e){if(Hi(!!e),"string"==typeof e){let t=0;const n=Yo.exec(e);if(Hi(!!n),n[1]){let e=n[1];e=(e+"000000000").substr(0,9),t=Number(e)}const r=new Date(e);return{seconds:Math.floor(r.getTime()/1e3),nanos:t}}return{seconds:Jo(e.seconds),nanos:Jo(e.nanos)}}function Jo(e){return"number"==typeof e?e:"string"==typeof e?Number(e):0}function Zo(e){return"string"==typeof e?Xo.fromBase64String(e):Xo.fromUint8Array(e)}function el(e){var t,n;return"server_timestamp"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function tl(e){const t=e.mapValue.fields.__previous_value__;return el(t)?tl(t):t}function nl(e){const t=Qo(e.mapValue.fields.__local_write_time__.timestampValue);return new uo(t.seconds,t.nanos)}class rl{constructor(e,t,n,r,s,a,i,o,l){this.databaseId=e,this.appId=t,this.persistenceKey=n,this.host=r,this.ssl=s,this.forceLongPolling=a,this.autoDetectLongPolling=i,this.longPollingOptions=o,this.useFetchStreams=l}}class sl{constructor(e,t){this.projectId=e,this.database=t||"(default)"}static empty(){return new sl("","")}get isDefaultDatabase(){return"(default)"===this.database}isEqual(e){return e instanceof sl&&e.projectId===this.projectId&&e.database===this.database}}const al={mapValue:{fields:{__type__:{stringValue:"__max__"}}}};function il(e){return"nullValue"in e?0:"booleanValue"in e?1:"integerValue"in e||"doubleValue"in e?2:"timestampValue"in e?3:"stringValue"in e?5:"bytesValue"in e?6:"referenceValue"in e?7:"geoPointValue"in e?8:"arrayValue"in e?9:"mapValue"in e?el(e)?4:Sl(e)?9007199254740991:xl(e)?10:11:Gi()}function ol(e,t){if(e===t)return!0;const n=il(e);if(n!==il(t))return!1;switch(n){case 0:case 9007199254740991:return!0;case 1:return e.booleanValue===t.booleanValue;case 4:return nl(e).isEqual(nl(t));case 3:return function(e,t){if("string"==typeof e.timestampValue&&"string"==typeof t.timestampValue&&e.timestampValue.length===t.timestampValue.length)return e.timestampValue===t.timestampValue;const n=Qo(e.timestampValue),r=Qo(t.timestampValue);return n.seconds===r.seconds&&n.nanos===r.nanos}(e,t);case 5:return e.stringValue===t.stringValue;case 6:return function(e,t){return Zo(e.bytesValue).isEqual(Zo(t.bytesValue))}(e,t);case 7:return e.referenceValue===t.referenceValue;case 8:return function(e,t){return Jo(e.geoPointValue.latitude)===Jo(t.geoPointValue.latitude)&&Jo(e.geoPointValue.longitude)===Jo(t.geoPointValue.longitude)}(e,t);case 2:return function(e,t){if("integerValue"in e&&"integerValue"in t)return Jo(e.integerValue)===Jo(t.integerValue);if("doubleValue"in e&&"doubleValue"in t){const n=Jo(e.doubleValue),r=Jo(t.doubleValue);return n===r?Ao(n)===Ao(r):isNaN(n)&&isNaN(r)}return!1}(e,t);case 9:return lo(e.arrayValue.values||[],t.arrayValue.values||[],ol);case 10:case 11:return function(e,t){const n=e.mapValue.fields||{},r=t.mapValue.fields||{};if(zo(n)!==zo(r))return!1;for(const s in n)if(n.hasOwnProperty(s)&&(void 0===r[s]||!ol(n[s],r[s])))return!1;return!0}(e,t);default:return Gi()}}function ll(e,t){return void 0!==(e.values||[]).find((e=>ol(e,t)))}function ul(e,t){if(e===t)return 0;const n=il(e),r=il(t);if(n!==r)return oo(n,r);switch(n){case 0:case 9007199254740991:return 0;case 1:return oo(e.booleanValue,t.booleanValue);case 2:return function(e,t){const n=Jo(e.integerValue||e.doubleValue),r=Jo(t.integerValue||t.doubleValue);return n<r?-1:n>r?1:n===r?0:isNaN(n)?isNaN(r)?0:-1:1}(e,t);case 3:return cl(e.timestampValue,t.timestampValue);case 4:return cl(nl(e),nl(t));case 5:return oo(e.stringValue,t.stringValue);case 6:return function(e,t){const n=Zo(e),r=Zo(t);return n.compareTo(r)}(e.bytesValue,t.bytesValue);case 7:return function(e,t){const n=e.split("/"),r=t.split("/");for(let s=0;s<n.length&&s<r.length;s++){const e=oo(n[s],r[s]);if(0!==e)return e}return oo(n.length,r.length)}(e.referenceValue,t.referenceValue);case 8:return function(e,t){const n=oo(Jo(e.latitude),Jo(t.latitude));return 0!==n?n:oo(Jo(e.longitude),Jo(t.longitude))}(e.geoPointValue,t.geoPointValue);case 9:return hl(e.arrayValue,t.arrayValue);case 10:return function(e,t){var n,r,s,a;const i=e.fields||{},o=t.fields||{},l=null===(n=i.value)||void 0===n?void 0:n.arrayValue,u=null===(r=o.value)||void 0===r?void 0:r.arrayValue,c=oo((null===(s=null==l?void 0:l.values)||void 0===s?void 0:s.length)||0,(null===(a=null==u?void 0:u.values)||void 0===a?void 0:a.length)||0);return 0!==c?c:hl(l,u)}(e.mapValue,t.mapValue);case 11:return function(e,t){if(e===al.mapValue&&t===al.mapValue)return 0;if(e===al.mapValue)return 1;if(t===al.mapValue)return-1;const n=e.fields||{},r=Object.keys(n),s=t.fields||{},a=Object.keys(s);r.sort(),a.sort();for(let i=0;i<r.length&&i<a.length;++i){const e=oo(r[i],a[i]);if(0!==e)return e;const t=ul(n[r[i]],s[a[i]]);if(0!==t)return t}return oo(r.length,a.length)}(e.mapValue,t.mapValue);default:throw Gi()}}function cl(e,t){if("string"==typeof e&&"string"==typeof t&&e.length===t.length)return oo(e,t);const n=Qo(e),r=Qo(t),s=oo(n.seconds,r.seconds);return 0!==s?s:oo(n.nanos,r.nanos)}function hl(e,t){const n=e.values||[],r=t.values||[];for(let s=0;s<n.length&&s<r.length;++s){const e=ul(n[s],r[s]);if(e)return e}return oo(n.length,r.length)}function dl(e){return pl(e)}function pl(e){return"nullValue"in e?"null":"booleanValue"in e?""+e.booleanValue:"integerValue"in e?""+e.integerValue:"doubleValue"in e?""+e.doubleValue:"timestampValue"in e?function(e){const t=Qo(e);return`time(${t.seconds},${t.nanos})`}(e.timestampValue):"stringValue"in e?e.stringValue:"bytesValue"in e?function(e){return Zo(e).toBase64()}(e.bytesValue):"referenceValue"in e?function(e){return go.fromName(e).toString()}(e.referenceValue):"geoPointValue"in e?function(e){return`geo(${e.latitude},${e.longitude})`}(e.geoPointValue):"arrayValue"in e?function(e){let t="[",n=!0;for(const r of e.values||[])n?n=!1:t+=",",t+=pl(r);return t+"]"}(e.arrayValue):"mapValue"in e?function(e){const t=Object.keys(e.fields||{}).sort();let n="{",r=!0;for(const s of t)r?r=!1:n+=",",n+=`${s}:${pl(e.fields[s])}`;return n+"}"}(e.mapValue):Gi()}function fl(e){switch(il(e)){case 0:case 1:return 4;case 2:return 8;case 3:case 8:return 16;case 4:const t=tl(e);return t?16+fl(t):16;case 5:return 2*e.stringValue.length;case 6:return Zo(e.bytesValue).approximateByteSize();case 7:return e.referenceValue.length;case 9:return function(e){return(e.values||[]).reduce(((e,t)=>e+fl(t)),0)}(e.arrayValue);case 10:case 11:return function(e){let t=0;return Bo(e.fields,((e,n)=>{t+=e.length+fl(n)})),t}(e.mapValue);default:throw Gi()}}function ml(e,t){return{referenceValue:`projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}`}}function gl(e){return!!e&&"integerValue"in e}function yl(e){return!!e&&"arrayValue"in e}function bl(e){return!!e&&"nullValue"in e}function vl(e){return!!e&&"doubleValue"in e&&isNaN(Number(e.doubleValue))}function wl(e){return!!e&&"mapValue"in e}function xl(e){var t,n;return"__vector__"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function kl(e){if(e.geoPointValue)return{geoPointValue:Object.assign({},e.geoPointValue)};if(e.timestampValue&&"object"==typeof e.timestampValue)return{timestampValue:Object.assign({},e.timestampValue)};if(e.mapValue){const t={mapValue:{fields:{}}};return Bo(e.mapValue.fields,((e,n)=>t.mapValue.fields[e]=kl(n))),t}if(e.arrayValue){const t={arrayValue:{values:[]}};for(let n=0;n<(e.arrayValue.values||[]).length;++n)t.arrayValue.values[n]=kl(e.arrayValue.values[n]);return t}return Object.assign({},e)}function Sl(e){return"__max__"===(((e.mapValue||{}).fields||{}).__type__||{}).stringValue}class Il{constructor(e){this.value=e}static empty(){return new Il({mapValue:{}})}field(e){if(e.isEmpty())return this.value;{let t=this.value;for(let n=0;n<e.length-1;++n)if(t=(t.mapValue.fields||{})[e.get(n)],!wl(t))return null;return t=(t.mapValue.fields||{})[e.lastSegment()],t||null}}set(e,t){this.getFieldsMap(e.popLast())[e.lastSegment()]=kl(t)}setAll(e){let t=mo.emptyPath(),n={},r=[];e.forEach(((e,s)=>{if(!t.isImmediateParentOf(s)){const e=this.getFieldsMap(t);this.applyChanges(e,n,r),n={},r=[],t=s.popLast()}e?n[s.lastSegment()]=kl(e):r.push(s.lastSegment())}));const s=this.getFieldsMap(t);this.applyChanges(s,n,r)}delete(e){const t=this.field(e.popLast());wl(t)&&t.mapValue.fields&&delete t.mapValue.fields[e.lastSegment()]}isEqual(e){return ol(this.value,e.value)}getFieldsMap(e){let t=this.value;t.mapValue.fields||(t.mapValue={fields:{}});for(let n=0;n<e.length;++n){let r=t.mapValue.fields[e.get(n)];wl(r)&&r.mapValue.fields||(r={mapValue:{fields:{}}},t.mapValue.fields[e.get(n)]=r),t=r}return t.mapValue.fields}applyChanges(e,t,n){Bo(t,((t,n)=>e[t]=n));for(const r of n)delete e[r]}clone(){return new Il(kl(this.value))}}function Tl(e){const t=[];return Bo(e.fields,((e,n)=>{const r=new mo([e]);if(wl(n)){const e=Tl(n.mapValue).fields;if(0===e.length)t.push(r);else for(const n of e)t.push(r.child(n))}else t.push(r)})),new qo(t)}class Nl{constructor(e,t,n,r,s,a,i){this.key=e,this.documentType=t,this.version=n,this.readTime=r,this.createTime=s,this.data=a,this.documentState=i}static newInvalidDocument(e){return new Nl(e,0,co.min(),co.min(),co.min(),Il.empty(),0)}static newFoundDocument(e,t,n,r){return new Nl(e,1,t,co.min(),n,r,0)}static newNoDocument(e,t){return new Nl(e,2,t,co.min(),co.min(),Il.empty(),0)}static newUnknownDocument(e,t){return new Nl(e,3,t,co.min(),co.min(),Il.empty(),2)}convertToFoundDocument(e,t){return!this.createTime.isEqual(co.min())||2!==this.documentType&&0!==this.documentType||(this.createTime=e),this.version=e,this.documentType=1,this.data=t,this.documentState=0,this}convertToNoDocument(e){return this.version=e,this.documentType=2,this.data=Il.empty(),this.documentState=0,this}convertToUnknownDocument(e){return this.version=e,this.documentType=3,this.data=Il.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=co.min(),this}setReadTime(e){return this.readTime=e,this}get hasLocalMutations(){return 1===this.documentState}get hasCommittedMutations(){return 2===this.documentState}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return 0!==this.documentType}isFoundDocument(){return 1===this.documentType}isNoDocument(){return 2===this.documentType}isUnknownDocument(){return 3===this.documentType}isEqual(e){return e instanceof Nl&&this.key.isEqual(e.key)&&this.version.isEqual(e.version)&&this.documentType===e.documentType&&this.documentState===e.documentState&&this.data.isEqual(e.data)}mutableCopy(){return new Nl(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}class El{constructor(e,t){this.position=e,this.inclusive=t}}function Cl(e,t,n){let r=0;for(let s=0;s<e.position.length;s++){const a=t[s],i=e.position[s];if(r=a.field.isKeyField()?go.comparator(go.fromName(i.referenceValue),n.key):ul(i,n.data.field(a.field)),"desc"===a.dir&&(r*=-1),0!==r)break}return r}function _l(e,t){if(null===e)return null===t;if(null===t)return!1;if(e.inclusive!==t.inclusive||e.position.length!==t.position.length)return!1;for(let n=0;n<e.position.length;n++)if(!ol(e.position[n],t.position[n]))return!1;return!0}class Al{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"asc";this.field=e,this.dir=t}}function Rl(e,t){return e.dir===t.dir&&e.field.isEqual(t.field)}class $l{}class Ol extends $l{constructor(e,t,n){super(),this.field=e,this.op=t,this.value=n}static create(e,t,n){return e.isKeyField()?"in"===t||"not-in"===t?this.createKeyFieldInFilter(e,t,n):new Ul(e,t,n):"array-contains"===t?new Gl(e,n):"in"===t?new Hl(e,n):"not-in"===t?new ql(e,n):"array-contains-any"===t?new Kl(e,n):new Ol(e,t,n)}static createKeyFieldInFilter(e,t,n){return"in"===t?new Vl(e,n):new Wl(e,n)}matches(e){const t=e.data.field(this.field);return"!="===this.op?null!==t&&this.matchesComparison(ul(t,this.value)):null!==t&&il(this.value)===il(t)&&this.matchesComparison(ul(t,this.value))}matchesComparison(e){switch(this.op){case"<":return e<0;case"<=":return e<=0;case"==":return 0===e;case"!=":return 0!==e;case">":return e>0;case">=":return e>=0;default:return Gi()}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class Dl extends $l{constructor(e,t){super(),this.filters=e,this.op=t,this.ae=null}static create(e,t){return new Dl(e,t)}matches(e){return Fl(this)?void 0===this.filters.find((t=>!t.matches(e))):void 0!==this.filters.find((t=>t.matches(e)))}getFlattenedFilters(){return null!==this.ae||(this.ae=this.filters.reduce(((e,t)=>e.concat(t.getFlattenedFilters())),[])),this.ae}getFilters(){return Object.assign([],this.filters)}}function Fl(e){return"and"===e.op}function Ll(e){return Ml(e)&&Fl(e)}function Ml(e){for(const t of e.filters)if(t instanceof Dl)return!1;return!0}function Pl(e){if(e instanceof Ol)return e.field.canonicalString()+e.op.toString()+dl(e.value);if(Ll(e))return e.filters.map((e=>Pl(e))).join(",");{const t=e.filters.map((e=>Pl(e))).join(",");return`${e.op}(${t})`}}function zl(e,t){return e instanceof Ol?function(e,t){return t instanceof Ol&&e.op===t.op&&e.field.isEqual(t.field)&&ol(e.value,t.value)}(e,t):e instanceof Dl?function(e,t){return t instanceof Dl&&e.op===t.op&&e.filters.length===t.filters.length&&e.filters.reduce(((e,n,r)=>e&&zl(n,t.filters[r])),!0)}(e,t):void Gi()}function Bl(e){return e instanceof Ol?function(e){return`${e.field.canonicalString()} ${e.op} ${dl(e.value)}`}(e):e instanceof Dl?function(e){return e.op.toString()+" {"+e.getFilters().map(Bl).join(" ,")+"}"}(e):"Filter"}class Ul extends Ol{constructor(e,t,n){super(e,t,n),this.key=go.fromName(n.referenceValue)}matches(e){const t=go.comparator(e.key,this.key);return this.matchesComparison(t)}}class Vl extends Ol{constructor(e,t){super(e,"in",t),this.keys=jl("in",t)}matches(e){return this.keys.some((t=>t.isEqual(e.key)))}}class Wl extends Ol{constructor(e,t){super(e,"not-in",t),this.keys=jl("not-in",t)}matches(e){return!this.keys.some((t=>t.isEqual(e.key)))}}function jl(e,t){var n;return((null===(n=t.arrayValue)||void 0===n?void 0:n.values)||[]).map((e=>go.fromName(e.referenceValue)))}class Gl extends Ol{constructor(e,t){super(e,"array-contains",t)}matches(e){const t=e.data.field(this.field);return yl(t)&&ll(t.arrayValue,this.value)}}class Hl extends Ol{constructor(e,t){super(e,"in",t)}matches(e){const t=e.data.field(this.field);return null!==t&&ll(this.value.arrayValue,t)}}class ql extends Ol{constructor(e,t){super(e,"not-in",t)}matches(e){if(ll(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const t=e.data.field(this.field);return null!==t&&!ll(this.value.arrayValue,t)}}class Kl extends Ol{constructor(e,t){super(e,"array-contains-any",t)}matches(e){const t=e.data.field(this.field);return!(!yl(t)||!t.arrayValue.values)&&t.arrayValue.values.some((e=>ll(this.value.arrayValue,e)))}}class Xl{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;this.path=e,this.collectionGroup=t,this.orderBy=n,this.filters=r,this.limit=s,this.startAt=a,this.endAt=i,this.ue=null}}function Yl(e){return new Xl(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,arguments.length>6&&void 0!==arguments[6]?arguments[6]:null)}function Ql(e){const t=qi(e);if(null===t.ue){let e=t.path.canonicalString();null!==t.collectionGroup&&(e+="|cg:"+t.collectionGroup),e+="|f:",e+=t.filters.map((e=>Pl(e))).join(","),e+="|ob:",e+=t.orderBy.map((e=>function(e){return e.field.canonicalString()+e.dir}(e))).join(","),_o(t.limit)||(e+="|l:",e+=t.limit),t.startAt&&(e+="|lb:",e+=t.startAt.inclusive?"b:":"a:",e+=t.startAt.position.map((e=>dl(e))).join(",")),t.endAt&&(e+="|ub:",e+=t.endAt.inclusive?"a:":"b:",e+=t.endAt.position.map((e=>dl(e))).join(",")),t.ue=e}return t.ue}function Jl(e,t){if(e.limit!==t.limit)return!1;if(e.orderBy.length!==t.orderBy.length)return!1;for(let n=0;n<e.orderBy.length;n++)if(!Rl(e.orderBy[n],t.orderBy[n]))return!1;if(e.filters.length!==t.filters.length)return!1;for(let n=0;n<e.filters.length;n++)if(!zl(e.filters[n],t.filters[n]))return!1;return e.collectionGroup===t.collectionGroup&&!!e.path.isEqual(t.path)&&!!_l(e.startAt,t.startAt)&&_l(e.endAt,t.endAt)}function Zl(e){return go.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}class eu{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"F",i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.path=e,this.collectionGroup=t,this.explicitOrderBy=n,this.filters=r,this.limit=s,this.limitType=a,this.startAt=i,this.endAt=o,this.ce=null,this.le=null,this.he=null,this.startAt,this.endAt}}function tu(e,t,n,r,s,a,i,o){return new eu(e,t,n,r,s,a,i,o)}function nu(e){return new eu(e)}function ru(e){return 0===e.filters.length&&null===e.limit&&null==e.startAt&&null==e.endAt&&(0===e.explicitOrderBy.length||1===e.explicitOrderBy.length&&e.explicitOrderBy[0].field.isKeyField())}function su(e){return null!==e.collectionGroup}function au(e){const t=qi(e);if(null===t.ce){t.ce=[];const e=new Set;for(const s of t.explicitOrderBy)t.ce.push(s),e.add(s.field.canonicalString());const n=t.explicitOrderBy.length>0?t.explicitOrderBy[t.explicitOrderBy.length-1].dir:"asc",r=function(e){let t=new Go(mo.comparator);return e.filters.forEach((e=>{e.getFlattenedFilters().forEach((e=>{e.isInequality()&&(t=t.add(e.field))}))})),t}(t);r.forEach((r=>{e.has(r.canonicalString())||r.isKeyField()||t.ce.push(new Al(r,n))})),e.has(mo.keyField().canonicalString())||t.ce.push(new Al(mo.keyField(),n))}return t.ce}function iu(e){const t=qi(e);return t.le||(t.le=ou(t,au(e))),t.le}function ou(e,t){if("F"===e.limitType)return Yl(e.path,e.collectionGroup,t,e.filters,e.limit,e.startAt,e.endAt);{t=t.map((e=>{const t="desc"===e.dir?"asc":"desc";return new Al(e.field,t)}));const n=e.endAt?new El(e.endAt.position,e.endAt.inclusive):null,r=e.startAt?new El(e.startAt.position,e.startAt.inclusive):null;return Yl(e.path,e.collectionGroup,t,e.filters,e.limit,n,r)}}function lu(e,t){const n=e.filters.concat([t]);return new eu(e.path,e.collectionGroup,e.explicitOrderBy.slice(),n,e.limit,e.limitType,e.startAt,e.endAt)}function uu(e,t,n){return new eu(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,n,e.startAt,e.endAt)}function cu(e,t){return Jl(iu(e),iu(t))&&e.limitType===t.limitType}function hu(e){return`${Ql(iu(e))}|lt:${e.limitType}`}function du(e){return`Query(target=${function(e){let t=e.path.canonicalString();return null!==e.collectionGroup&&(t+=" collectionGroup="+e.collectionGroup),e.filters.length>0&&(t+=`, filters: [${e.filters.map((e=>Bl(e))).join(", ")}]`),_o(e.limit)||(t+=", limit: "+e.limit),e.orderBy.length>0&&(t+=`, orderBy: [${e.orderBy.map((e=>function(e){return`${e.field.canonicalString()} (${e.dir})`}(e))).join(", ")}]`),e.startAt&&(t+=", startAt: ",t+=e.startAt.inclusive?"b:":"a:",t+=e.startAt.position.map((e=>dl(e))).join(",")),e.endAt&&(t+=", endAt: ",t+=e.endAt.inclusive?"a:":"b:",t+=e.endAt.position.map((e=>dl(e))).join(",")),`Target(${t})`}(iu(e))}; limitType=${e.limitType})`}function pu(e,t){return t.isFoundDocument()&&function(e,t){const n=t.key.path;return null!==e.collectionGroup?t.key.hasCollectionId(e.collectionGroup)&&e.path.isPrefixOf(n):go.isDocumentKey(e.path)?e.path.isEqual(n):e.path.isImmediateParentOf(n)}(e,t)&&function(e,t){for(const n of au(e))if(!n.field.isKeyField()&&null===t.data.field(n.field))return!1;return!0}(e,t)&&function(e,t){for(const n of e.filters)if(!n.matches(t))return!1;return!0}(e,t)&&function(e,t){return!(e.startAt&&!function(e,t,n){const r=Cl(e,t,n);return e.inclusive?r<=0:r<0}(e.startAt,au(e),t))&&!(e.endAt&&!function(e,t,n){const r=Cl(e,t,n);return e.inclusive?r>=0:r>0}(e.endAt,au(e),t))}(e,t)}function fu(e){return e.collectionGroup||(e.path.length%2==1?e.path.lastSegment():e.path.get(e.path.length-2))}function mu(e){return(t,n)=>{let r=!1;for(const s of au(e)){const e=gu(s,t,n);if(0!==e)return e;r=r||s.field.isKeyField()}return 0}}function gu(e,t,n){const r=e.field.isKeyField()?go.comparator(t.key,n.key):function(e,t,n){const r=t.data.field(e),s=n.data.field(e);return null!==r&&null!==s?ul(r,s):Gi()}(e.field,t,n);switch(e.dir){case"asc":return r;case"desc":return-1*r;default:return Gi()}}class yu{constructor(e,t){this.mapKeyFn=e,this.equalsFn=t,this.inner={},this.innerSize=0}get(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0!==n)for(const[r,s]of n)if(this.equalsFn(r,e))return s}has(e){return void 0!==this.get(e)}set(e,t){const n=this.mapKeyFn(e),r=this.inner[n];if(void 0===r)return this.inner[n]=[[e,t]],void this.innerSize++;for(let s=0;s<r.length;s++)if(this.equalsFn(r[s][0],e))return void(r[s]=[e,t]);r.push([e,t]),this.innerSize++}delete(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0===n)return!1;for(let r=0;r<n.length;r++)if(this.equalsFn(n[r][0],e))return 1===n.length?delete this.inner[t]:n.splice(r,1),this.innerSize--,!0;return!1}forEach(e){Bo(this.inner,((t,n)=>{for(const[r,s]of n)e(r,s)}))}isEmpty(){return Uo(this.inner)}size(){return this.innerSize}}const bu=new Vo(go.comparator);function vu(){return bu}const wu=new Vo(go.comparator);function xu(){let e=wu;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const s of n)e=e.insert(s.key,s);return e}function ku(e){let t=wu;return e.forEach(((e,n)=>t=t.insert(e,n.overlayedDocument))),t}function Su(){return Tu()}function Iu(){return Tu()}function Tu(){return new yu((e=>e.toString()),((e,t)=>e.isEqual(t)))}const Nu=new Vo(go.comparator),Eu=new Go(go.comparator);function Cu(){let e=Eu;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const s of n)e=e.add(s);return e}const _u=new Go(oo);function Au(){return _u}function Ru(e,t){if(e.useProto3Json){if(isNaN(t))return{doubleValue:"NaN"};if(t===1/0)return{doubleValue:"Infinity"};if(t===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:Ao(t)?"-0":t}}function $u(e){return{integerValue:""+e}}function Ou(e,t){return Ro(t)?$u(t):Ru(e,t)}class Du{constructor(){this._=void 0}}function Fu(e,t,n){return e instanceof Pu?function(e,t){const n={fields:{__type__:{stringValue:"server_timestamp"},__local_write_time__:{timestampValue:{seconds:e.seconds,nanos:e.nanoseconds}}}};return t&&el(t)&&(t=tl(t)),t&&(n.fields.__previous_value__=t),{mapValue:n}}(n,t):e instanceof zu?Bu(e,t):e instanceof Uu?Vu(e,t):function(e,t){const n=Mu(e,t),r=ju(n)+ju(e.Pe);return gl(n)&&gl(e.Pe)?$u(r):Ru(e.serializer,r)}(e,t)}function Lu(e,t,n){return e instanceof zu?Bu(e,t):e instanceof Uu?Vu(e,t):n}function Mu(e,t){return e instanceof Wu?function(e){return gl(e)||function(e){return!!e&&"doubleValue"in e}(e)}(t)?t:{integerValue:0}:null}class Pu extends Du{}class zu extends Du{constructor(e){super(),this.elements=e}}function Bu(e,t){const n=Gu(t);for(const r of e.elements)n.some((e=>ol(e,r)))||n.push(r);return{arrayValue:{values:n}}}class Uu extends Du{constructor(e){super(),this.elements=e}}function Vu(e,t){let n=Gu(t);for(const r of e.elements)n=n.filter((e=>!ol(e,r)));return{arrayValue:{values:n}}}class Wu extends Du{constructor(e,t){super(),this.serializer=e,this.Pe=t}}function ju(e){return Jo(e.integerValue||e.doubleValue)}function Gu(e){return yl(e)&&e.arrayValue.values?e.arrayValue.values.slice():[]}class Hu{constructor(e,t){this.field=e,this.transform=t}}class qu{constructor(e,t){this.version=e,this.transformResults=t}}class Ku{constructor(e,t){this.updateTime=e,this.exists=t}static none(){return new Ku}static exists(e){return new Ku(void 0,e)}static updateTime(e){return new Ku(e)}get isNone(){return void 0===this.updateTime&&void 0===this.exists}isEqual(e){return this.exists===e.exists&&(this.updateTime?!!e.updateTime&&this.updateTime.isEqual(e.updateTime):!e.updateTime)}}function Xu(e,t){return void 0!==e.updateTime?t.isFoundDocument()&&t.version.isEqual(e.updateTime):void 0===e.exists||e.exists===t.isFoundDocument()}class Yu{}function Qu(e,t){if(!e.hasLocalMutations||t&&0===t.fields.length)return null;if(null===t)return e.isNoDocument()?new oc(e.key,Ku.none()):new nc(e.key,e.data,Ku.none());{const n=e.data,r=Il.empty();let s=new Go(mo.comparator);for(let e of t.fields)if(!s.has(e)){let t=n.field(e);null===t&&e.length>1&&(e=e.popLast(),t=n.field(e)),null===t?r.delete(e):r.set(e,t),s=s.add(e)}return new rc(e.key,r,new qo(s.toArray()),Ku.none())}}function Ju(e,t,n){e instanceof nc?function(e,t,n){const r=e.value.clone(),s=ac(e.fieldTransforms,t,n.transformResults);r.setAll(s),t.convertToFoundDocument(n.version,r).setHasCommittedMutations()}(e,t,n):e instanceof rc?function(e,t,n){if(!Xu(e.precondition,t))return void t.convertToUnknownDocument(n.version);const r=ac(e.fieldTransforms,t,n.transformResults),s=t.data;s.setAll(sc(e)),s.setAll(r),t.convertToFoundDocument(n.version,s).setHasCommittedMutations()}(e,t,n):function(e,t,n){t.convertToNoDocument(n.version).setHasCommittedMutations()}(0,t,n)}function Zu(e,t,n,r){return e instanceof nc?function(e,t,n,r){if(!Xu(e.precondition,t))return n;const s=e.value.clone(),a=ic(e.fieldTransforms,r,t);return s.setAll(a),t.convertToFoundDocument(t.version,s).setHasLocalMutations(),null}(e,t,n,r):e instanceof rc?function(e,t,n,r){if(!Xu(e.precondition,t))return n;const s=ic(e.fieldTransforms,r,t),a=t.data;return a.setAll(sc(e)),a.setAll(s),t.convertToFoundDocument(t.version,a).setHasLocalMutations(),null===n?null:n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map((e=>e.field)))}(e,t,n,r):function(e,t,n){return Xu(e.precondition,t)?(t.convertToNoDocument(t.version).setHasLocalMutations(),null):n}(e,t,n)}function ec(e,t){let n=null;for(const r of e.fieldTransforms){const e=t.data.field(r.field),s=Mu(r.transform,e||null);null!=s&&(null===n&&(n=Il.empty()),n.set(r.field,s))}return n||null}function tc(e,t){return e.type===t.type&&!!e.key.isEqual(t.key)&&!!e.precondition.isEqual(t.precondition)&&!!function(e,t){return void 0===e&&void 0===t||!(!e||!t)&&lo(e,t,((e,t)=>function(e,t){return e.field.isEqual(t.field)&&function(e,t){return e instanceof zu&&t instanceof zu||e instanceof Uu&&t instanceof Uu?lo(e.elements,t.elements,ol):e instanceof Wu&&t instanceof Wu?ol(e.Pe,t.Pe):e instanceof Pu&&t instanceof Pu}(e.transform,t.transform)}(e,t)))}(e.fieldTransforms,t.fieldTransforms)&&(0===e.type?e.value.isEqual(t.value):1!==e.type||e.data.isEqual(t.data)&&e.fieldMask.isEqual(t.fieldMask))}class nc extends Yu{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];super(),this.key=e,this.value=t,this.precondition=n,this.fieldTransforms=r,this.type=0}getFieldMask(){return null}}class rc extends Yu{constructor(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];super(),this.key=e,this.data=t,this.fieldMask=n,this.precondition=r,this.fieldTransforms=s,this.type=1}getFieldMask(){return this.fieldMask}}function sc(e){const t=new Map;return e.fieldMask.fields.forEach((n=>{if(!n.isEmpty()){const r=e.data.field(n);t.set(n,r)}})),t}function ac(e,t,n){const r=new Map;Hi(e.length===n.length);for(let s=0;s<n.length;s++){const a=e[s],i=a.transform,o=t.data.field(a.field);r.set(a.field,Lu(i,o,n[s]))}return r}function ic(e,t,n){const r=new Map;for(const s of e){const e=s.transform,a=n.data.field(s.field);r.set(s.field,Fu(e,a,t))}return r}class oc extends Yu{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class lc extends Yu{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}class uc{constructor(e,t,n,r){this.batchId=e,this.localWriteTime=t,this.baseMutations=n,this.mutations=r}applyToRemoteDocument(e,t){const n=t.mutationResults;for(let r=0;r<this.mutations.length;r++){const t=this.mutations[r];t.key.isEqual(e.key)&&Ju(t,e,n[r])}}applyToLocalView(e,t){for(const n of this.baseMutations)n.key.isEqual(e.key)&&(t=Zu(n,e,t,this.localWriteTime));for(const n of this.mutations)n.key.isEqual(e.key)&&(t=Zu(n,e,t,this.localWriteTime));return t}applyToLocalDocumentSet(e,t){const n=Iu();return this.mutations.forEach((r=>{const s=e.get(r.key),a=s.overlayedDocument;let i=this.applyToLocalView(a,s.mutatedFields);i=t.has(r.key)?null:i;const o=Qu(a,i);null!==o&&n.set(r.key,o),a.isValidDocument()||a.convertToNoDocument(co.min())})),n}keys(){return this.mutations.reduce(((e,t)=>e.add(t.key)),Cu())}isEqual(e){return this.batchId===e.batchId&&lo(this.mutations,e.mutations,((e,t)=>tc(e,t)))&&lo(this.baseMutations,e.baseMutations,((e,t)=>tc(e,t)))}}class cc{constructor(e,t,n,r){this.batch=e,this.commitVersion=t,this.mutationResults=n,this.docVersions=r}static from(e,t,n){Hi(e.mutations.length===n.length);let r=Nu;const s=e.mutations;for(let a=0;a<s.length;a++)r=r.insert(s[a].key,n[a].version);return new cc(e,t,n,r)}}class hc{constructor(e,t){this.largestBatchId=e,this.mutation=t}getKey(){return this.mutation.key}isEqual(e){return null!==e&&this.mutation===e.mutation}toString(){return`Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`}}class dc{constructor(e,t){this.count=e,this.unchangedNames=t}}var pc,fc;function mc(e){switch(e){default:return Gi();case Ki.CANCELLED:case Ki.UNKNOWN:case Ki.DEADLINE_EXCEEDED:case Ki.RESOURCE_EXHAUSTED:case Ki.INTERNAL:case Ki.UNAVAILABLE:case Ki.UNAUTHENTICATED:return!1;case Ki.INVALID_ARGUMENT:case Ki.NOT_FOUND:case Ki.ALREADY_EXISTS:case Ki.PERMISSION_DENIED:case Ki.FAILED_PRECONDITION:case Ki.ABORTED:case Ki.OUT_OF_RANGE:case Ki.UNIMPLEMENTED:case Ki.DATA_LOSS:return!0}}function gc(e){if(void 0===e)return Vi("GRPC error has no .code"),Ki.UNKNOWN;switch(e){case pc.OK:return Ki.OK;case pc.CANCELLED:return Ki.CANCELLED;case pc.UNKNOWN:return Ki.UNKNOWN;case pc.DEADLINE_EXCEEDED:return Ki.DEADLINE_EXCEEDED;case pc.RESOURCE_EXHAUSTED:return Ki.RESOURCE_EXHAUSTED;case pc.INTERNAL:return Ki.INTERNAL;case pc.UNAVAILABLE:return Ki.UNAVAILABLE;case pc.UNAUTHENTICATED:return Ki.UNAUTHENTICATED;case pc.INVALID_ARGUMENT:return Ki.INVALID_ARGUMENT;case pc.NOT_FOUND:return Ki.NOT_FOUND;case pc.ALREADY_EXISTS:return Ki.ALREADY_EXISTS;case pc.PERMISSION_DENIED:return Ki.PERMISSION_DENIED;case pc.FAILED_PRECONDITION:return Ki.FAILED_PRECONDITION;case pc.ABORTED:return Ki.ABORTED;case pc.OUT_OF_RANGE:return Ki.OUT_OF_RANGE;case pc.UNIMPLEMENTED:return Ki.UNIMPLEMENTED;case pc.DATA_LOSS:return Ki.DATA_LOSS;default:return Gi()}}(fc=pc||(pc={}))[fc.OK=0]="OK",fc[fc.CANCELLED=1]="CANCELLED",fc[fc.UNKNOWN=2]="UNKNOWN",fc[fc.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",fc[fc.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",fc[fc.NOT_FOUND=5]="NOT_FOUND",fc[fc.ALREADY_EXISTS=6]="ALREADY_EXISTS",fc[fc.PERMISSION_DENIED=7]="PERMISSION_DENIED",fc[fc.UNAUTHENTICATED=16]="UNAUTHENTICATED",fc[fc.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",fc[fc.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",fc[fc.ABORTED=10]="ABORTED",fc[fc.OUT_OF_RANGE=11]="OUT_OF_RANGE",fc[fc.UNIMPLEMENTED=12]="UNIMPLEMENTED",fc[fc.INTERNAL=13]="INTERNAL",fc[fc.UNAVAILABLE=14]="UNAVAILABLE",fc[fc.DATA_LOSS=15]="DATA_LOSS";let yc=null;function bc(){return new TextEncoder}const vc=new ki([4294967295,4294967295],0);function wc(e){const t=bc().encode(e),n=new Si;return n.update(t),new Uint8Array(n.digest())}function xc(e){const t=new DataView(e.buffer),n=t.getUint32(0,!0),r=t.getUint32(4,!0),s=t.getUint32(8,!0),a=t.getUint32(12,!0);return[new ki([n,r],0),new ki([s,a],0)]}class kc{constructor(e,t,n){if(this.bitmap=e,this.padding=t,this.hashCount=n,t<0||t>=8)throw new Sc(`Invalid padding: ${t}`);if(n<0)throw new Sc(`Invalid hash count: ${n}`);if(e.length>0&&0===this.hashCount)throw new Sc(`Invalid hash count: ${n}`);if(0===e.length&&0!==t)throw new Sc(`Invalid padding when bitmap length is 0: ${t}`);this.Ie=8*e.length-t,this.Te=ki.fromNumber(this.Ie)}Ee(e,t,n){let r=e.add(t.multiply(ki.fromNumber(n)));return 1===r.compare(vc)&&(r=new ki([r.getBits(0),r.getBits(1)],0)),r.modulo(this.Te).toNumber()}de(e){return 0!=(this.bitmap[Math.floor(e/8)]&1<<e%8)}mightContain(e){if(0===this.Ie)return!1;const t=wc(e),[n,r]=xc(t);for(let s=0;s<this.hashCount;s++){const e=this.Ee(n,r,s);if(!this.de(e))return!1}return!0}static create(e,t,n){const r=e%8==0?0:8-e%8,s=new Uint8Array(Math.ceil(e/8)),a=new kc(s,r,t);return n.forEach((e=>a.insert(e))),a}insert(e){if(0===this.Ie)return;const t=wc(e),[n,r]=xc(t);for(let s=0;s<this.hashCount;s++){const e=this.Ee(n,r,s);this.Ae(e)}}Ae(e){const t=Math.floor(e/8),n=e%8;this.bitmap[t]|=1<<n}}class Sc extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}class Ic{constructor(e,t,n,r,s){this.snapshotVersion=e,this.targetChanges=t,this.targetMismatches=n,this.documentUpdates=r,this.resolvedLimboDocuments=s}static createSynthesizedRemoteEventForCurrentChange(e,t,n){const r=new Map;return r.set(e,Tc.createSynthesizedTargetChangeForCurrentChange(e,t,n)),new Ic(co.min(),r,new Vo(oo),vu(),Cu())}}class Tc{constructor(e,t,n,r,s){this.resumeToken=e,this.current=t,this.addedDocuments=n,this.modifiedDocuments=r,this.removedDocuments=s}static createSynthesizedTargetChangeForCurrentChange(e,t,n){return new Tc(n,t,Cu(),Cu(),Cu())}}class Nc{constructor(e,t,n,r){this.Re=e,this.removedTargetIds=t,this.key=n,this.Ve=r}}class Ec{constructor(e,t){this.targetId=e,this.me=t}}class Cc{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Xo.EMPTY_BYTE_STRING,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.state=e,this.targetIds=t,this.resumeToken=n,this.cause=r}}class _c{constructor(){this.fe=0,this.ge=$c(),this.pe=Xo.EMPTY_BYTE_STRING,this.ye=!1,this.we=!0}get current(){return this.ye}get resumeToken(){return this.pe}get Se(){return 0!==this.fe}get be(){return this.we}De(e){e.approximateByteSize()>0&&(this.we=!0,this.pe=e)}ve(){let e=Cu(),t=Cu(),n=Cu();return this.ge.forEach(((r,s)=>{switch(s){case 0:e=e.add(r);break;case 2:t=t.add(r);break;case 1:n=n.add(r);break;default:Gi()}})),new Tc(this.pe,this.ye,e,t,n)}Ce(){this.we=!1,this.ge=$c()}Fe(e,t){this.we=!0,this.ge=this.ge.insert(e,t)}Me(e){this.we=!0,this.ge=this.ge.remove(e)}xe(){this.fe+=1}Oe(){this.fe-=1,Hi(this.fe>=0)}Ne(){this.we=!0,this.ye=!0}}class Ac{constructor(e){this.Le=e,this.Be=new Map,this.ke=vu(),this.qe=Rc(),this.Qe=new Vo(oo)}Ke(e){for(const t of e.Re)e.Ve&&e.Ve.isFoundDocument()?this.$e(t,e.Ve):this.Ue(t,e.key,e.Ve);for(const t of e.removedTargetIds)this.Ue(t,e.key,e.Ve)}We(e){this.forEachTarget(e,(t=>{const n=this.Ge(t);switch(e.state){case 0:this.ze(t)&&n.De(e.resumeToken);break;case 1:n.Oe(),n.Se||n.Ce(),n.De(e.resumeToken);break;case 2:n.Oe(),n.Se||this.removeTarget(t);break;case 3:this.ze(t)&&(n.Ne(),n.De(e.resumeToken));break;case 4:this.ze(t)&&(this.je(t),n.De(e.resumeToken));break;default:Gi()}}))}forEachTarget(e,t){e.targetIds.length>0?e.targetIds.forEach(t):this.Be.forEach(((e,n)=>{this.ze(n)&&t(n)}))}He(e){const t=e.targetId,n=e.me.count,r=this.Je(t);if(r){const s=r.target;if(Zl(s))if(0===n){const e=new go(s.path);this.Ue(t,e,Nl.newNoDocument(e,co.min()))}else Hi(1===n);else{const r=this.Ye(t);if(r!==n){const n=this.Ze(e),s=n?this.Xe(n,e,r):1;if(0!==s){this.je(t);const e=2===s?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Qe=this.Qe.insert(t,e)}null==yc||yc.et(function(e,t,n,r,s){var a,i,o,l,u,c;const h={localCacheCount:e,existenceFilterCount:t.count,databaseId:n.database,projectId:n.projectId},d=t.unchangedNames;return d&&(h.bloomFilter={applied:0===s,hashCount:null!==(a=null==d?void 0:d.hashCount)&&void 0!==a?a:0,bitmapLength:null!==(l=null===(o=null===(i=null==d?void 0:d.bits)||void 0===i?void 0:i.bitmap)||void 0===o?void 0:o.length)&&void 0!==l?l:0,padding:null!==(c=null===(u=null==d?void 0:d.bits)||void 0===u?void 0:u.padding)&&void 0!==c?c:0,mightContain:e=>{var t;return null!==(t=null==r?void 0:r.mightContain(e))&&void 0!==t&&t}}),h}(r,e.me,this.Le.tt(),n,s))}}}}Ze(e){const t=e.me.unchangedNames;if(!t||!t.bits)return null;const{bits:{bitmap:n="",padding:r=0},hashCount:s=0}=t;let a,i;try{a=Zo(n).toUint8Array()}catch(e){if(e instanceof Ko)return Wi("Decoding the base64 bloom filter in existence filter failed ("+e.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw e}try{i=new kc(a,r,s)}catch(e){return Wi(e instanceof Sc?"BloomFilter error: ":"Applying bloom filter failed: ",e),null}return 0===i.Ie?null:i}Xe(e,t,n){return t.me.count===n-this.nt(e,t.targetId)?0:2}nt(e,t){const n=this.Le.getRemoteKeysForTarget(t);let r=0;return n.forEach((n=>{const s=this.Le.tt(),a=`projects/${s.projectId}/databases/${s.database}/documents/${n.path.canonicalString()}`;e.mightContain(a)||(this.Ue(t,n,null),r++)})),r}rt(e){const t=new Map;this.Be.forEach(((n,r)=>{const s=this.Je(r);if(s){if(n.current&&Zl(s.target)){const t=new go(s.target.path);null!==this.ke.get(t)||this.it(r,t)||this.Ue(r,t,Nl.newNoDocument(t,e))}n.be&&(t.set(r,n.ve()),n.Ce())}}));let n=Cu();this.qe.forEach(((e,t)=>{let r=!0;t.forEachWhile((e=>{const t=this.Je(e);return!t||"TargetPurposeLimboResolution"===t.purpose||(r=!1,!1)})),r&&(n=n.add(e))})),this.ke.forEach(((t,n)=>n.setReadTime(e)));const r=new Ic(e,t,this.Qe,this.ke,n);return this.ke=vu(),this.qe=Rc(),this.Qe=new Vo(oo),r}$e(e,t){if(!this.ze(e))return;const n=this.it(e,t.key)?2:0;this.Ge(e).Fe(t.key,n),this.ke=this.ke.insert(t.key,t),this.qe=this.qe.insert(t.key,this.st(t.key).add(e))}Ue(e,t,n){if(!this.ze(e))return;const r=this.Ge(e);this.it(e,t)?r.Fe(t,1):r.Me(t),this.qe=this.qe.insert(t,this.st(t).delete(e)),n&&(this.ke=this.ke.insert(t,n))}removeTarget(e){this.Be.delete(e)}Ye(e){const t=this.Ge(e).ve();return this.Le.getRemoteKeysForTarget(e).size+t.addedDocuments.size-t.removedDocuments.size}xe(e){this.Ge(e).xe()}Ge(e){let t=this.Be.get(e);return t||(t=new _c,this.Be.set(e,t)),t}st(e){let t=this.qe.get(e);return t||(t=new Go(oo),this.qe=this.qe.insert(e,t)),t}ze(e){const t=null!==this.Je(e);return t||Ui("WatchChangeAggregator","Detected inactive target",e),t}Je(e){const t=this.Be.get(e);return t&&t.Se?null:this.Le.ot(e)}je(e){this.Be.set(e,new _c),this.Le.getRemoteKeysForTarget(e).forEach((t=>{this.Ue(e,t,null)}))}it(e,t){return this.Le.getRemoteKeysForTarget(e).has(t)}}function Rc(){return new Vo(go.comparator)}function $c(){return new Vo(go.comparator)}const Oc={asc:"ASCENDING",desc:"DESCENDING"},Dc={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},Fc={and:"AND",or:"OR"};class Lc{constructor(e,t){this.databaseId=e,this.useProto3Json=t}}function Mc(e,t){return e.useProto3Json||_o(t)?t:{value:t}}function Pc(e,t){return e.useProto3Json?`${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z`:{seconds:""+t.seconds,nanos:t.nanoseconds}}function zc(e,t){return e.useProto3Json?t.toBase64():t.toUint8Array()}function Bc(e,t){return Pc(e,t.toTimestamp())}function Uc(e){return Hi(!!e),co.fromTimestamp(function(e){const t=Qo(e);return new uo(t.seconds,t.nanos)}(e))}function Vc(e,t){return Wc(e,t).canonicalString()}function Wc(e,t){const n=function(e){return new po(["projects",e.projectId,"databases",e.database])}(e).child("documents");return void 0===t?n:n.child(t)}function jc(e){const t=po.fromString(e);return Hi(ch(t)),t}function Gc(e,t){return Vc(e.databaseId,t.path)}function Hc(e,t){const n=jc(t);if(n.get(1)!==e.databaseId.projectId)throw new Xi(Ki.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+n.get(1)+" vs "+e.databaseId.projectId);if(n.get(3)!==e.databaseId.database)throw new Xi(Ki.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+n.get(3)+" vs "+e.databaseId.database);return new go(Yc(n))}function qc(e,t){return Vc(e.databaseId,t)}function Kc(e){const t=jc(e);return 4===t.length?po.emptyPath():Yc(t)}function Xc(e){return new po(["projects",e.databaseId.projectId,"databases",e.databaseId.database]).canonicalString()}function Yc(e){return Hi(e.length>4&&"documents"===e.get(4)),e.popFirst(5)}function Qc(e,t,n){return{name:Gc(e,t),fields:n.value.mapValue.fields}}function Jc(e,t){let n;if(t instanceof nc)n={update:Qc(e,t.key,t.value)};else if(t instanceof oc)n={delete:Gc(e,t.key)};else if(t instanceof rc)n={update:Qc(e,t.key,t.data),updateMask:uh(t.fieldMask)};else{if(!(t instanceof lc))return Gi();n={verify:Gc(e,t.key)}}return t.fieldTransforms.length>0&&(n.updateTransforms=t.fieldTransforms.map((e=>function(e,t){const n=t.transform;if(n instanceof Pu)return{fieldPath:t.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(n instanceof zu)return{fieldPath:t.field.canonicalString(),appendMissingElements:{values:n.elements}};if(n instanceof Uu)return{fieldPath:t.field.canonicalString(),removeAllFromArray:{values:n.elements}};if(n instanceof Wu)return{fieldPath:t.field.canonicalString(),increment:n.Pe};throw Gi()}(0,e)))),t.precondition.isNone||(n.currentDocument=function(e,t){return void 0!==t.updateTime?{updateTime:Bc(e,t.updateTime)}:void 0!==t.exists?{exists:t.exists}:Gi()}(e,t.precondition)),n}function Zc(e,t){return{documents:[qc(e,t.path)]}}function eh(e,t){const n={structuredQuery:{}},r=t.path;let s;null!==t.collectionGroup?(s=r,n.structuredQuery.from=[{collectionId:t.collectionGroup,allDescendants:!0}]):(s=r.popLast(),n.structuredQuery.from=[{collectionId:r.lastSegment()}]),n.parent=qc(e,s);const a=function(e){if(0!==e.length)return lh(Dl.create(e,"and"))}(t.filters);a&&(n.structuredQuery.where=a);const i=function(e){if(0!==e.length)return e.map((e=>function(e){return{field:ih(e.field),direction:rh(e.dir)}}(e)))}(t.orderBy);i&&(n.structuredQuery.orderBy=i);const o=Mc(e,t.limit);return null!==o&&(n.structuredQuery.limit=o),t.startAt&&(n.structuredQuery.startAt=function(e){return{before:e.inclusive,values:e.position}}(t.startAt)),t.endAt&&(n.structuredQuery.endAt=function(e){return{before:!e.inclusive,values:e.position}}(t.endAt)),{_t:n,parent:s}}function th(e){let t=Kc(e.parent);const n=e.structuredQuery,r=n.from?n.from.length:0;let s=null;if(r>0){Hi(1===r);const e=n.from[0];e.allDescendants?s=e.collectionId:t=t.child(e.collectionId)}let a=[];n.where&&(a=function(e){const t=nh(e);return t instanceof Dl&&Ll(t)?t.getFilters():[t]}(n.where));let i=[];n.orderBy&&(i=function(e){return e.map((e=>function(e){return new Al(oh(e.field),function(e){switch(e){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}}(e.direction))}(e)))}(n.orderBy));let o=null;n.limit&&(o=function(e){let t;return t="object"==typeof e?e.value:e,_o(t)?null:t}(n.limit));let l=null;n.startAt&&(l=function(e){const t=!!e.before,n=e.values||[];return new El(n,t)}(n.startAt));let u=null;return n.endAt&&(u=function(e){const t=!e.before,n=e.values||[];return new El(n,t)}(n.endAt)),tu(t,s,i,a,o,"F",l,u)}function nh(e){return void 0!==e.unaryFilter?function(e){switch(e.unaryFilter.op){case"IS_NAN":const t=oh(e.unaryFilter.field);return Ol.create(t,"==",{doubleValue:NaN});case"IS_NULL":const n=oh(e.unaryFilter.field);return Ol.create(n,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const r=oh(e.unaryFilter.field);return Ol.create(r,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const s=oh(e.unaryFilter.field);return Ol.create(s,"!=",{nullValue:"NULL_VALUE"});default:return Gi()}}(e):void 0!==e.fieldFilter?function(e){return Ol.create(oh(e.fieldFilter.field),function(e){switch(e){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";default:return Gi()}}(e.fieldFilter.op),e.fieldFilter.value)}(e):void 0!==e.compositeFilter?function(e){return Dl.create(e.compositeFilter.filters.map((e=>nh(e))),function(e){switch(e){case"AND":return"and";case"OR":return"or";default:return Gi()}}(e.compositeFilter.op))}(e):Gi()}function rh(e){return Oc[e]}function sh(e){return Dc[e]}function ah(e){return Fc[e]}function ih(e){return{fieldPath:e.canonicalString()}}function oh(e){return mo.fromServerFormat(e.fieldPath)}function lh(e){return e instanceof Ol?function(e){if("=="===e.op){if(vl(e.value))return{unaryFilter:{field:ih(e.field),op:"IS_NAN"}};if(bl(e.value))return{unaryFilter:{field:ih(e.field),op:"IS_NULL"}}}else if("!="===e.op){if(vl(e.value))return{unaryFilter:{field:ih(e.field),op:"IS_NOT_NAN"}};if(bl(e.value))return{unaryFilter:{field:ih(e.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:ih(e.field),op:sh(e.op),value:e.value}}}(e):e instanceof Dl?function(e){const t=e.getFilters().map((e=>lh(e)));return 1===t.length?t[0]:{compositeFilter:{op:ah(e.op),filters:t}}}(e):Gi()}function uh(e){const t=[];return e.fields.forEach((e=>t.push(e.canonicalString()))),{fieldPaths:t}}function ch(e){return e.length>=4&&"projects"===e.get(0)&&"databases"===e.get(2)}class hh{constructor(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:co.min(),a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:co.min(),i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Xo.EMPTY_BYTE_STRING,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.target=e,this.targetId=t,this.purpose=n,this.sequenceNumber=r,this.snapshotVersion=s,this.lastLimboFreeSnapshotVersion=a,this.resumeToken=i,this.expectedCount=o}withSequenceNumber(e){return new hh(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(e,t){return new hh(this.target,this.targetId,this.purpose,this.sequenceNumber,t,this.lastLimboFreeSnapshotVersion,e,null)}withExpectedCount(e){return new hh(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)}withLastLimboFreeSnapshotVersion(e){return new hh(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)}}class dh{constructor(e){this.ct=e}}function ph(e){const t=th({parent:e.parent,structuredQuery:e.structuredQuery});return"LAST"===e.limitType?uu(t,t.limit,"L"):t}class fh{constructor(){}It(e,t){this.Tt(e,t),t.Et()}Tt(e,t){if("nullValue"in e)this.dt(t,5);else if("booleanValue"in e)this.dt(t,10),t.At(e.booleanValue?1:0);else if("integerValue"in e)this.dt(t,15),t.At(Jo(e.integerValue));else if("doubleValue"in e){const n=Jo(e.doubleValue);isNaN(n)?this.dt(t,13):(this.dt(t,15),Ao(n)?t.At(0):t.At(n))}else if("timestampValue"in e){let n=e.timestampValue;this.dt(t,20),"string"==typeof n&&(n=Qo(n)),t.Rt(`${n.seconds||""}`),t.At(n.nanos||0)}else if("stringValue"in e)this.Vt(e.stringValue,t),this.ft(t);else if("bytesValue"in e)this.dt(t,30),t.gt(Zo(e.bytesValue)),this.ft(t);else if("referenceValue"in e)this.yt(e.referenceValue,t);else if("geoPointValue"in e){const n=e.geoPointValue;this.dt(t,45),t.At(n.latitude||0),t.At(n.longitude||0)}else"mapValue"in e?Sl(e)?this.dt(t,Number.MAX_SAFE_INTEGER):xl(e)?this.wt(e.mapValue,t):(this.St(e.mapValue,t),this.ft(t)):"arrayValue"in e?(this.bt(e.arrayValue,t),this.ft(t)):Gi()}Vt(e,t){this.dt(t,25),this.Dt(e,t)}Dt(e,t){t.Rt(e)}St(e,t){const n=e.fields||{};this.dt(t,55);for(const r of Object.keys(n))this.Vt(r,t),this.Tt(n[r],t)}wt(e,t){var n,r;const s=e.fields||{};this.dt(t,53);const a="value",i=(null===(r=null===(n=s[a].arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.length)||0;this.dt(t,15),t.At(Jo(i)),this.Vt(a,t),this.Tt(s[a],t)}bt(e,t){const n=e.values||[];this.dt(t,50);for(const r of n)this.Tt(r,t)}yt(e,t){this.dt(t,37),go.fromName(e).path.forEach((e=>{this.dt(t,60),this.Dt(e,t)}))}dt(e,t){e.At(t)}ft(e){e.At(2)}}fh.vt=new fh;class mh{constructor(){this.un=new gh}addToCollectionParentIndex(e,t){return this.un.add(t),To.resolve()}getCollectionParents(e,t){return To.resolve(this.un.getEntries(t))}addFieldIndex(e,t){return To.resolve()}deleteFieldIndex(e,t){return To.resolve()}deleteAllFieldIndexes(e){return To.resolve()}createTargetIndexes(e,t){return To.resolve()}getDocumentsMatchingTarget(e,t){return To.resolve(null)}getIndexType(e,t){return To.resolve(0)}getFieldIndexes(e,t){return To.resolve([])}getNextCollectionGroupToUpdate(e){return To.resolve(null)}getMinOffset(e,t){return To.resolve(wo.min())}getMinOffsetFromCollectionGroup(e,t){return To.resolve(wo.min())}updateCollectionGroup(e,t,n){return To.resolve()}updateIndexEntries(e,t){return To.resolve()}}class gh{constructor(){this.index={}}add(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t]||new Go(po.comparator),s=!r.has(n);return this.index[t]=r.add(n),s}has(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t];return r&&r.has(n)}getEntries(e){return(this.index[e]||new Go(po.comparator)).toArray()}}new Uint8Array(0);const yh={didRun:!1,sequenceNumbersCollected:0,targetsRemoved:0,documentsRemoved:0};class bh{constructor(e,t,n){this.cacheSizeCollectionThreshold=e,this.percentileToCollect=t,this.maximumSequenceNumbersToCollect=n}static withCacheSize(e){return new bh(e,bh.DEFAULT_COLLECTION_PERCENTILE,bh.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}}bh.DEFAULT_COLLECTION_PERCENTILE=10,bh.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,bh.DEFAULT=new bh(41943040,bh.DEFAULT_COLLECTION_PERCENTILE,bh.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),bh.DISABLED=new bh(-1,0,0);class vh{constructor(e){this.Ln=e}next(){return this.Ln+=2,this.Ln}static Bn(){return new vh(0)}static kn(){return new vh(-1)}}function wh(e,t){let[n,r]=e,[s,a]=t;const i=oo(n,s);return 0===i?oo(r,a):i}class xh{constructor(e){this.Un=e,this.buffer=new Go(wh),this.Wn=0}Gn(){return++this.Wn}zn(e){const t=[e,this.Gn()];if(this.buffer.size<this.Un)this.buffer=this.buffer.add(t);else{const e=this.buffer.last();wh(t,e)<0&&(this.buffer=this.buffer.delete(e).add(t))}}get maxValue(){return this.buffer.last()[0]}}class kh{constructor(e,t,n){this.garbageCollector=e,this.asyncQueue=t,this.localStore=n,this.jn=null}start(){-1!==this.garbageCollector.params.cacheSizeCollectionThreshold&&this.Hn(6e4)}stop(){this.jn&&(this.jn.cancel(),this.jn=null)}get started(){return null!==this.jn}Hn(e){Ui("LruGarbageCollector",`Garbage collection scheduled in ${e}ms`),this.jn=this.asyncQueue.enqueueAfterDelay("lru_garbage_collection",e,(async()=>{this.jn=null;try{await this.localStore.collectGarbage(this.garbageCollector)}catch(e){Eo(e)?Ui("LruGarbageCollector","Ignoring IndexedDB error during garbage collection: ",e):await Io(e)}await this.Hn(3e5)}))}}class Sh{constructor(e,t){this.Jn=e,this.params=t}calculateTargetCount(e,t){return this.Jn.Yn(e).next((e=>Math.floor(t/100*e)))}nthSequenceNumber(e,t){if(0===t)return To.resolve(Co.oe);const n=new xh(t);return this.Jn.forEachTarget(e,(e=>n.zn(e.sequenceNumber))).next((()=>this.Jn.Zn(e,(e=>n.zn(e))))).next((()=>n.maxValue))}removeTargets(e,t,n){return this.Jn.removeTargets(e,t,n)}removeOrphanedDocuments(e,t){return this.Jn.removeOrphanedDocuments(e,t)}collect(e,t){return-1===this.params.cacheSizeCollectionThreshold?(Ui("LruGarbageCollector","Garbage collection skipped; disabled"),To.resolve(yh)):this.getCacheSize(e).next((n=>n<this.params.cacheSizeCollectionThreshold?(Ui("LruGarbageCollector",`Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),yh):this.Xn(e,t)))}getCacheSize(e){return this.Jn.getCacheSize(e)}Xn(e,t){let n,r,s,a,i,o,l;const u=Date.now();return this.calculateTargetCount(e,this.params.percentileToCollect).next((t=>(t>this.params.maximumSequenceNumbersToCollect?(Ui("LruGarbageCollector",`Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`),r=this.params.maximumSequenceNumbersToCollect):r=t,a=Date.now(),this.nthSequenceNumber(e,r)))).next((r=>(n=r,i=Date.now(),this.removeTargets(e,n,t)))).next((t=>(s=t,o=Date.now(),this.removeOrphanedDocuments(e,n)))).next((e=>(l=Date.now(),Bi()<=$t.DEBUG&&Ui("LruGarbageCollector",`LRU Garbage Collection\n\tCounted targets in ${a-u}ms\n\tDetermined least recently used ${r} in `+(i-a)+"ms\n"+`\tRemoved ${s} targets in `+(o-i)+"ms\n"+`\tRemoved ${e} documents in `+(l-o)+"ms\n"+`Total Duration: ${l-u}ms`),To.resolve({didRun:!0,sequenceNumbersCollected:r,targetsRemoved:s,documentsRemoved:e}))))}}function Ih(e,t){return new Sh(e,t)}class Th{constructor(){this.changes=new yu((e=>e.toString()),((e,t)=>e.isEqual(t))),this.changesApplied=!1}addEntry(e){this.assertNotApplied(),this.changes.set(e.key,e)}removeEntry(e,t){this.assertNotApplied(),this.changes.set(e,Nl.newInvalidDocument(e).setReadTime(t))}getEntry(e,t){this.assertNotApplied();const n=this.changes.get(t);return void 0!==n?To.resolve(n):this.getFromCache(e,t)}getEntries(e,t){return this.getAllFromCache(e,t)}apply(e){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(e)}assertNotApplied(){}}class Nh{constructor(e,t){this.overlayedDocument=e,this.mutatedFields=t}}class Eh{constructor(e,t,n,r){this.remoteDocumentCache=e,this.mutationQueue=t,this.documentOverlayCache=n,this.indexManager=r}getDocument(e,t){let n=null;return this.documentOverlayCache.getOverlay(e,t).next((r=>(n=r,this.remoteDocumentCache.getEntry(e,t)))).next((e=>(null!==n&&Zu(n.mutation,e,qo.empty(),uo.now()),e)))}getDocuments(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.getLocalViewOfDocuments(e,t,Cu()).next((()=>t))))}getLocalViewOfDocuments(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Cu();const r=Su();return this.populateOverlays(e,r,t).next((()=>this.computeViews(e,t,r,n).next((e=>{let t=xu();return e.forEach(((e,n)=>{t=t.insert(e,n.overlayedDocument)})),t}))))}getOverlayedDocuments(e,t){const n=Su();return this.populateOverlays(e,n,t).next((()=>this.computeViews(e,t,n,Cu())))}populateOverlays(e,t,n){const r=[];return n.forEach((e=>{t.has(e)||r.push(e)})),this.documentOverlayCache.getOverlays(e,r).next((e=>{e.forEach(((e,n)=>{t.set(e,n)}))}))}computeViews(e,t,n,r){let s=vu();const a=Tu(),i=Tu();return t.forEach(((e,t)=>{const i=n.get(t.key);r.has(t.key)&&(void 0===i||i.mutation instanceof rc)?s=s.insert(t.key,t):void 0!==i?(a.set(t.key,i.mutation.getFieldMask()),Zu(i.mutation,t,i.mutation.getFieldMask(),uo.now())):a.set(t.key,qo.empty())})),this.recalculateAndSaveOverlays(e,s).next((e=>(e.forEach(((e,t)=>a.set(e,t))),t.forEach(((e,t)=>{var n;return i.set(e,new Nh(t,null!==(n=a.get(e))&&void 0!==n?n:null))})),i)))}recalculateAndSaveOverlays(e,t){const n=Tu();let r=new Vo(((e,t)=>e-t)),s=Cu();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e,t).next((e=>{for(const s of e)s.keys().forEach((e=>{const a=t.get(e);if(null===a)return;let i=n.get(e)||qo.empty();i=s.applyToLocalView(a,i),n.set(e,i);const o=(r.get(s.batchId)||Cu()).add(e);r=r.insert(s.batchId,o)}))})).next((()=>{const a=[],i=r.getReverseIterator();for(;i.hasNext();){const r=i.getNext(),o=r.key,l=r.value,u=Iu();l.forEach((e=>{if(!s.has(e)){const r=Qu(t.get(e),n.get(e));null!==r&&u.set(e,r),s=s.add(e)}})),a.push(this.documentOverlayCache.saveOverlays(e,o,u))}return To.waitFor(a)})).next((()=>n))}recalculateAndSaveOverlaysForDocumentKeys(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.recalculateAndSaveOverlays(e,t)))}getDocumentsMatchingQuery(e,t,n,r){return function(e){return go.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}(t)?this.getDocumentsMatchingDocumentQuery(e,t.path):su(t)?this.getDocumentsMatchingCollectionGroupQuery(e,t,n,r):this.getDocumentsMatchingCollectionQuery(e,t,n,r)}getNextDocuments(e,t,n,r){return this.remoteDocumentCache.getAllFromCollectionGroup(e,t,n,r).next((s=>{const a=r-s.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(e,t,n.largestBatchId,r-s.size):To.resolve(Su());let i=-1,o=s;return a.next((t=>To.forEach(t,((t,n)=>(i<n.largestBatchId&&(i=n.largestBatchId),s.get(t)?To.resolve():this.remoteDocumentCache.getEntry(e,t).next((e=>{o=o.insert(t,e)}))))).next((()=>this.populateOverlays(e,t,s))).next((()=>this.computeViews(e,o,t,Cu()))).next((e=>({batchId:i,changes:ku(e)})))))}))}getDocumentsMatchingDocumentQuery(e,t){return this.getDocument(e,new go(t)).next((e=>{let t=xu();return e.isFoundDocument()&&(t=t.insert(e.key,e)),t}))}getDocumentsMatchingCollectionGroupQuery(e,t,n,r){const s=t.collectionGroup;let a=xu();return this.indexManager.getCollectionParents(e,s).next((i=>To.forEach(i,(i=>{const o=function(e,t){return new eu(t,null,e.explicitOrderBy.slice(),e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)}(t,i.child(s));return this.getDocumentsMatchingCollectionQuery(e,o,n,r).next((e=>{e.forEach(((e,t)=>{a=a.insert(e,t)}))}))})).next((()=>a))))}getDocumentsMatchingCollectionQuery(e,t,n,r){let s;return this.documentOverlayCache.getOverlaysForCollection(e,t.path,n.largestBatchId).next((a=>(s=a,this.remoteDocumentCache.getDocumentsMatchingQuery(e,t,n,s,r)))).next((e=>{s.forEach(((t,n)=>{const r=n.getKey();null===e.get(r)&&(e=e.insert(r,Nl.newInvalidDocument(r)))}));let n=xu();return e.forEach(((e,r)=>{const a=s.get(e);void 0!==a&&Zu(a.mutation,r,qo.empty(),uo.now()),pu(t,r)&&(n=n.insert(e,r))})),n}))}}class Ch{constructor(e){this.serializer=e,this.hr=new Map,this.Pr=new Map}getBundleMetadata(e,t){return To.resolve(this.hr.get(t))}saveBundleMetadata(e,t){return this.hr.set(t.id,function(e){return{id:e.id,version:e.version,createTime:Uc(e.createTime)}}(t)),To.resolve()}getNamedQuery(e,t){return To.resolve(this.Pr.get(t))}saveNamedQuery(e,t){return this.Pr.set(t.name,function(e){return{name:e.name,query:ph(e.bundledQuery),readTime:Uc(e.readTime)}}(t)),To.resolve()}}class _h{constructor(){this.overlays=new Vo(go.comparator),this.Ir=new Map}getOverlay(e,t){return To.resolve(this.overlays.get(t))}getOverlays(e,t){const n=Su();return To.forEach(t,(t=>this.getOverlay(e,t).next((e=>{null!==e&&n.set(t,e)})))).next((()=>n))}saveOverlays(e,t,n){return n.forEach(((n,r)=>{this.ht(e,t,r)})),To.resolve()}removeOverlaysForBatchId(e,t,n){const r=this.Ir.get(n);return void 0!==r&&(r.forEach((e=>this.overlays=this.overlays.remove(e))),this.Ir.delete(n)),To.resolve()}getOverlaysForCollection(e,t,n){const r=Su(),s=t.length+1,a=new go(t.child("")),i=this.overlays.getIteratorFrom(a);for(;i.hasNext();){const e=i.getNext().value,a=e.getKey();if(!t.isPrefixOf(a.path))break;a.path.length===s&&e.largestBatchId>n&&r.set(e.getKey(),e)}return To.resolve(r)}getOverlaysForCollectionGroup(e,t,n,r){let s=new Vo(((e,t)=>e-t));const a=this.overlays.getIterator();for(;a.hasNext();){const e=a.getNext().value;if(e.getKey().getCollectionGroup()===t&&e.largestBatchId>n){let t=s.get(e.largestBatchId);null===t&&(t=Su(),s=s.insert(e.largestBatchId,t)),t.set(e.getKey(),e)}}const i=Su(),o=s.getIterator();for(;o.hasNext()&&(o.getNext().value.forEach(((e,t)=>i.set(e,t))),!(i.size()>=r)););return To.resolve(i)}ht(e,t,n){const r=this.overlays.get(n.key);if(null!==r){const e=this.Ir.get(r.largestBatchId).delete(n.key);this.Ir.set(r.largestBatchId,e)}this.overlays=this.overlays.insert(n.key,new hc(t,n));let s=this.Ir.get(t);void 0===s&&(s=Cu(),this.Ir.set(t,s)),this.Ir.set(t,s.add(n.key))}}class Ah{constructor(){this.sessionToken=Xo.EMPTY_BYTE_STRING}getSessionToken(e){return To.resolve(this.sessionToken)}setSessionToken(e,t){return this.sessionToken=t,To.resolve()}}class Rh{constructor(){this.Tr=new Go($h.Er),this.dr=new Go($h.Ar)}isEmpty(){return this.Tr.isEmpty()}addReference(e,t){const n=new $h(e,t);this.Tr=this.Tr.add(n),this.dr=this.dr.add(n)}Rr(e,t){e.forEach((e=>this.addReference(e,t)))}removeReference(e,t){this.Vr(new $h(e,t))}mr(e,t){e.forEach((e=>this.removeReference(e,t)))}gr(e){const t=new go(new po([])),n=new $h(t,e),r=new $h(t,e+1),s=[];return this.dr.forEachInRange([n,r],(e=>{this.Vr(e),s.push(e.key)})),s}pr(){this.Tr.forEach((e=>this.Vr(e)))}Vr(e){this.Tr=this.Tr.delete(e),this.dr=this.dr.delete(e)}yr(e){const t=new go(new po([])),n=new $h(t,e),r=new $h(t,e+1);let s=Cu();return this.dr.forEachInRange([n,r],(e=>{s=s.add(e.key)})),s}containsKey(e){const t=new $h(e,0),n=this.Tr.firstAfterOrEqual(t);return null!==n&&e.isEqual(n.key)}}class $h{constructor(e,t){this.key=e,this.wr=t}static Er(e,t){return go.comparator(e.key,t.key)||oo(e.wr,t.wr)}static Ar(e,t){return oo(e.wr,t.wr)||go.comparator(e.key,t.key)}}class Oh{constructor(e,t){this.indexManager=e,this.referenceDelegate=t,this.mutationQueue=[],this.Sr=1,this.br=new Go($h.Er)}checkEmpty(e){return To.resolve(0===this.mutationQueue.length)}addMutationBatch(e,t,n,r){const s=this.Sr;this.Sr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const a=new uc(s,t,n,r);this.mutationQueue.push(a);for(const i of r)this.br=this.br.add(new $h(i.key,s)),this.indexManager.addToCollectionParentIndex(e,i.key.path.popLast());return To.resolve(a)}lookupMutationBatch(e,t){return To.resolve(this.Dr(t))}getNextMutationBatchAfterBatchId(e,t){const n=t+1,r=this.vr(n),s=r<0?0:r;return To.resolve(this.mutationQueue.length>s?this.mutationQueue[s]:null)}getHighestUnacknowledgedBatchId(){return To.resolve(0===this.mutationQueue.length?-1:this.Sr-1)}getAllMutationBatches(e){return To.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(e,t){const n=new $h(t,0),r=new $h(t,Number.POSITIVE_INFINITY),s=[];return this.br.forEachInRange([n,r],(e=>{const t=this.Dr(e.wr);s.push(t)})),To.resolve(s)}getAllMutationBatchesAffectingDocumentKeys(e,t){let n=new Go(oo);return t.forEach((e=>{const t=new $h(e,0),r=new $h(e,Number.POSITIVE_INFINITY);this.br.forEachInRange([t,r],(e=>{n=n.add(e.wr)}))})),To.resolve(this.Cr(n))}getAllMutationBatchesAffectingQuery(e,t){const n=t.path,r=n.length+1;let s=n;go.isDocumentKey(s)||(s=s.child(""));const a=new $h(new go(s),0);let i=new Go(oo);return this.br.forEachWhile((e=>{const t=e.key.path;return!!n.isPrefixOf(t)&&(t.length===r&&(i=i.add(e.wr)),!0)}),a),To.resolve(this.Cr(i))}Cr(e){const t=[];return e.forEach((e=>{const n=this.Dr(e);null!==n&&t.push(n)})),t}removeMutationBatch(e,t){Hi(0===this.Fr(t.batchId,"removed")),this.mutationQueue.shift();let n=this.br;return To.forEach(t.mutations,(r=>{const s=new $h(r.key,t.batchId);return n=n.delete(s),this.referenceDelegate.markPotentiallyOrphaned(e,r.key)})).next((()=>{this.br=n}))}On(e){}containsKey(e,t){const n=new $h(t,0),r=this.br.firstAfterOrEqual(n);return To.resolve(t.isEqual(r&&r.key))}performConsistencyCheck(e){return this.mutationQueue.length,To.resolve()}Fr(e,t){return this.vr(e)}vr(e){return 0===this.mutationQueue.length?0:e-this.mutationQueue[0].batchId}Dr(e){const t=this.vr(e);return t<0||t>=this.mutationQueue.length?null:this.mutationQueue[t]}}class Dh{constructor(e){this.Mr=e,this.docs=new Vo(go.comparator),this.size=0}setIndexManager(e){this.indexManager=e}addEntry(e,t){const n=t.key,r=this.docs.get(n),s=r?r.size:0,a=this.Mr(t);return this.docs=this.docs.insert(n,{document:t.mutableCopy(),size:a}),this.size+=a-s,this.indexManager.addToCollectionParentIndex(e,n.path.popLast())}removeEntry(e){const t=this.docs.get(e);t&&(this.docs=this.docs.remove(e),this.size-=t.size)}getEntry(e,t){const n=this.docs.get(t);return To.resolve(n?n.document.mutableCopy():Nl.newInvalidDocument(t))}getEntries(e,t){let n=vu();return t.forEach((e=>{const t=this.docs.get(e);n=n.insert(e,t?t.document.mutableCopy():Nl.newInvalidDocument(e))})),To.resolve(n)}getDocumentsMatchingQuery(e,t,n,r){let s=vu();const a=t.path,i=new go(a.child("")),o=this.docs.getIteratorFrom(i);for(;o.hasNext();){const{key:e,value:{document:i}}=o.getNext();if(!a.isPrefixOf(e.path))break;e.path.length>a.length+1||xo(vo(i),n)<=0||(r.has(i.key)||pu(t,i))&&(s=s.insert(i.key,i.mutableCopy()))}return To.resolve(s)}getAllFromCollectionGroup(e,t,n,r){Gi()}Or(e,t){return To.forEach(this.docs,(e=>t(e)))}newChangeBuffer(e){return new Fh(this)}getSize(e){return To.resolve(this.size)}}class Fh extends Th{constructor(e){super(),this.cr=e}applyChanges(e){const t=[];return this.changes.forEach(((n,r)=>{r.isValidDocument()?t.push(this.cr.addEntry(e,r)):this.cr.removeEntry(n)})),To.waitFor(t)}getFromCache(e,t){return this.cr.getEntry(e,t)}getAllFromCache(e,t){return this.cr.getEntries(e,t)}}class Lh{constructor(e){this.persistence=e,this.Nr=new yu((e=>Ql(e)),Jl),this.lastRemoteSnapshotVersion=co.min(),this.highestTargetId=0,this.Lr=0,this.Br=new Rh,this.targetCount=0,this.kr=vh.Bn()}forEachTarget(e,t){return this.Nr.forEach(((e,n)=>t(n))),To.resolve()}getLastRemoteSnapshotVersion(e){return To.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(e){return To.resolve(this.Lr)}allocateTargetId(e){return this.highestTargetId=this.kr.next(),To.resolve(this.highestTargetId)}setTargetsMetadata(e,t,n){return n&&(this.lastRemoteSnapshotVersion=n),t>this.Lr&&(this.Lr=t),To.resolve()}Kn(e){this.Nr.set(e.target,e);const t=e.targetId;t>this.highestTargetId&&(this.kr=new vh(t),this.highestTargetId=t),e.sequenceNumber>this.Lr&&(this.Lr=e.sequenceNumber)}addTargetData(e,t){return this.Kn(t),this.targetCount+=1,To.resolve()}updateTargetData(e,t){return this.Kn(t),To.resolve()}removeTargetData(e,t){return this.Nr.delete(t.target),this.Br.gr(t.targetId),this.targetCount-=1,To.resolve()}removeTargets(e,t,n){let r=0;const s=[];return this.Nr.forEach(((a,i)=>{i.sequenceNumber<=t&&null===n.get(i.targetId)&&(this.Nr.delete(a),s.push(this.removeMatchingKeysForTargetId(e,i.targetId)),r++)})),To.waitFor(s).next((()=>r))}getTargetCount(e){return To.resolve(this.targetCount)}getTargetData(e,t){const n=this.Nr.get(t)||null;return To.resolve(n)}addMatchingKeys(e,t,n){return this.Br.Rr(t,n),To.resolve()}removeMatchingKeys(e,t,n){this.Br.mr(t,n);const r=this.persistence.referenceDelegate,s=[];return r&&t.forEach((t=>{s.push(r.markPotentiallyOrphaned(e,t))})),To.waitFor(s)}removeMatchingKeysForTargetId(e,t){return this.Br.gr(t),To.resolve()}getMatchingKeysForTargetId(e,t){const n=this.Br.yr(t);return To.resolve(n)}containsKey(e,t){return To.resolve(this.Br.containsKey(t))}}class Mh{constructor(e,t){this.qr={},this.overlays={},this.Qr=new Co(0),this.Kr=!1,this.Kr=!0,this.$r=new Ah,this.referenceDelegate=e(this),this.Ur=new Lh(this),this.indexManager=new mh,this.remoteDocumentCache=function(e){return new Dh(e)}((e=>this.referenceDelegate.Wr(e))),this.serializer=new dh(t),this.Gr=new Ch(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.Kr=!1,Promise.resolve()}get started(){return this.Kr}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(e){return this.indexManager}getDocumentOverlayCache(e){let t=this.overlays[e.toKey()];return t||(t=new _h,this.overlays[e.toKey()]=t),t}getMutationQueue(e,t){let n=this.qr[e.toKey()];return n||(n=new Oh(t,this.referenceDelegate),this.qr[e.toKey()]=n),n}getGlobalsCache(){return this.$r}getTargetCache(){return this.Ur}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Gr}runTransaction(e,t,n){Ui("MemoryPersistence","Starting transaction:",e);const r=new Ph(this.Qr.next());return this.referenceDelegate.zr(),n(r).next((e=>this.referenceDelegate.jr(r).next((()=>e)))).toPromise().then((e=>(r.raiseOnCommittedEvent(),e)))}Hr(e,t){return To.or(Object.values(this.qr).map((n=>()=>n.containsKey(e,t))))}}class Ph extends So{constructor(e){super(),this.currentSequenceNumber=e}}class zh{constructor(e){this.persistence=e,this.Jr=new Rh,this.Yr=null}static Zr(e){return new zh(e)}get Xr(){if(this.Yr)return this.Yr;throw Gi()}addReference(e,t,n){return this.Jr.addReference(n,t),this.Xr.delete(n.toString()),To.resolve()}removeReference(e,t,n){return this.Jr.removeReference(n,t),this.Xr.add(n.toString()),To.resolve()}markPotentiallyOrphaned(e,t){return this.Xr.add(t.toString()),To.resolve()}removeTarget(e,t){this.Jr.gr(t.targetId).forEach((e=>this.Xr.add(e.toString())));const n=this.persistence.getTargetCache();return n.getMatchingKeysForTargetId(e,t.targetId).next((e=>{e.forEach((e=>this.Xr.add(e.toString())))})).next((()=>n.removeTargetData(e,t)))}zr(){this.Yr=new Set}jr(e){const t=this.persistence.getRemoteDocumentCache().newChangeBuffer();return To.forEach(this.Xr,(n=>{const r=go.fromPath(n);return this.ei(e,r).next((e=>{e||t.removeEntry(r,co.min())}))})).next((()=>(this.Yr=null,t.apply(e))))}updateLimboDocument(e,t){return this.ei(e,t).next((e=>{e?this.Xr.delete(t.toString()):this.Xr.add(t.toString())}))}Wr(e){return 0}ei(e,t){return To.or([()=>To.resolve(this.Jr.containsKey(t)),()=>this.persistence.getTargetCache().containsKey(e,t),()=>this.persistence.Hr(e,t)])}}class Bh{constructor(e,t){this.persistence=e,this.ti=new yu((e=>$o(e.path)),((e,t)=>e.isEqual(t))),this.garbageCollector=Ih(this,t)}static Zr(e,t){return new Bh(e,t)}zr(){}jr(e){return To.resolve()}forEachTarget(e,t){return this.persistence.getTargetCache().forEachTarget(e,t)}Yn(e){const t=this.er(e);return this.persistence.getTargetCache().getTargetCount(e).next((e=>t.next((t=>e+t))))}er(e){let t=0;return this.Zn(e,(e=>{t++})).next((()=>t))}Zn(e,t){return To.forEach(this.ti,((n,r)=>this.nr(e,n,r).next((e=>e?To.resolve():t(r)))))}removeTargets(e,t,n){return this.persistence.getTargetCache().removeTargets(e,t,n)}removeOrphanedDocuments(e,t){let n=0;const r=this.persistence.getRemoteDocumentCache(),s=r.newChangeBuffer();return r.Or(e,(r=>this.nr(e,r,t).next((e=>{e||(n++,s.removeEntry(r,co.min()))})))).next((()=>s.apply(e))).next((()=>n))}markPotentiallyOrphaned(e,t){return this.ti.set(t,e.currentSequenceNumber),To.resolve()}removeTarget(e,t){const n=t.withSequenceNumber(e.currentSequenceNumber);return this.persistence.getTargetCache().updateTargetData(e,n)}addReference(e,t,n){return this.ti.set(n,e.currentSequenceNumber),To.resolve()}removeReference(e,t,n){return this.ti.set(n,e.currentSequenceNumber),To.resolve()}updateLimboDocument(e,t){return this.ti.set(t,e.currentSequenceNumber),To.resolve()}Wr(e){let t=e.key.toString().length;return e.isFoundDocument()&&(t+=fl(e.data.value)),t}nr(e,t,n){return To.or([()=>this.persistence.Hr(e,t),()=>this.persistence.getTargetCache().containsKey(e,t),()=>{const e=this.ti.get(t);return To.resolve(void 0!==e&&e>n)}])}getCacheSize(e){return this.persistence.getRemoteDocumentCache().getSize(e)}}class Uh{constructor(e,t,n,r){this.targetId=e,this.fromCache=t,this.$i=n,this.Ui=r}static Wi(e,t){let n=Cu(),r=Cu();for(const s of t.docChanges)switch(s.type){case 0:n=n.add(s.doc.key);break;case 1:r=r.add(s.doc.key)}return new Uh(e,t.fromCache,n,r)}}class Vh{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(e){this._documentReadCount+=e}}class Wh{constructor(){this.Gi=!1,this.zi=!1,this.ji=100,this.Hi=ft()?8:No(pt())>0?6:4}initialize(e,t){this.Ji=e,this.indexManager=t,this.Gi=!0}getDocumentsMatchingQuery(e,t,n,r){const s={result:null};return this.Yi(e,t).next((e=>{s.result=e})).next((()=>{if(!s.result)return this.Zi(e,t,r,n).next((e=>{s.result=e}))})).next((()=>{if(s.result)return;const n=new Vh;return this.Xi(e,t,n).next((r=>{if(s.result=r,this.zi)return this.es(e,t,n,r.size)}))})).next((()=>s.result))}es(e,t,n,r){return n.documentReadCount<this.ji?(Bi()<=$t.DEBUG&&Ui("QueryEngine","SDK will not create cache indexes for query:",du(t),"since it only creates cache indexes for collection contains","more than or equal to",this.ji,"documents"),To.resolve()):(Bi()<=$t.DEBUG&&Ui("QueryEngine","Query:",du(t),"scans",n.documentReadCount,"local documents and returns",r,"documents as results."),n.documentReadCount>this.Hi*r?(Bi()<=$t.DEBUG&&Ui("QueryEngine","The SDK decides to create cache indexes for query:",du(t),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(e,iu(t))):To.resolve())}Yi(e,t){if(ru(t))return To.resolve(null);let n=iu(t);return this.indexManager.getIndexType(e,n).next((r=>0===r?null:(null!==t.limit&&1===r&&(t=uu(t,null,"F"),n=iu(t)),this.indexManager.getDocumentsMatchingTarget(e,n).next((r=>{const s=Cu(...r);return this.Ji.getDocuments(e,s).next((r=>this.indexManager.getMinOffset(e,n).next((n=>{const a=this.ts(t,r);return this.ns(t,a,s,n.readTime)?this.Yi(e,uu(t,null,"F")):this.rs(e,a,t,n)}))))})))))}Zi(e,t,n,r){return ru(t)||r.isEqual(co.min())?To.resolve(null):this.Ji.getDocuments(e,n).next((s=>{const a=this.ts(t,s);return this.ns(t,a,n,r)?To.resolve(null):(Bi()<=$t.DEBUG&&Ui("QueryEngine","Re-using previous result from %s to execute query: %s",r.toString(),du(t)),this.rs(e,a,t,bo(r,-1)).next((e=>e)))}))}ts(e,t){let n=new Go(mu(e));return t.forEach(((t,r)=>{pu(e,r)&&(n=n.add(r))})),n}ns(e,t,n,r){if(null===e.limit)return!1;if(n.size!==t.size)return!0;const s="F"===e.limitType?t.last():t.first();return!!s&&(s.hasPendingWrites||s.version.compareTo(r)>0)}Xi(e,t,n){return Bi()<=$t.DEBUG&&Ui("QueryEngine","Using full collection scan to execute query:",du(t)),this.Ji.getDocumentsMatchingQuery(e,t,wo.min(),n)}rs(e,t,n,r){return this.Ji.getDocumentsMatchingQuery(e,n,r).next((e=>(t.forEach((t=>{e=e.insert(t.key,t)})),e)))}}class jh{constructor(e,t,n,r){this.persistence=e,this.ss=t,this.serializer=r,this.os=new Vo(oo),this._s=new yu((e=>Ql(e)),Jl),this.us=new Map,this.cs=e.getRemoteDocumentCache(),this.Ur=e.getTargetCache(),this.Gr=e.getBundleCache(),this.ls(n)}ls(e){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(e),this.indexManager=this.persistence.getIndexManager(e),this.mutationQueue=this.persistence.getMutationQueue(e,this.indexManager),this.localDocuments=new Eh(this.cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.cs.setIndexManager(this.indexManager),this.ss.initialize(this.localDocuments,this.indexManager)}collectGarbage(e){return this.persistence.runTransaction("Collect garbage","readwrite-primary",(t=>e.collect(t,this.os)))}}function Gh(e,t,n,r){return new jh(e,t,n,r)}async function Hh(e,t){const n=qi(e);return await n.persistence.runTransaction("Handle user change","readonly",(e=>{let r;return n.mutationQueue.getAllMutationBatches(e).next((s=>(r=s,n.ls(t),n.mutationQueue.getAllMutationBatches(e)))).next((t=>{const s=[],a=[];let i=Cu();for(const e of r){s.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}for(const e of t){a.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}return n.localDocuments.getDocuments(e,i).next((e=>({hs:e,removedBatchIds:s,addedBatchIds:a})))}))}))}function qh(e){const t=qi(e);return t.persistence.runTransaction("Get last remote snapshot version","readonly",(e=>t.Ur.getLastRemoteSnapshotVersion(e)))}function Kh(e,t,n){let r=Cu(),s=Cu();return n.forEach((e=>r=r.add(e))),t.getEntries(e,r).next((e=>{let r=vu();return n.forEach(((n,a)=>{const i=e.get(n);a.isFoundDocument()!==i.isFoundDocument()&&(s=s.add(n)),a.isNoDocument()&&a.version.isEqual(co.min())?(t.removeEntry(n,a.readTime),r=r.insert(n,a)):!i.isValidDocument()||a.version.compareTo(i.version)>0||0===a.version.compareTo(i.version)&&i.hasPendingWrites?(t.addEntry(a),r=r.insert(n,a)):Ui("LocalStore","Ignoring outdated watch update for ",n,". Current version:",i.version," Watch version:",a.version)})),{Ps:r,Is:s}}))}function Xh(e,t){const n=qi(e);return n.persistence.runTransaction("Get next mutation batch","readonly",(e=>(void 0===t&&(t=-1),n.mutationQueue.getNextMutationBatchAfterBatchId(e,t))))}function Yh(e,t){const n=qi(e);return n.persistence.runTransaction("Allocate target","readwrite",(e=>{let r;return n.Ur.getTargetData(e,t).next((s=>s?(r=s,To.resolve(r)):n.Ur.allocateTargetId(e).next((s=>(r=new hh(t,s,"TargetPurposeListen",e.currentSequenceNumber),n.Ur.addTargetData(e,r).next((()=>r)))))))})).then((e=>{const r=n.os.get(e.targetId);return(null===r||e.snapshotVersion.compareTo(r.snapshotVersion)>0)&&(n.os=n.os.insert(e.targetId,e),n._s.set(t,e.targetId)),e}))}async function Qh(e,t,n){const r=qi(e),s=r.os.get(t),a=n?"readwrite":"readwrite-primary";try{n||await r.persistence.runTransaction("Release target",a,(e=>r.persistence.referenceDelegate.removeTarget(e,s)))}catch(e){if(!Eo(e))throw e;Ui("LocalStore",`Failed to update sequence numbers for target ${t}: ${e}`)}r.os=r.os.remove(t),r._s.delete(s.target)}function Jh(e,t,n){const r=qi(e);let s=co.min(),a=Cu();return r.persistence.runTransaction("Execute query","readwrite",(e=>function(e,t,n){const r=qi(e),s=r._s.get(n);return void 0!==s?To.resolve(r.os.get(s)):r.Ur.getTargetData(t,n)}(r,e,iu(t)).next((t=>{if(t)return s=t.lastLimboFreeSnapshotVersion,r.Ur.getMatchingKeysForTargetId(e,t.targetId).next((e=>{a=e}))})).next((()=>r.ss.getDocumentsMatchingQuery(e,t,n?s:co.min(),n?a:Cu()))).next((e=>(Zh(r,fu(t),e),{documents:e,Ts:a})))))}function Zh(e,t,n){let r=e.us.get(t)||co.min();n.forEach(((e,t)=>{t.readTime.compareTo(r)>0&&(r=t.readTime)})),e.us.set(t,r)}class ed{constructor(){this.activeTargetIds=Au()}fs(e){this.activeTargetIds=this.activeTargetIds.add(e)}gs(e){this.activeTargetIds=this.activeTargetIds.delete(e)}Vs(){const e={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(e)}}class td{constructor(){this.so=new ed,this.oo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(e){}updateMutationState(e,t,n){}addLocalQueryTarget(e){return(!(arguments.length>1&&void 0!==arguments[1])||arguments[1])&&this.so.fs(e),this.oo[e]||"not-current"}updateQueryState(e,t,n){this.oo[e]=t}removeLocalQueryTarget(e){this.so.gs(e)}isLocalQueryTarget(e){return this.so.activeTargetIds.has(e)}clearQueryState(e){delete this.oo[e]}getAllActiveQueryTargets(){return this.so.activeTargetIds}isActiveQueryTarget(e){return this.so.activeTargetIds.has(e)}start(){return this.so=new ed,Promise.resolve()}handleUserChange(e,t,n){}setOnlineState(e){}shutdown(){}writeSequenceNumber(e){}notifyBundleLoaded(e){}}class nd{_o(e){}shutdown(){}}class rd{constructor(){this.ao=()=>this.uo(),this.co=()=>this.lo(),this.ho=[],this.Po()}_o(e){this.ho.push(e)}shutdown(){window.removeEventListener("online",this.ao),window.removeEventListener("offline",this.co)}Po(){window.addEventListener("online",this.ao),window.addEventListener("offline",this.co)}uo(){Ui("ConnectivityMonitor","Network connectivity changed: AVAILABLE");for(const e of this.ho)e(0)}lo(){Ui("ConnectivityMonitor","Network connectivity changed: UNAVAILABLE");for(const e of this.ho)e(1)}static D(){return"undefined"!=typeof window&&void 0!==window.addEventListener&&void 0!==window.removeEventListener}}let sd=null;function ad(){return null===sd?sd=268435456+Math.round(2147483648*Math.random()):sd++,"0x"+sd.toString(16)}const id={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class od{constructor(e){this.Io=e.Io,this.To=e.To}Eo(e){this.Ao=e}Ro(e){this.Vo=e}mo(e){this.fo=e}onMessage(e){this.po=e}close(){this.To()}send(e){this.Io(e)}yo(){this.Ao()}wo(){this.Vo()}So(e){this.fo(e)}bo(e){this.po(e)}}const ld="WebChannelConnection";class ud extends class{constructor(e){this.databaseInfo=e,this.databaseId=e.databaseId;const t=e.ssl?"https":"http",n=encodeURIComponent(this.databaseId.projectId),r=encodeURIComponent(this.databaseId.database);this.Do=t+"://"+e.host,this.vo=`projects/${n}/databases/${r}`,this.Co="(default)"===this.databaseId.database?`project_id=${n}`:`project_id=${n}&database_id=${r}`}get Fo(){return!1}Mo(e,t,n,r,s){const a=ad(),i=this.xo(e,t.toUriEncodedString());Ui("RestConnection",`Sending RPC '${e}' ${a}:`,i,n);const o={"google-cloud-resource-prefix":this.vo,"x-goog-request-params":this.Co};return this.Oo(o,r,s),this.No(e,i,o,n).then((t=>(Ui("RestConnection",`Received RPC '${e}' ${a}: `,t),t)),(t=>{throw Wi("RestConnection",`RPC '${e}' ${a} failed with error: `,t,"url: ",i,"request:",n),t}))}Lo(e,t,n,r,s,a){return this.Mo(e,t,n,r,s)}Oo(e,t,n){e["X-Goog-Api-Client"]="gl-js/ fire/"+Pi,e["Content-Type"]="text/plain",this.databaseInfo.appId&&(e["X-Firebase-GMPID"]=this.databaseInfo.appId),t&&t.headers.forEach(((t,n)=>e[n]=t)),n&&n.headers.forEach(((t,n)=>e[n]=t))}xo(e,t){const n=id[e];return`${this.Do}/v1/${t}:${n}`}terminate(){}}{constructor(e){super(e),this.forceLongPolling=e.forceLongPolling,this.autoDetectLongPolling=e.autoDetectLongPolling,this.useFetchStreams=e.useFetchStreams,this.longPollingOptions=e.longPollingOptions}No(e,t,n,r){const s=ad();return new Promise(((a,i)=>{const o=new Ni;o.setWithCredentials(!0),o.listenOnce(Ci.COMPLETE,(()=>{try{switch(o.getLastErrorCode()){case _i.NO_ERROR:const t=o.getResponseJson();Ui(ld,`XHR for RPC '${e}' ${s} received:`,JSON.stringify(t)),a(t);break;case _i.TIMEOUT:Ui(ld,`RPC '${e}' ${s} timed out`),i(new Xi(Ki.DEADLINE_EXCEEDED,"Request time out"));break;case _i.HTTP_ERROR:const n=o.getStatus();if(Ui(ld,`RPC '${e}' ${s} failed with status:`,n,"response text:",o.getResponseText()),n>0){let e=o.getResponseJson();Array.isArray(e)&&(e=e[0]);const t=null==e?void 0:e.error;if(t&&t.status&&t.message){const e=function(e){const t=e.toLowerCase().replace(/_/g,"-");return Object.values(Ki).indexOf(t)>=0?t:Ki.UNKNOWN}(t.status);i(new Xi(e,t.message))}else i(new Xi(Ki.UNKNOWN,"Server responded with status "+o.getStatus()))}else i(new Xi(Ki.UNAVAILABLE,"Connection failed."));break;default:Gi()}}finally{Ui(ld,`RPC '${e}' ${s} completed.`)}}));const l=JSON.stringify(r);Ui(ld,`RPC '${e}' ${s} sending request:`,r),o.send(t,"POST",l,n,15)}))}Bo(e,t,n){const r=ad(),s=[this.Do,"/","google.firestore.v1.Firestore","/",e,"/channel"],a=Oi(),i=$i(),o={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},l=this.longPollingOptions.timeoutSeconds;void 0!==l&&(o.longPollingTimeout=Math.round(1e3*l)),this.useFetchStreams&&(o.useFetchStreams=!0),this.Oo(o.initMessageHeaders,t,n),o.encodeInitMessageHeaders=!0;const u=s.join("");Ui(ld,`Creating RPC '${e}' stream ${r}: ${u}`,o);const c=a.createWebChannel(u,o);let h=!1,d=!1;const p=new od({Io:t=>{d?Ui(ld,`Not sending because RPC '${e}' stream ${r} is closed:`,t):(h||(Ui(ld,`Opening RPC '${e}' stream ${r} transport.`),c.open(),h=!0),Ui(ld,`RPC '${e}' stream ${r} sending:`,t),c.send(t))},To:()=>c.close()}),f=(e,t,n)=>{e.listen(t,(e=>{try{n(e)}catch(e){setTimeout((()=>{throw e}),0)}}))};return f(c,Ei.EventType.OPEN,(()=>{d||(Ui(ld,`RPC '${e}' stream ${r} transport opened.`),p.yo())})),f(c,Ei.EventType.CLOSE,(()=>{d||(d=!0,Ui(ld,`RPC '${e}' stream ${r} transport closed`),p.So())})),f(c,Ei.EventType.ERROR,(t=>{d||(d=!0,Wi(ld,`RPC '${e}' stream ${r} transport errored:`,t),p.So(new Xi(Ki.UNAVAILABLE,"The operation could not be completed")))})),f(c,Ei.EventType.MESSAGE,(t=>{var n;if(!d){const s=t.data[0];Hi(!!s);const a=s,i=a.error||(null===(n=a[0])||void 0===n?void 0:n.error);if(i){Ui(ld,`RPC '${e}' stream ${r} received error:`,i);const t=i.status;let n=function(e){const t=pc[e];if(void 0!==t)return gc(t)}(t),s=i.message;void 0===n&&(n=Ki.INTERNAL,s="Unknown error status: "+t+" with message "+i.message),d=!0,p.So(new Xi(n,s)),c.close()}else Ui(ld,`RPC '${e}' stream ${r} received:`,s),p.bo(s)}})),f(i,Ri.STAT_EVENT,(t=>{t.stat===Ai.PROXY?Ui(ld,`RPC '${e}' stream ${r} detected buffering proxy`):t.stat===Ai.NOPROXY&&Ui(ld,`RPC '${e}' stream ${r} detected no buffering proxy`)})),setTimeout((()=>{p.wo()}),0),p}}function cd(){return"undefined"!=typeof document?document:null}function hd(e){return new Lc(e,!0)}class dd{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:6e4;this.ui=e,this.timerId=t,this.ko=n,this.qo=r,this.Qo=s,this.Ko=0,this.$o=null,this.Uo=Date.now(),this.reset()}reset(){this.Ko=0}Wo(){this.Ko=this.Qo}Go(e){this.cancel();const t=Math.floor(this.Ko+this.zo()),n=Math.max(0,Date.now()-this.Uo),r=Math.max(0,t-n);r>0&&Ui("ExponentialBackoff",`Backing off for ${r} ms (base delay: ${this.Ko} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`),this.$o=this.ui.enqueueAfterDelay(this.timerId,r,(()=>(this.Uo=Date.now(),e()))),this.Ko*=this.qo,this.Ko<this.ko&&(this.Ko=this.ko),this.Ko>this.Qo&&(this.Ko=this.Qo)}jo(){null!==this.$o&&(this.$o.skipDelay(),this.$o=null)}cancel(){null!==this.$o&&(this.$o.cancel(),this.$o=null)}zo(){return(Math.random()-.5)*this.Ko}}class pd{constructor(e,t,n,r,s,a,i,o){this.ui=e,this.Ho=n,this.Jo=r,this.connection=s,this.authCredentialsProvider=a,this.appCheckCredentialsProvider=i,this.listener=o,this.state=0,this.Yo=0,this.Zo=null,this.Xo=null,this.stream=null,this.e_=0,this.t_=new dd(e,t)}n_(){return 1===this.state||5===this.state||this.r_()}r_(){return 2===this.state||3===this.state}start(){this.e_=0,4!==this.state?this.auth():this.i_()}async stop(){this.n_()&&await this.close(0)}s_(){this.state=0,this.t_.reset()}o_(){this.r_()&&null===this.Zo&&(this.Zo=this.ui.enqueueAfterDelay(this.Ho,6e4,(()=>this.__())))}a_(e){this.u_(),this.stream.send(e)}async __(){if(this.r_())return this.close(0)}u_(){this.Zo&&(this.Zo.cancel(),this.Zo=null)}c_(){this.Xo&&(this.Xo.cancel(),this.Xo=null)}async close(e,t){this.u_(),this.c_(),this.t_.cancel(),this.Yo++,4!==e?this.t_.reset():t&&t.code===Ki.RESOURCE_EXHAUSTED?(Vi(t.toString()),Vi("Using maximum backoff delay to prevent overloading the backend."),this.t_.Wo()):t&&t.code===Ki.UNAUTHENTICATED&&3!==this.state&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),null!==this.stream&&(this.l_(),this.stream.close(),this.stream=null),this.state=e,await this.listener.mo(t)}l_(){}auth(){this.state=1;const e=this.h_(this.Yo),t=this.Yo;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then((e=>{let[n,r]=e;this.Yo===t&&this.P_(n,r)}),(t=>{e((()=>{const e=new Xi(Ki.UNKNOWN,"Fetching auth token failed: "+t.message);return this.I_(e)}))}))}P_(e,t){const n=this.h_(this.Yo);this.stream=this.T_(e,t),this.stream.Eo((()=>{n((()=>this.listener.Eo()))})),this.stream.Ro((()=>{n((()=>(this.state=2,this.Xo=this.ui.enqueueAfterDelay(this.Jo,1e4,(()=>(this.r_()&&(this.state=3),Promise.resolve()))),this.listener.Ro())))})),this.stream.mo((e=>{n((()=>this.I_(e)))})),this.stream.onMessage((e=>{n((()=>1==++this.e_?this.E_(e):this.onNext(e)))}))}i_(){this.state=5,this.t_.Go((async()=>{this.state=0,this.start()}))}I_(e){return Ui("PersistentStream",`close with error: ${e}`),this.stream=null,this.close(4,e)}h_(e){return t=>{this.ui.enqueueAndForget((()=>this.Yo===e?t():(Ui("PersistentStream","stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve())))}}}class fd extends pd{constructor(e,t,n,r,s,a){super(e,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",t,n,r,a),this.serializer=s}T_(e,t){return this.connection.Bo("Listen",e,t)}E_(e){return this.onNext(e)}onNext(e){this.t_.reset();const t=function(e,t){let n;if("targetChange"in t){t.targetChange;const r=function(e){return"NO_CHANGE"===e?0:"ADD"===e?1:"REMOVE"===e?2:"CURRENT"===e?3:"RESET"===e?4:Gi()}(t.targetChange.targetChangeType||"NO_CHANGE"),s=t.targetChange.targetIds||[],a=function(e,t){return e.useProto3Json?(Hi(void 0===t||"string"==typeof t),Xo.fromBase64String(t||"")):(Hi(void 0===t||t instanceof Buffer||t instanceof Uint8Array),Xo.fromUint8Array(t||new Uint8Array))}(e,t.targetChange.resumeToken),i=t.targetChange.cause,o=i&&function(e){const t=void 0===e.code?Ki.UNKNOWN:gc(e.code);return new Xi(t,e.message||"")}(i);n=new Cc(r,s,a,o||null)}else if("documentChange"in t){t.documentChange;const r=t.documentChange;r.document,r.document.name,r.document.updateTime;const s=Hc(e,r.document.name),a=Uc(r.document.updateTime),i=r.document.createTime?Uc(r.document.createTime):co.min(),o=new Il({mapValue:{fields:r.document.fields}}),l=Nl.newFoundDocument(s,a,i,o),u=r.targetIds||[],c=r.removedTargetIds||[];n=new Nc(u,c,l.key,l)}else if("documentDelete"in t){t.documentDelete;const r=t.documentDelete;r.document;const s=Hc(e,r.document),a=r.readTime?Uc(r.readTime):co.min(),i=Nl.newNoDocument(s,a),o=r.removedTargetIds||[];n=new Nc([],o,i.key,i)}else if("documentRemove"in t){t.documentRemove;const r=t.documentRemove;r.document;const s=Hc(e,r.document),a=r.removedTargetIds||[];n=new Nc([],a,s,null)}else{if(!("filter"in t))return Gi();{t.filter;const e=t.filter;e.targetId;const{count:r=0,unchangedNames:s}=e,a=new dc(r,s),i=e.targetId;n=new Ec(i,a)}}return n}(this.serializer,e),n=function(e){if(!("targetChange"in e))return co.min();const t=e.targetChange;return t.targetIds&&t.targetIds.length?co.min():t.readTime?Uc(t.readTime):co.min()}(e);return this.listener.d_(t,n)}A_(e){const t={};t.database=Xc(this.serializer),t.addTarget=function(e,t){let n;const r=t.target;if(n=Zl(r)?{documents:Zc(e,r)}:{query:eh(e,r)._t},n.targetId=t.targetId,t.resumeToken.approximateByteSize()>0){n.resumeToken=zc(e,t.resumeToken);const r=Mc(e,t.expectedCount);null!==r&&(n.expectedCount=r)}else if(t.snapshotVersion.compareTo(co.min())>0){n.readTime=Pc(e,t.snapshotVersion.toTimestamp());const r=Mc(e,t.expectedCount);null!==r&&(n.expectedCount=r)}return n}(this.serializer,e);const n=function(e,t){const n=function(e){switch(e){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return Gi()}}(t.purpose);return null==n?null:{"goog-listen-tags":n}}(this.serializer,e);n&&(t.labels=n),this.a_(t)}R_(e){const t={};t.database=Xc(this.serializer),t.removeTarget=e,this.a_(t)}}class md extends pd{constructor(e,t,n,r,s,a){super(e,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",t,n,r,a),this.serializer=s}get V_(){return this.e_>0}start(){this.lastStreamToken=void 0,super.start()}l_(){this.V_&&this.m_([])}T_(e,t){return this.connection.Bo("Write",e,t)}E_(e){return Hi(!!e.streamToken),this.lastStreamToken=e.streamToken,Hi(!e.writeResults||0===e.writeResults.length),this.listener.f_()}onNext(e){Hi(!!e.streamToken),this.lastStreamToken=e.streamToken,this.t_.reset();const t=function(e,t){return e&&e.length>0?(Hi(void 0!==t),e.map((e=>function(e,t){let n=e.updateTime?Uc(e.updateTime):Uc(t);return n.isEqual(co.min())&&(n=Uc(t)),new qu(n,e.transformResults||[])}(e,t)))):[]}(e.writeResults,e.commitTime),n=Uc(e.commitTime);return this.listener.g_(n,t)}p_(){const e={};e.database=Xc(this.serializer),this.a_(e)}m_(e){const t={streamToken:this.lastStreamToken,writes:e.map((e=>Jc(this.serializer,e)))};this.a_(t)}}class gd extends class{}{constructor(e,t,n,r){super(),this.authCredentials=e,this.appCheckCredentials=t,this.connection=n,this.serializer=r,this.y_=!1}w_(){if(this.y_)throw new Xi(Ki.FAILED_PRECONDITION,"The client has already been terminated.")}Mo(e,t,n,r){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((s=>{let[a,i]=s;return this.connection.Mo(e,Wc(t,n),r,a,i)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===Ki.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new Xi(Ki.UNKNOWN,e.toString())}))}Lo(e,t,n,r,s){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((a=>{let[i,o]=a;return this.connection.Lo(e,Wc(t,n),r,i,o,s)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===Ki.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new Xi(Ki.UNKNOWN,e.toString())}))}terminate(){this.y_=!0,this.connection.terminate()}}class yd{constructor(e,t){this.asyncQueue=e,this.onlineStateHandler=t,this.state="Unknown",this.S_=0,this.b_=null,this.D_=!0}v_(){0===this.S_&&(this.C_("Unknown"),this.b_=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,(()=>(this.b_=null,this.F_("Backend didn't respond within 10 seconds."),this.C_("Offline"),Promise.resolve()))))}M_(e){"Online"===this.state?this.C_("Unknown"):(this.S_++,this.S_>=1&&(this.x_(),this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`),this.C_("Offline")))}set(e){this.x_(),this.S_=0,"Online"===e&&(this.D_=!1),this.C_(e)}C_(e){e!==this.state&&(this.state=e,this.onlineStateHandler(e))}F_(e){const t=`Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.D_?(Vi(t),this.D_=!1):Ui("OnlineStateTracker",t)}x_(){null!==this.b_&&(this.b_.cancel(),this.b_=null)}}class bd{constructor(e,t,n,r,s){this.localStore=e,this.datastore=t,this.asyncQueue=n,this.remoteSyncer={},this.O_=[],this.N_=new Map,this.L_=new Set,this.B_=[],this.k_=s,this.k_._o((e=>{n.enqueueAndForget((async()=>{Ed(this)&&(Ui("RemoteStore","Restarting streams for network reachability change."),await async function(e){const t=qi(e);t.L_.add(4),await wd(t),t.q_.set("Unknown"),t.L_.delete(4),await vd(t)}(this))}))})),this.q_=new yd(n,r)}}async function vd(e){if(Ed(e))for(const t of e.B_)await t(!0)}async function wd(e){for(const t of e.B_)await t(!1)}function xd(e,t){const n=qi(e);n.N_.has(t.targetId)||(n.N_.set(t.targetId,t),Nd(n)?Td(n):Hd(n).r_()&&Sd(n,t))}function kd(e,t){const n=qi(e),r=Hd(n);n.N_.delete(t),r.r_()&&Id(n,t),0===n.N_.size&&(r.r_()?r.o_():Ed(n)&&n.q_.set("Unknown"))}function Sd(e,t){if(e.Q_.xe(t.targetId),t.resumeToken.approximateByteSize()>0||t.snapshotVersion.compareTo(co.min())>0){const n=e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;t=t.withExpectedCount(n)}Hd(e).A_(t)}function Id(e,t){e.Q_.xe(t),Hd(e).R_(t)}function Td(e){e.Q_=new Ac({getRemoteKeysForTarget:t=>e.remoteSyncer.getRemoteKeysForTarget(t),ot:t=>e.N_.get(t)||null,tt:()=>e.datastore.serializer.databaseId}),Hd(e).start(),e.q_.v_()}function Nd(e){return Ed(e)&&!Hd(e).n_()&&e.N_.size>0}function Ed(e){return 0===qi(e).L_.size}function Cd(e){e.Q_=void 0}async function _d(e){e.q_.set("Online")}async function Ad(e){e.N_.forEach(((t,n)=>{Sd(e,t)}))}async function Rd(e,t){Cd(e),Nd(e)?(e.q_.M_(t),Td(e)):e.q_.set("Unknown")}async function $d(e,t,n){if(e.q_.set("Online"),t instanceof Cc&&2===t.state&&t.cause)try{await async function(e,t){const n=t.cause;for(const r of t.targetIds)e.N_.has(r)&&(await e.remoteSyncer.rejectListen(r,n),e.N_.delete(r),e.Q_.removeTarget(r))}(e,t)}catch(n){Ui("RemoteStore","Failed to remove targets %s: %s ",t.targetIds.join(","),n),await Od(e,n)}else if(t instanceof Nc?e.Q_.Ke(t):t instanceof Ec?e.Q_.He(t):e.Q_.We(t),!n.isEqual(co.min()))try{const t=await qh(e.localStore);n.compareTo(t)>=0&&await function(e,t){const n=e.Q_.rt(t);return n.targetChanges.forEach(((n,r)=>{if(n.resumeToken.approximateByteSize()>0){const s=e.N_.get(r);s&&e.N_.set(r,s.withResumeToken(n.resumeToken,t))}})),n.targetMismatches.forEach(((t,n)=>{const r=e.N_.get(t);if(!r)return;e.N_.set(t,r.withResumeToken(Xo.EMPTY_BYTE_STRING,r.snapshotVersion)),Id(e,t);const s=new hh(r.target,t,n,r.sequenceNumber);Sd(e,s)})),e.remoteSyncer.applyRemoteEvent(n)}(e,n)}catch(t){Ui("RemoteStore","Failed to raise snapshot:",t),await Od(e,t)}}async function Od(e,t,n){if(!Eo(t))throw t;e.L_.add(1),await wd(e),e.q_.set("Offline"),n||(n=()=>qh(e.localStore)),e.asyncQueue.enqueueRetryable((async()=>{Ui("RemoteStore","Retrying IndexedDB access"),await n(),e.L_.delete(1),await vd(e)}))}function Dd(e,t){return t().catch((n=>Od(e,n,t)))}async function Fd(e){const t=qi(e),n=qd(t);let r=t.O_.length>0?t.O_[t.O_.length-1].batchId:-1;for(;Ld(t);)try{const e=await Xh(t.localStore,r);if(null===e){0===t.O_.length&&n.o_();break}r=e.batchId,Md(t,e)}catch(e){await Od(t,e)}Pd(t)&&zd(t)}function Ld(e){return Ed(e)&&e.O_.length<10}function Md(e,t){e.O_.push(t);const n=qd(e);n.r_()&&n.V_&&n.m_(t.mutations)}function Pd(e){return Ed(e)&&!qd(e).n_()&&e.O_.length>0}function zd(e){qd(e).start()}async function Bd(e){qd(e).p_()}async function Ud(e){const t=qd(e);for(const n of e.O_)t.m_(n.mutations)}async function Vd(e,t,n){const r=e.O_.shift(),s=cc.from(r,t,n);await Dd(e,(()=>e.remoteSyncer.applySuccessfulWrite(s))),await Fd(e)}async function Wd(e,t){t&&qd(e).V_&&await async function(e,t){if(function(e){return mc(e)&&e!==Ki.ABORTED}(t.code)){const n=e.O_.shift();qd(e).s_(),await Dd(e,(()=>e.remoteSyncer.rejectFailedWrite(n.batchId,t))),await Fd(e)}}(e,t),Pd(e)&&zd(e)}async function jd(e,t){const n=qi(e);n.asyncQueue.verifyOperationInProgress(),Ui("RemoteStore","RemoteStore received new credentials");const r=Ed(n);n.L_.add(3),await wd(n),r&&n.q_.set("Unknown"),await n.remoteSyncer.handleCredentialChange(t),n.L_.delete(3),await vd(n)}async function Gd(e,t){const n=qi(e);t?(n.L_.delete(2),await vd(n)):t||(n.L_.add(2),await wd(n),n.q_.set("Unknown"))}function Hd(e){return e.K_||(e.K_=function(e,t,n){const r=qi(e);return r.w_(),new fd(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:_d.bind(null,e),Ro:Ad.bind(null,e),mo:Rd.bind(null,e),d_:$d.bind(null,e)}),e.B_.push((async t=>{t?(e.K_.s_(),Nd(e)?Td(e):e.q_.set("Unknown")):(await e.K_.stop(),Cd(e))}))),e.K_}function qd(e){return e.U_||(e.U_=function(e,t,n){const r=qi(e);return r.w_(),new md(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:()=>Promise.resolve(),Ro:Bd.bind(null,e),mo:Wd.bind(null,e),f_:Ud.bind(null,e),g_:Vd.bind(null,e)}),e.B_.push((async t=>{t?(e.U_.s_(),await Fd(e)):(await e.U_.stop(),e.O_.length>0&&(Ui("RemoteStore",`Stopping write stream with ${e.O_.length} pending writes`),e.O_=[]))}))),e.U_}class Kd{constructor(e,t,n,r,s){this.asyncQueue=e,this.timerId=t,this.targetTimeMs=n,this.op=r,this.removalCallback=s,this.deferred=new Yi,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch((e=>{}))}get promise(){return this.deferred.promise}static createAndSchedule(e,t,n,r,s){const a=Date.now()+n,i=new Kd(e,t,a,r,s);return i.start(n),i}start(e){this.timerHandle=setTimeout((()=>this.handleDelayElapsed()),e)}skipDelay(){return this.handleDelayElapsed()}cancel(e){null!==this.timerHandle&&(this.clearTimeout(),this.deferred.reject(new Xi(Ki.CANCELLED,"Operation cancelled"+(e?": "+e:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget((()=>null!==this.timerHandle?(this.clearTimeout(),this.op().then((e=>this.deferred.resolve(e)))):Promise.resolve()))}clearTimeout(){null!==this.timerHandle&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function Xd(e,t){if(Vi("AsyncQueue",`${t}: ${e}`),Eo(e))return new Xi(Ki.UNAVAILABLE,`${t}: ${e}`);throw e}class Yd{constructor(e){this.comparator=e?(t,n)=>e(t,n)||go.comparator(t.key,n.key):(e,t)=>go.comparator(e.key,t.key),this.keyedMap=xu(),this.sortedSet=new Vo(this.comparator)}static emptySet(e){return new Yd(e.comparator)}has(e){return null!=this.keyedMap.get(e)}get(e){return this.keyedMap.get(e)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(e){const t=this.keyedMap.get(e);return t?this.sortedSet.indexOf(t):-1}get size(){return this.sortedSet.size}forEach(e){this.sortedSet.inorderTraversal(((t,n)=>(e(t),!1)))}add(e){const t=this.delete(e.key);return t.copy(t.keyedMap.insert(e.key,e),t.sortedSet.insert(e,null))}delete(e){const t=this.get(e);return t?this.copy(this.keyedMap.remove(e),this.sortedSet.remove(t)):this}isEqual(e){if(!(e instanceof Yd))return!1;if(this.size!==e.size)return!1;const t=this.sortedSet.getIterator(),n=e.sortedSet.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(!e.isEqual(r))return!1}return!0}toString(){const e=[];return this.forEach((t=>{e.push(t.toString())})),0===e.length?"DocumentSet ()":"DocumentSet (\n  "+e.join("  \n")+"\n)"}copy(e,t){const n=new Yd;return n.comparator=this.comparator,n.keyedMap=e,n.sortedSet=t,n}}class Qd{constructor(){this.W_=new Vo(go.comparator)}track(e){const t=e.doc.key,n=this.W_.get(t);n?0!==e.type&&3===n.type?this.W_=this.W_.insert(t,e):3===e.type&&1!==n.type?this.W_=this.W_.insert(t,{type:n.type,doc:e.doc}):2===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):2===e.type&&0===n.type?this.W_=this.W_.insert(t,{type:0,doc:e.doc}):1===e.type&&0===n.type?this.W_=this.W_.remove(t):1===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:1,doc:n.doc}):0===e.type&&1===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):Gi():this.W_=this.W_.insert(t,e)}G_(){const e=[];return this.W_.inorderTraversal(((t,n)=>{e.push(n)})),e}}class Jd{constructor(e,t,n,r,s,a,i,o,l){this.query=e,this.docs=t,this.oldDocs=n,this.docChanges=r,this.mutatedKeys=s,this.fromCache=a,this.syncStateChanged=i,this.excludesMetadataChanges=o,this.hasCachedResults=l}static fromInitialDocuments(e,t,n,r,s){const a=[];return t.forEach((e=>{a.push({type:0,doc:e})})),new Jd(e,t,Yd.emptySet(t),a,n,r,!0,!1,s)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(e){if(!(this.fromCache===e.fromCache&&this.hasCachedResults===e.hasCachedResults&&this.syncStateChanged===e.syncStateChanged&&this.mutatedKeys.isEqual(e.mutatedKeys)&&cu(this.query,e.query)&&this.docs.isEqual(e.docs)&&this.oldDocs.isEqual(e.oldDocs)))return!1;const t=this.docChanges,n=e.docChanges;if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++)if(t[r].type!==n[r].type||!t[r].doc.isEqual(n[r].doc))return!1;return!0}}class Zd{constructor(){this.z_=void 0,this.j_=[]}H_(){return this.j_.some((e=>e.J_()))}}class ep{constructor(){this.queries=tp(),this.onlineState="Unknown",this.Y_=new Set}terminate(){!function(e,t){const n=qi(e),r=n.queries;n.queries=tp(),r.forEach(((e,n)=>{for(const r of n.j_)r.onError(t)}))}(this,new Xi(Ki.ABORTED,"Firestore shutting down"))}}function tp(){return new yu((e=>hu(e)),cu)}async function np(e,t){const n=qi(e);let r=3;const s=t.query;let a=n.queries.get(s);a?!a.H_()&&t.J_()&&(r=2):(a=new Zd,r=t.J_()?0:1);try{switch(r){case 0:a.z_=await n.onListen(s,!0);break;case 1:a.z_=await n.onListen(s,!1);break;case 2:await n.onFirstRemoteStoreListen(s)}}catch(e){const n=Xd(e,`Initialization of query '${du(t.query)}' failed`);return void t.onError(n)}n.queries.set(s,a),a.j_.push(t),t.Z_(n.onlineState),a.z_&&t.X_(a.z_)&&ip(n)}async function rp(e,t){const n=qi(e),r=t.query;let s=3;const a=n.queries.get(r);if(a){const e=a.j_.indexOf(t);e>=0&&(a.j_.splice(e,1),0===a.j_.length?s=t.J_()?0:1:!a.H_()&&t.J_()&&(s=2))}switch(s){case 0:return n.queries.delete(r),n.onUnlisten(r,!0);case 1:return n.queries.delete(r),n.onUnlisten(r,!1);case 2:return n.onLastRemoteStoreUnlisten(r);default:return}}function sp(e,t){const n=qi(e);let r=!1;for(const s of t){const e=s.query,t=n.queries.get(e);if(t){for(const e of t.j_)e.X_(s)&&(r=!0);t.z_=s}}r&&ip(n)}function ap(e,t,n){const r=qi(e),s=r.queries.get(t);if(s)for(const a of s.j_)a.onError(n);r.queries.delete(t)}function ip(e){e.Y_.forEach((e=>{e.next()}))}var op,lp;(lp=op||(op={})).ea="default",lp.Cache="cache";class up{constructor(e,t,n){this.query=e,this.ta=t,this.na=!1,this.ra=null,this.onlineState="Unknown",this.options=n||{}}X_(e){if(!this.options.includeMetadataChanges){const t=[];for(const n of e.docChanges)3!==n.type&&t.push(n);e=new Jd(e.query,e.docs,e.oldDocs,t,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)}let t=!1;return this.na?this.ia(e)&&(this.ta.next(e),t=!0):this.sa(e,this.onlineState)&&(this.oa(e),t=!0),this.ra=e,t}onError(e){this.ta.error(e)}Z_(e){this.onlineState=e;let t=!1;return this.ra&&!this.na&&this.sa(this.ra,e)&&(this.oa(this.ra),t=!0),t}sa(e,t){if(!e.fromCache)return!0;if(!this.J_())return!0;const n="Offline"!==t;return(!this.options._a||!n)&&(!e.docs.isEmpty()||e.hasCachedResults||"Offline"===t)}ia(e){if(e.docChanges.length>0)return!0;const t=this.ra&&this.ra.hasPendingWrites!==e.hasPendingWrites;return!(!e.syncStateChanged&&!t)&&!0===this.options.includeMetadataChanges}oa(e){e=Jd.fromInitialDocuments(e.query,e.docs,e.mutatedKeys,e.fromCache,e.hasCachedResults),this.na=!0,this.ta.next(e)}J_(){return this.options.source!==op.Cache}}class cp{constructor(e){this.key=e}}class hp{constructor(e){this.key=e}}class dp{constructor(e,t){this.query=e,this.Ta=t,this.Ea=null,this.hasCachedResults=!1,this.current=!1,this.da=Cu(),this.mutatedKeys=Cu(),this.Aa=mu(e),this.Ra=new Yd(this.Aa)}get Va(){return this.Ta}ma(e,t){const n=t?t.fa:new Qd,r=t?t.Ra:this.Ra;let s=t?t.mutatedKeys:this.mutatedKeys,a=r,i=!1;const o="F"===this.query.limitType&&r.size===this.query.limit?r.last():null,l="L"===this.query.limitType&&r.size===this.query.limit?r.first():null;if(e.inorderTraversal(((e,t)=>{const u=r.get(e),c=pu(this.query,t)?t:null,h=!!u&&this.mutatedKeys.has(u.key),d=!!c&&(c.hasLocalMutations||this.mutatedKeys.has(c.key)&&c.hasCommittedMutations);let p=!1;u&&c?u.data.isEqual(c.data)?h!==d&&(n.track({type:3,doc:c}),p=!0):this.ga(u,c)||(n.track({type:2,doc:c}),p=!0,(o&&this.Aa(c,o)>0||l&&this.Aa(c,l)<0)&&(i=!0)):!u&&c?(n.track({type:0,doc:c}),p=!0):u&&!c&&(n.track({type:1,doc:u}),p=!0,(o||l)&&(i=!0)),p&&(c?(a=a.add(c),s=d?s.add(e):s.delete(e)):(a=a.delete(e),s=s.delete(e)))})),null!==this.query.limit)for(;a.size>this.query.limit;){const e="F"===this.query.limitType?a.last():a.first();a=a.delete(e.key),s=s.delete(e.key),n.track({type:1,doc:e})}return{Ra:a,fa:n,ns:i,mutatedKeys:s}}ga(e,t){return e.hasLocalMutations&&t.hasCommittedMutations&&!t.hasLocalMutations}applyChanges(e,t,n,r){const s=this.Ra;this.Ra=e.Ra,this.mutatedKeys=e.mutatedKeys;const a=e.fa.G_();a.sort(((e,t)=>function(e,t){const n=e=>{switch(e){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return Gi()}};return n(e)-n(t)}(e.type,t.type)||this.Aa(e.doc,t.doc))),this.pa(n),r=null!=r&&r;const i=t&&!r?this.ya():[],o=0===this.da.size&&this.current&&!r?1:0,l=o!==this.Ea;return this.Ea=o,0!==a.length||l?{snapshot:new Jd(this.query,e.Ra,s,a,e.mutatedKeys,0===o,l,!1,!!n&&n.resumeToken.approximateByteSize()>0),wa:i}:{wa:i}}Z_(e){return this.current&&"Offline"===e?(this.current=!1,this.applyChanges({Ra:this.Ra,fa:new Qd,mutatedKeys:this.mutatedKeys,ns:!1},!1)):{wa:[]}}Sa(e){return!this.Ta.has(e)&&!!this.Ra.has(e)&&!this.Ra.get(e).hasLocalMutations}pa(e){e&&(e.addedDocuments.forEach((e=>this.Ta=this.Ta.add(e))),e.modifiedDocuments.forEach((e=>{})),e.removedDocuments.forEach((e=>this.Ta=this.Ta.delete(e))),this.current=e.current)}ya(){if(!this.current)return[];const e=this.da;this.da=Cu(),this.Ra.forEach((e=>{this.Sa(e.key)&&(this.da=this.da.add(e.key))}));const t=[];return e.forEach((e=>{this.da.has(e)||t.push(new hp(e))})),this.da.forEach((n=>{e.has(n)||t.push(new cp(n))})),t}ba(e){this.Ta=e.Ts,this.da=Cu();const t=this.ma(e.documents);return this.applyChanges(t,!0)}Da(){return Jd.fromInitialDocuments(this.query,this.Ra,this.mutatedKeys,0===this.Ea,this.hasCachedResults)}}class pp{constructor(e,t,n){this.query=e,this.targetId=t,this.view=n}}class fp{constructor(e){this.key=e,this.va=!1}}class mp{constructor(e,t,n,r,s,a){this.localStore=e,this.remoteStore=t,this.eventManager=n,this.sharedClientState=r,this.currentUser=s,this.maxConcurrentLimboResolutions=a,this.Ca={},this.Fa=new yu((e=>hu(e)),cu),this.Ma=new Map,this.xa=new Set,this.Oa=new Vo(go.comparator),this.Na=new Map,this.La=new Rh,this.Ba={},this.ka=new Map,this.qa=vh.kn(),this.onlineState="Unknown",this.Qa=void 0}get isPrimaryClient(){return!0===this.Qa}}async function gp(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Mp(e);let s;const a=r.Fa.get(t);return a?(r.sharedClientState.addLocalQueryTarget(a.targetId),s=a.view.Da()):s=await bp(r,t,n,!0),s}async function yp(e,t){const n=Mp(e);await bp(n,t,!0,!1)}async function bp(e,t,n,r){const s=await Yh(e.localStore,iu(t)),a=s.targetId,i=e.sharedClientState.addLocalQueryTarget(a,n);let o;return r&&(o=await vp(e,t,a,"current"===i,s.resumeToken)),e.isPrimaryClient&&n&&xd(e.remoteStore,s),o}async function vp(e,t,n,r,s){e.Ka=(t,n,r)=>async function(e,t,n,r){let s=t.view.ma(n);s.ns&&(s=await Jh(e.localStore,t.query,!1).then((e=>{let{documents:n}=e;return t.view.ma(n,s)})));const a=r&&r.targetChanges.get(t.targetId),i=r&&null!=r.targetMismatches.get(t.targetId),o=t.view.applyChanges(s,e.isPrimaryClient,a,i);return Rp(e,t.targetId,o.wa),o.snapshot}(e,t,n,r);const a=await Jh(e.localStore,t,!0),i=new dp(t,a.Ts),o=i.ma(a.documents),l=Tc.createSynthesizedTargetChangeForCurrentChange(n,r&&"Offline"!==e.onlineState,s),u=i.applyChanges(o,e.isPrimaryClient,l);Rp(e,n,u.wa);const c=new pp(t,n,i);return e.Fa.set(t,c),e.Ma.has(n)?e.Ma.get(n).push(t):e.Ma.set(n,[t]),u.snapshot}async function wp(e,t,n){const r=qi(e),s=r.Fa.get(t),a=r.Ma.get(s.targetId);if(a.length>1)return r.Ma.set(s.targetId,a.filter((e=>!cu(e,t)))),void r.Fa.delete(t);r.isPrimaryClient?(r.sharedClientState.removeLocalQueryTarget(s.targetId),r.sharedClientState.isActiveQueryTarget(s.targetId)||await Qh(r.localStore,s.targetId,!1).then((()=>{r.sharedClientState.clearQueryState(s.targetId),n&&kd(r.remoteStore,s.targetId),_p(r,s.targetId)})).catch(Io)):(_p(r,s.targetId),await Qh(r.localStore,s.targetId,!0))}async function xp(e,t){const n=qi(e),r=n.Fa.get(t),s=n.Ma.get(r.targetId);n.isPrimaryClient&&1===s.length&&(n.sharedClientState.removeLocalQueryTarget(r.targetId),kd(n.remoteStore,r.targetId))}async function kp(e,t){const n=qi(e);try{const e=await function(e,t){const n=qi(e),r=t.snapshotVersion;let s=n.os;return n.persistence.runTransaction("Apply remote event","readwrite-primary",(e=>{const a=n.cs.newChangeBuffer({trackRemovals:!0});s=n.os;const i=[];t.targetChanges.forEach(((a,o)=>{const l=s.get(o);if(!l)return;i.push(n.Ur.removeMatchingKeys(e,a.removedDocuments,o).next((()=>n.Ur.addMatchingKeys(e,a.addedDocuments,o))));let u=l.withSequenceNumber(e.currentSequenceNumber);null!==t.targetMismatches.get(o)?u=u.withResumeToken(Xo.EMPTY_BYTE_STRING,co.min()).withLastLimboFreeSnapshotVersion(co.min()):a.resumeToken.approximateByteSize()>0&&(u=u.withResumeToken(a.resumeToken,r)),s=s.insert(o,u),function(e,t,n){return 0===e.resumeToken.approximateByteSize()||t.snapshotVersion.toMicroseconds()-e.snapshotVersion.toMicroseconds()>=3e8||n.addedDocuments.size+n.modifiedDocuments.size+n.removedDocuments.size>0}(l,u,a)&&i.push(n.Ur.updateTargetData(e,u))}));let o=vu(),l=Cu();if(t.documentUpdates.forEach((r=>{t.resolvedLimboDocuments.has(r)&&i.push(n.persistence.referenceDelegate.updateLimboDocument(e,r))})),i.push(Kh(e,a,t.documentUpdates).next((e=>{o=e.Ps,l=e.Is}))),!r.isEqual(co.min())){const t=n.Ur.getLastRemoteSnapshotVersion(e).next((t=>n.Ur.setTargetsMetadata(e,e.currentSequenceNumber,r)));i.push(t)}return To.waitFor(i).next((()=>a.apply(e))).next((()=>n.localDocuments.getLocalViewOfDocuments(e,o,l))).next((()=>o))})).then((e=>(n.os=s,e)))}(n.localStore,t);t.targetChanges.forEach(((e,t)=>{const r=n.Na.get(t);r&&(Hi(e.addedDocuments.size+e.modifiedDocuments.size+e.removedDocuments.size<=1),e.addedDocuments.size>0?r.va=!0:e.modifiedDocuments.size>0?Hi(r.va):e.removedDocuments.size>0&&(Hi(r.va),r.va=!1))})),await Dp(n,e,t)}catch(e){await Io(e)}}function Sp(e,t,n){const r=qi(e);if(r.isPrimaryClient&&0===n||!r.isPrimaryClient&&1===n){const e=[];r.Fa.forEach(((n,r)=>{const s=r.view.Z_(t);s.snapshot&&e.push(s.snapshot)})),function(e,t){const n=qi(e);n.onlineState=t;let r=!1;n.queries.forEach(((e,n)=>{for(const s of n.j_)s.Z_(t)&&(r=!0)})),r&&ip(n)}(r.eventManager,t),e.length&&r.Ca.d_(e),r.onlineState=t,r.isPrimaryClient&&r.sharedClientState.setOnlineState(t)}}async function Ip(e,t,n){const r=qi(e);r.sharedClientState.updateQueryState(t,"rejected",n);const s=r.Na.get(t),a=s&&s.key;if(a){let e=new Vo(go.comparator);e=e.insert(a,Nl.newNoDocument(a,co.min()));const n=Cu().add(a),s=new Ic(co.min(),new Map,new Vo(oo),e,n);await kp(r,s),r.Oa=r.Oa.remove(a),r.Na.delete(t),Op(r)}else await Qh(r.localStore,t,!1).then((()=>_p(r,t,n))).catch(Io)}async function Tp(e,t){const n=qi(e),r=t.batch.batchId;try{const e=await function(e,t){const n=qi(e);return n.persistence.runTransaction("Acknowledge batch","readwrite-primary",(e=>{const r=t.batch.keys(),s=n.cs.newChangeBuffer({trackRemovals:!0});return function(e,t,n,r){const s=n.batch,a=s.keys();let i=To.resolve();return a.forEach((e=>{i=i.next((()=>r.getEntry(t,e))).next((t=>{const a=n.docVersions.get(e);Hi(null!==a),t.version.compareTo(a)<0&&(s.applyToRemoteDocument(t,n),t.isValidDocument()&&(t.setReadTime(n.commitVersion),r.addEntry(t)))}))})),i.next((()=>e.mutationQueue.removeMutationBatch(t,s)))}(n,e,t,s).next((()=>s.apply(e))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t.batch.batchId))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,function(e){let t=Cu();for(let n=0;n<e.mutationResults.length;++n)e.mutationResults[n].transformResults.length>0&&(t=t.add(e.batch.mutations[n].key));return t}(t)))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(n.localStore,t);Cp(n,r,null),Ep(n,r),n.sharedClientState.updateMutationState(r,"acknowledged"),await Dp(n,e)}catch(e){await Io(e)}}async function Np(e,t,n){const r=qi(e);try{const e=await function(e,t){const n=qi(e);return n.persistence.runTransaction("Reject batch","readwrite-primary",(e=>{let r;return n.mutationQueue.lookupMutationBatch(e,t).next((t=>(Hi(null!==t),r=t.keys(),n.mutationQueue.removeMutationBatch(e,t)))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,r))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(r.localStore,t);Cp(r,t,n),Ep(r,t),r.sharedClientState.updateMutationState(t,"rejected",n),await Dp(r,e)}catch(n){await Io(n)}}function Ep(e,t){(e.ka.get(t)||[]).forEach((e=>{e.resolve()})),e.ka.delete(t)}function Cp(e,t,n){const r=qi(e);let s=r.Ba[r.currentUser.toKey()];if(s){const e=s.get(t);e&&(n?e.reject(n):e.resolve(),s=s.remove(t)),r.Ba[r.currentUser.toKey()]=s}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;e.sharedClientState.removeLocalQueryTarget(t);for(const r of e.Ma.get(t))e.Fa.delete(r),n&&e.Ca.$a(r,n);e.Ma.delete(t),e.isPrimaryClient&&e.La.gr(t).forEach((t=>{e.La.containsKey(t)||Ap(e,t)}))}function Ap(e,t){e.xa.delete(t.path.canonicalString());const n=e.Oa.get(t);null!==n&&(kd(e.remoteStore,n),e.Oa=e.Oa.remove(t),e.Na.delete(n),Op(e))}function Rp(e,t,n){for(const r of n)r instanceof cp?(e.La.addReference(r.key,t),$p(e,r)):r instanceof hp?(Ui("SyncEngine","Document no longer in limbo: "+r.key),e.La.removeReference(r.key,t),e.La.containsKey(r.key)||Ap(e,r.key)):Gi()}function $p(e,t){const n=t.key,r=n.path.canonicalString();e.Oa.get(n)||e.xa.has(r)||(Ui("SyncEngine","New document in limbo: "+n),e.xa.add(r),Op(e))}function Op(e){for(;e.xa.size>0&&e.Oa.size<e.maxConcurrentLimboResolutions;){const t=e.xa.values().next().value;e.xa.delete(t);const n=new go(po.fromString(t)),r=e.qa.next();e.Na.set(r,new fp(n)),e.Oa=e.Oa.insert(n,r),xd(e.remoteStore,new hh(iu(nu(n.path)),r,"TargetPurposeLimboResolution",Co.oe))}}async function Dp(e,t,n){const r=qi(e),s=[],a=[],i=[];r.Fa.isEmpty()||(r.Fa.forEach(((e,o)=>{i.push(r.Ka(o,t,n).then((e=>{var t;if((e||n)&&r.isPrimaryClient){const s=e?!e.fromCache:null===(t=null==n?void 0:n.targetChanges.get(o.targetId))||void 0===t?void 0:t.current;r.sharedClientState.updateQueryState(o.targetId,s?"current":"not-current")}if(e){s.push(e);const t=Uh.Wi(o.targetId,e);a.push(t)}})))})),await Promise.all(i),r.Ca.d_(s),await async function(e,t){const n=qi(e);try{await n.persistence.runTransaction("notifyLocalViewChanges","readwrite",(e=>To.forEach(t,(t=>To.forEach(t.$i,(r=>n.persistence.referenceDelegate.addReference(e,t.targetId,r))).next((()=>To.forEach(t.Ui,(r=>n.persistence.referenceDelegate.removeReference(e,t.targetId,r)))))))))}catch(e){if(!Eo(e))throw e;Ui("LocalStore","Failed to update sequence numbers: "+e)}for(const r of t){const e=r.targetId;if(!r.fromCache){const t=n.os.get(e),r=t.snapshotVersion,s=t.withLastLimboFreeSnapshotVersion(r);n.os=n.os.insert(e,s)}}}(r.localStore,a))}async function Fp(e,t){const n=qi(e);if(!n.currentUser.isEqual(t)){Ui("SyncEngine","User change. New user:",t.toKey());const e=await Hh(n.localStore,t);n.currentUser=t,function(e,t){e.ka.forEach((e=>{e.forEach((e=>{e.reject(new Xi(Ki.CANCELLED,t))}))})),e.ka.clear()}(n,"'waitForPendingWrites' promise is rejected due to a user change."),n.sharedClientState.handleUserChange(t,e.removedBatchIds,e.addedBatchIds),await Dp(n,e.hs)}}function Lp(e,t){const n=qi(e),r=n.Na.get(t);if(r&&r.va)return Cu().add(r.key);{let e=Cu();const r=n.Ma.get(t);if(!r)return e;for(const t of r){const r=n.Fa.get(t);e=e.unionWith(r.view.Va)}return e}}function Mp(e){const t=qi(e);return t.remoteStore.remoteSyncer.applyRemoteEvent=kp.bind(null,t),t.remoteStore.remoteSyncer.getRemoteKeysForTarget=Lp.bind(null,t),t.remoteStore.remoteSyncer.rejectListen=Ip.bind(null,t),t.Ca.d_=sp.bind(null,t.eventManager),t.Ca.$a=ap.bind(null,t.eventManager),t}function Pp(e){const t=qi(e);return t.remoteStore.remoteSyncer.applySuccessfulWrite=Tp.bind(null,t),t.remoteStore.remoteSyncer.rejectFailedWrite=Np.bind(null,t),t}class zp{constructor(){this.kind="memory",this.synchronizeTabs=!1}async initialize(e){this.serializer=hd(e.databaseInfo.databaseId),this.sharedClientState=this.Wa(e),this.persistence=this.Ga(e),await this.persistence.start(),this.localStore=this.za(e),this.gcScheduler=this.ja(e,this.localStore),this.indexBackfillerScheduler=this.Ha(e,this.localStore)}ja(e,t){return null}Ha(e,t){return null}za(e){return Gh(this.persistence,new Wh,e.initialUser,this.serializer)}Ga(e){return new Mh(zh.Zr,this.serializer)}Wa(e){return new td}async terminate(){var e,t;null===(e=this.gcScheduler)||void 0===e||e.stop(),null===(t=this.indexBackfillerScheduler)||void 0===t||t.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}zp.provider={build:()=>new zp};class Bp extends zp{constructor(e){super(),this.cacheSizeBytes=e}ja(e,t){Hi(this.persistence.referenceDelegate instanceof Bh);const n=this.persistence.referenceDelegate.garbageCollector;return new kh(n,e.asyncQueue,t)}Ga(e){const t=void 0!==this.cacheSizeBytes?bh.withCacheSize(this.cacheSizeBytes):bh.DEFAULT;return new Mh((e=>Bh.Zr(e,t)),this.serializer)}}class Up{async initialize(e,t){this.localStore||(this.localStore=e.localStore,this.sharedClientState=e.sharedClientState,this.datastore=this.createDatastore(t),this.remoteStore=this.createRemoteStore(t),this.eventManager=this.createEventManager(t),this.syncEngine=this.createSyncEngine(t,!e.synchronizeTabs),this.sharedClientState.onlineStateHandler=e=>Sp(this.syncEngine,e,1),this.remoteStore.remoteSyncer.handleCredentialChange=Fp.bind(null,this.syncEngine),await Gd(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(e){return new ep}createDatastore(e){const t=hd(e.databaseInfo.databaseId),n=function(e){return new ud(e)}(e.databaseInfo);return function(e,t,n,r){return new gd(e,t,n,r)}(e.authCredentials,e.appCheckCredentials,n,t)}createRemoteStore(e){return function(e,t,n,r,s){return new bd(e,t,n,r,s)}(this.localStore,this.datastore,e.asyncQueue,(e=>Sp(this.syncEngine,e,0)),rd.D()?new rd:new nd)}createSyncEngine(e,t){return function(e,t,n,r,s,a,i){const o=new mp(e,t,n,r,s,a);return i&&(o.Qa=!0),o}(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,e.initialUser,e.maxConcurrentLimboResolutions,t)}async terminate(){var e,t;await async function(e){const t=qi(e);Ui("RemoteStore","RemoteStore shutting down."),t.L_.add(5),await wd(t),t.k_.shutdown(),t.q_.set("Unknown")}(this.remoteStore),null===(e=this.datastore)||void 0===e||e.terminate(),null===(t=this.eventManager)||void 0===t||t.terminate()}}Up.provider={build:()=>new Up};class Vp{constructor(e){this.observer=e,this.muted=!1}next(e){this.muted||this.observer.next&&this.Ya(this.observer.next,e)}error(e){this.muted||(this.observer.error?this.Ya(this.observer.error,e):Vi("Uncaught Error in snapshot listener:",e.toString()))}Za(){this.muted=!0}Ya(e,t){setTimeout((()=>{this.muted||e(t)}),0)}}class Wp{constructor(e,t,n,r,s){this.authCredentials=e,this.appCheckCredentials=t,this.asyncQueue=n,this.databaseInfo=r,this.user=Mi.UNAUTHENTICATED,this.clientId=io.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this._uninitializedComponentsProvider=s,this.authCredentials.start(n,(async e=>{Ui("FirestoreClient","Received user=",e.uid),await this.authCredentialListener(e),this.user=e})),this.appCheckCredentials.start(n,(e=>(Ui("FirestoreClient","Received new app check token=",e),this.appCheckCredentialListener(e,this.user))))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(e){this.authCredentialListener=e}setAppCheckTokenChangeListener(e){this.appCheckCredentialListener=e}terminate(){this.asyncQueue.enterRestrictedMode();const e=new Yi;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),e.resolve()}catch(t){const n=Xd(t,"Failed to shutdown persistence");e.reject(n)}})),e.promise}}async function jp(e,t){e.asyncQueue.verifyOperationInProgress(),Ui("FirestoreClient","Initializing OfflineComponentProvider");const n=e.configuration;await t.initialize(n);let r=n.initialUser;e.setCredentialChangeListener((async e=>{r.isEqual(e)||(await Hh(t.localStore,e),r=e)})),t.persistence.setDatabaseDeletedListener((()=>e.terminate())),e._offlineComponents=t}async function Gp(e,t){e.asyncQueue.verifyOperationInProgress();const n=await Hp(e);Ui("FirestoreClient","Initializing OnlineComponentProvider"),await t.initialize(n,e.configuration),e.setCredentialChangeListener((e=>jd(t.remoteStore,e))),e.setAppCheckTokenChangeListener(((e,n)=>jd(t.remoteStore,n))),e._onlineComponents=t}async function Hp(e){if(!e._offlineComponents)if(e._uninitializedComponentsProvider){Ui("FirestoreClient","Using user provided OfflineComponentProvider");try{await jp(e,e._uninitializedComponentsProvider._offline)}catch(t){const n=t;if(!function(e){return"FirebaseError"===e.name?e.code===Ki.FAILED_PRECONDITION||e.code===Ki.UNIMPLEMENTED:!("undefined"!=typeof DOMException&&e instanceof DOMException)||22===e.code||20===e.code||11===e.code}(n))throw n;Wi("Error using user provided cache. Falling back to memory cache: "+n),await jp(e,new zp)}}else Ui("FirestoreClient","Using default OfflineComponentProvider"),await jp(e,new Bp(void 0));return e._offlineComponents}async function qp(e){return e._onlineComponents||(e._uninitializedComponentsProvider?(Ui("FirestoreClient","Using user provided OnlineComponentProvider"),await Gp(e,e._uninitializedComponentsProvider._online)):(Ui("FirestoreClient","Using default OnlineComponentProvider"),await Gp(e,new Up))),e._onlineComponents}function Kp(e){return qp(e).then((e=>e.syncEngine))}async function Xp(e){const t=await qp(e),n=t.eventManager;return n.onListen=gp.bind(null,t.syncEngine),n.onUnlisten=wp.bind(null,t.syncEngine),n.onFirstRemoteStoreListen=yp.bind(null,t.syncEngine),n.onLastRemoteStoreUnlisten=xp.bind(null,t.syncEngine),n}function Yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new Yi;return e.asyncQueue.enqueueAndForget((async()=>function(e,t,n,r,s){const a=new Vp({next:n=>{a.Za(),t.enqueueAndForget((()=>rp(e,i))),n.fromCache&&"server"===r.source?s.reject(new Xi(Ki.UNAVAILABLE,'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')):s.resolve(n)},error:e=>s.reject(e)}),i=new up(n,a,{includeMetadataChanges:!0,_a:!0});return np(e,i)}(await Xp(e),e.asyncQueue,t,n,r))),r.promise}function Qp(e){const t={};return void 0!==e.timeoutSeconds&&(t.timeoutSeconds=e.timeoutSeconds),t}const Jp=new Map;function Zp(e,t,n){if(!n)throw new Xi(Ki.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)}function ef(e){if(!go.isDocumentKey(e))throw new Xi(Ki.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)}function tf(e){if(go.isDocumentKey(e))throw new Xi(Ki.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)}function nf(e){if(void 0===e)return"undefined";if(null===e)return"null";if("string"==typeof e)return e.length>20&&(e=`${e.substring(0,20)}...`),JSON.stringify(e);if("number"==typeof e||"boolean"==typeof e)return""+e;if("object"==typeof e){if(e instanceof Array)return"an array";{const t=function(e){return e.constructor?e.constructor.name:null}(e);return t?`a custom ${t} object`:"an object"}}return"function"==typeof e?"a function":Gi()}function rf(e,t){if("_delegate"in e&&(e=e._delegate),!(e instanceof t)){if(t.name===e.constructor.name)throw new Xi(Ki.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const n=nf(e);throw new Xi(Ki.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${n}`)}}return e}function sf(e,t){if(t<=0)throw new Xi(Ki.INVALID_ARGUMENT,`Function ${e}() requires a positive number, but it was: ${t}.`)}class af{constructor(e){var t,n;if(void 0===e.host){if(void 0!==e.ssl)throw new Xi(Ki.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host="firestore.googleapis.com",this.ssl=!0}else this.host=e.host,this.ssl=null===(t=e.ssl)||void 0===t||t;if(this.credentials=e.credentials,this.ignoreUndefinedProperties=!!e.ignoreUndefinedProperties,this.localCache=e.localCache,void 0===e.cacheSizeBytes)this.cacheSizeBytes=41943040;else{if(-1!==e.cacheSizeBytes&&e.cacheSizeBytes<1048576)throw new Xi(Ki.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=e.cacheSizeBytes}(function(e,t,n,r){if(!0===t&&!0===r)throw new Xi(Ki.INVALID_ARGUMENT,`${e} and ${n} cannot be used together.`)})("experimentalForceLongPolling",e.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",e.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!e.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:void 0===e.experimentalAutoDetectLongPolling?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!e.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=Qp(null!==(n=e.experimentalLongPollingOptions)&&void 0!==n?n:{}),function(e){if(void 0!==e.timeoutSeconds){if(isNaN(e.timeoutSeconds))throw new Xi(Ki.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);if(e.timeoutSeconds<5)throw new Xi(Ki.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);if(e.timeoutSeconds>30)throw new Xi(Ki.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)}}(this.experimentalLongPollingOptions),this.useFetchStreams=!!e.useFetchStreams}isEqual(e){return this.host===e.host&&this.ssl===e.ssl&&this.credentials===e.credentials&&this.cacheSizeBytes===e.cacheSizeBytes&&this.experimentalForceLongPolling===e.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===e.experimentalAutoDetectLongPolling&&function(e,t){return e.timeoutSeconds===t.timeoutSeconds}(this.experimentalLongPollingOptions,e.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===e.ignoreUndefinedProperties&&this.useFetchStreams===e.useFetchStreams}}class of{constructor(e,t,n,r){this._authCredentials=e,this._appCheckCredentials=t,this._databaseId=n,this._app=r,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new af({}),this._settingsFrozen=!1,this._terminateTask="notTerminated"}get app(){if(!this._app)throw new Xi(Ki.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return"notTerminated"!==this._terminateTask}_setSettings(e){if(this._settingsFrozen)throw new Xi(Ki.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new af(e),void 0!==e.credentials&&(this._authCredentials=function(e){if(!e)return new Ji;switch(e.type){case"firstParty":return new no(e.sessionIndex||"0",e.iamToken||null,e.authTokenFactory||null);case"provider":return e.client;default:throw new Xi(Ki.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}}(e.credentials))}_getSettings(){return this._settings}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return"notTerminated"===this._terminateTask&&(this._terminateTask=this._terminate()),this._terminateTask}async _restart(){"notTerminated"===this._terminateTask?await this._terminate():this._terminateTask="notTerminated"}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return function(e){const t=Jp.get(e);t&&(Ui("ComponentProvider","Removing Datastore"),Jp.delete(e),t.terminate())}(this),Promise.resolve()}}function lf(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};var s;const a=(e=rf(e,of))._getSettings(),i=`${t}:${n}`;if("firestore.googleapis.com"!==a.host&&a.host!==i&&Wi("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),e._setSettings(Object.assign(Object.assign({},a),{host:i,ssl:!1})),r.mockUserToken){let t,n;if("string"==typeof r.mockUserToken)t=r.mockUserToken,n=Mi.MOCK_USER;else{t=function(e,t){if(e.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const n=t||"demo-project",r=e.iat||0,s=e.sub||e.user_id;if(!s)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const a=Object.assign({iss:`https://securetoken.google.com/${n}`,aud:n,iat:r,exp:r+3600,auth_time:r,sub:s,user_id:s,firebase:{sign_in_provider:"custom",identities:{}}},e);return[at(JSON.stringify({alg:"none",type:"JWT"})),at(JSON.stringify(a)),""].join(".")}(r.mockUserToken,null===(s=e._app)||void 0===s?void 0:s.options.projectId);const a=r.mockUserToken.sub||r.mockUserToken.user_id;if(!a)throw new Xi(Ki.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");n=new Mi(a)}e._authCredentials=new Zi(new Qi(t,n))}}class uf{constructor(e,t,n){this.converter=t,this._query=n,this.type="query",this.firestore=e}withConverter(e){return new uf(this.firestore,e,this._query)}}class cf{constructor(e,t,n){this.converter=t,this._key=n,this.type="document",this.firestore=e}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new hf(this.firestore,this.converter,this._key.path.popLast())}withConverter(e){return new cf(this.firestore,e,this._key)}}class hf extends uf{constructor(e,t,n){super(e,t,nu(n)),this._path=n,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const e=this._path.popLast();return e.isEmpty()?null:new cf(this.firestore,null,new go(e))}withConverter(e){return new hf(this.firestore,e,this._path)}}function df(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),s=2;s<n;s++)r[s-2]=arguments[s];if(e=Nt(e),Zp("collection","path",t),e instanceof of){const n=po.fromString(t,...r);return tf(n),new hf(e,null,n)}{if(!(e instanceof cf||e instanceof hf))throw new Xi(Ki.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(po.fromString(t,...r));return tf(n),new hf(e.firestore,null,n)}}class pf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Promise.resolve();this.Pu=[],this.Iu=!1,this.Tu=[],this.Eu=null,this.du=!1,this.Au=!1,this.Ru=[],this.t_=new dd(this,"async_queue_retry"),this.Vu=()=>{const e=cd();e&&Ui("AsyncQueue","Visibility state changed to "+e.visibilityState),this.t_.jo()},this.mu=e;const t=cd();t&&"function"==typeof t.addEventListener&&t.addEventListener("visibilitychange",this.Vu)}get isShuttingDown(){return this.Iu}enqueueAndForget(e){this.enqueue(e)}enqueueAndForgetEvenWhileRestricted(e){this.fu(),this.gu(e)}enterRestrictedMode(e){if(!this.Iu){this.Iu=!0,this.Au=e||!1;const t=cd();t&&"function"==typeof t.removeEventListener&&t.removeEventListener("visibilitychange",this.Vu)}}enqueue(e){if(this.fu(),this.Iu)return new Promise((()=>{}));const t=new Yi;return this.gu((()=>this.Iu&&this.Au?Promise.resolve():(e().then(t.resolve,t.reject),t.promise))).then((()=>t.promise))}enqueueRetryable(e){this.enqueueAndForget((()=>(this.Pu.push(e),this.pu())))}async pu(){if(0!==this.Pu.length){try{await this.Pu[0](),this.Pu.shift(),this.t_.reset()}catch(t5){if(!Eo(t5))throw t5;Ui("AsyncQueue","Operation failed with retryable error: "+t5)}this.Pu.length>0&&this.t_.Go((()=>this.pu()))}}gu(e){const t=this.mu.then((()=>(this.du=!0,e().catch((e=>{this.Eu=e,this.du=!1;const t=function(e){let t=e.message||"";return e.stack&&(t=e.stack.includes(e.message)?e.stack:e.message+"\n"+e.stack),t}(e);throw Vi("INTERNAL UNHANDLED ERROR: ",t),e})).then((e=>(this.du=!1,e))))));return this.mu=t,t}enqueueAfterDelay(e,t,n){this.fu(),this.Ru.indexOf(e)>-1&&(t=0);const r=Kd.createAndSchedule(this,e,t,n,(e=>this.yu(e)));return this.Tu.push(r),r}fu(){this.Eu&&Gi()}verifyOperationInProgress(){}async wu(){let e;do{e=this.mu,await e}while(e!==this.mu)}Su(e){for(const t of this.Tu)if(t.timerId===e)return!0;return!1}bu(e){return this.wu().then((()=>{this.Tu.sort(((e,t)=>e.targetTimeMs-t.targetTimeMs));for(const t of this.Tu)if(t.skipDelay(),"all"!==e&&t.timerId===e)break;return this.wu()}))}Du(e){this.Ru.push(e)}yu(e){const t=this.Tu.indexOf(e);this.Tu.splice(t,1)}}class ff extends of{constructor(e,t,n,r){super(e,t,n,r),this.type="firestore",this._queue=new pf,this._persistenceKey=(null==r?void 0:r.name)||"[DEFAULT]"}async _terminate(){if(this._firestoreClient){const e=this._firestoreClient.terminate();this._queue=new pf(e),this._firestoreClient=void 0,await e}}}function mf(e){if(e._terminated)throw new Xi(Ki.FAILED_PRECONDITION,"The client has already been terminated.");return e._firestoreClient||gf(e),e._firestoreClient}function gf(e){var t,n,r;const s=e._freezeSettings(),a=function(e,t,n,r){return new rl(e,t,n,r.host,r.ssl,r.experimentalForceLongPolling,r.experimentalAutoDetectLongPolling,Qp(r.experimentalLongPollingOptions),r.useFetchStreams)}(e._databaseId,(null===(t=e._app)||void 0===t?void 0:t.options.appId)||"",e._persistenceKey,s);e._componentsProvider||(null===(n=s.localCache)||void 0===n?void 0:n._offlineComponentProvider)&&(null===(r=s.localCache)||void 0===r?void 0:r._onlineComponentProvider)&&(e._componentsProvider={_offline:s.localCache._offlineComponentProvider,_online:s.localCache._onlineComponentProvider}),e._firestoreClient=new Wp(e._authCredentials,e._appCheckCredentials,e._queue,a,e._componentsProvider&&function(e){const t=null==e?void 0:e._online.build();return{_offline:null==e?void 0:e._offline.build(t),_online:t}}(e._componentsProvider))}class yf{constructor(e){this._byteString=e}static fromBase64String(e){try{return new yf(Xo.fromBase64String(e))}catch(e){throw new Xi(Ki.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+e)}}static fromUint8Array(e){return new yf(Xo.fromUint8Array(e))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(e){return this._byteString.isEqual(e._byteString)}}class bf{constructor(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let r=0;r<t.length;++r)if(0===t[r].length)throw new Xi(Ki.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new mo(t)}isEqual(e){return this._internalPath.isEqual(e._internalPath)}}class vf{constructor(e){this._methodName=e}}class wf{constructor(e,t){if(!isFinite(e)||e<-90||e>90)throw new Xi(Ki.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+e);if(!isFinite(t)||t<-180||t>180)throw new Xi(Ki.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+t);this._lat=e,this._long=t}get latitude(){return this._lat}get longitude(){return this._long}isEqual(e){return this._lat===e._lat&&this._long===e._long}toJSON(){return{latitude:this._lat,longitude:this._long}}_compareTo(e){return oo(this._lat,e._lat)||oo(this._long,e._long)}}class xf{constructor(e){this._values=(e||[]).map((e=>e))}toArray(){return this._values.map((e=>e))}isEqual(e){return function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(this._values,e._values)}}const kf=/^__.*__$/;class Sf{constructor(e,t,n){this.data=e,this.fieldMask=t,this.fieldTransforms=n}toMutation(e,t){return null!==this.fieldMask?new rc(e,this.data,this.fieldMask,t,this.fieldTransforms):new nc(e,this.data,t,this.fieldTransforms)}}function If(e){switch(e){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw Gi()}}class Tf{constructor(e,t,n,r,s,a){this.settings=e,this.databaseId=t,this.serializer=n,this.ignoreUndefinedProperties=r,void 0===s&&this.vu(),this.fieldTransforms=s||[],this.fieldMask=a||[]}get path(){return this.settings.path}get Cu(){return this.settings.Cu}Fu(e){return new Tf(Object.assign(Object.assign({},this.settings),e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}Mu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Fu({path:n,xu:!1});return r.Ou(e),r}Nu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Fu({path:n,xu:!1});return r.vu(),r}Lu(e){return this.Fu({path:void 0,xu:!0})}Bu(e){return Pf(e,this.settings.methodName,this.settings.ku||!1,this.path,this.settings.qu)}contains(e){return void 0!==this.fieldMask.find((t=>e.isPrefixOf(t)))||void 0!==this.fieldTransforms.find((t=>e.isPrefixOf(t.field)))}vu(){if(this.path)for(let e=0;e<this.path.length;e++)this.Ou(this.path.get(e))}Ou(e){if(0===e.length)throw this.Bu("Document fields must not be empty");if(If(this.Cu)&&kf.test(e))throw this.Bu('Document fields cannot begin and end with "__"')}}class Nf{constructor(e,t,n){this.databaseId=e,this.ignoreUndefinedProperties=t,this.serializer=n||hd(e)}Qu(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return new Tf({Cu:e,methodName:t,qu:n,path:mo.emptyPath(),xu:!1,ku:r},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function Ef(e){const t=e._freezeSettings(),n=hd(e._databaseId);return new Nf(e._databaseId,!!t.ignoreUndefinedProperties,n)}function Cf(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=e.Qu(a.merge||a.mergeFields?2:0,t,n,s);Df("Data must be an object, but it was:",i,r);const o=$f(r,i);let l,u;if(a.merge)l=new qo(i.fieldMask),u=i.fieldTransforms;else if(a.mergeFields){const e=[];for(const r of a.mergeFields){const s=Ff(t,r,n);if(!i.contains(s))throw new Xi(Ki.INVALID_ARGUMENT,`Field '${s}' is specified in your field mask but missing from your input data.`);zf(e,s)||e.push(s)}l=new qo(e),u=i.fieldTransforms.filter((e=>l.covers(e.field)))}else l=null,u=i.fieldTransforms;return new Sf(new Il(o),l,u)}class _f extends vf{_toFieldTransform(e){return new Hu(e.path,new Pu)}isEqual(e){return e instanceof _f}}function Af(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return Rf(n,e.Qu(r?4:3,t))}function Rf(e,t){if(Of(e=Nt(e)))return Df("Unsupported field value:",t,e),$f(e,t);if(e instanceof vf)return function(e,t){if(!If(t.Cu))throw t.Bu(`${e._methodName}() can only be used with update() and set()`);if(!t.path)throw t.Bu(`${e._methodName}() is not currently supported inside arrays`);const n=e._toFieldTransform(t);n&&t.fieldTransforms.push(n)}(e,t),null;if(void 0===e&&t.ignoreUndefinedProperties)return null;if(t.path&&t.fieldMask.push(t.path),e instanceof Array){if(t.settings.xu&&4!==t.Cu)throw t.Bu("Nested arrays are not supported");return function(e,t){const n=[];let r=0;for(const s of e){let e=Rf(s,t.Lu(r));null==e&&(e={nullValue:"NULL_VALUE"}),n.push(e),r++}return{arrayValue:{values:n}}}(e,t)}return function(e,t){if(null===(e=Nt(e)))return{nullValue:"NULL_VALUE"};if("number"==typeof e)return Ou(t.serializer,e);if("boolean"==typeof e)return{booleanValue:e};if("string"==typeof e)return{stringValue:e};if(e instanceof Date){const n=uo.fromDate(e);return{timestampValue:Pc(t.serializer,n)}}if(e instanceof uo){const n=new uo(e.seconds,1e3*Math.floor(e.nanoseconds/1e3));return{timestampValue:Pc(t.serializer,n)}}if(e instanceof wf)return{geoPointValue:{latitude:e.latitude,longitude:e.longitude}};if(e instanceof yf)return{bytesValue:zc(t.serializer,e._byteString)};if(e instanceof cf){const n=t.databaseId,r=e.firestore._databaseId;if(!r.isEqual(n))throw t.Bu(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);return{referenceValue:Vc(e.firestore._databaseId||t.databaseId,e._key.path)}}if(e instanceof xf)return function(e,t){return{mapValue:{fields:{__type__:{stringValue:"__vector__"},value:{arrayValue:{values:e.toArray().map((e=>{if("number"!=typeof e)throw t.Bu("VectorValues must only contain numeric values.");return Ru(t.serializer,e)}))}}}}}}(e,t);throw t.Bu(`Unsupported field value: ${nf(e)}`)}(e,t)}function $f(e,t){const n={};return Uo(e)?t.path&&t.path.length>0&&t.fieldMask.push(t.path):Bo(e,((e,r)=>{const s=Rf(r,t.Mu(e));null!=s&&(n[e]=s)})),{mapValue:{fields:n}}}function Of(e){return!("object"!=typeof e||null===e||e instanceof Array||e instanceof Date||e instanceof uo||e instanceof wf||e instanceof yf||e instanceof cf||e instanceof vf||e instanceof xf)}function Df(e,t,n){if(!Of(n)||!function(e){return"object"==typeof e&&null!==e&&(Object.getPrototypeOf(e)===Object.prototype||null===Object.getPrototypeOf(e))}(n)){const r=nf(n);throw"an object"===r?t.Bu(e+" a custom object"):t.Bu(e+" "+r)}}function Ff(e,t,n){if((t=Nt(t))instanceof bf)return t._internalPath;if("string"==typeof t)return Mf(e,t);throw Pf("Field path arguments must be of type string or ",e,!1,void 0,n)}const Lf=new RegExp("[~\\*/\\[\\]]");function Mf(e,t,n){if(t.search(Lf)>=0)throw Pf(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,e,!1,void 0,n);try{return new bf(...t.split("."))._internalPath}catch(r){throw Pf(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,e,!1,void 0,n)}}function Pf(e,t,n,r,s){const a=r&&!r.isEmpty(),i=void 0!==s;let o=`Function ${t}() called with invalid data`;n&&(o+=" (via `toFirestore()`)"),o+=". ";let l="";return(a||i)&&(l+=" (found",a&&(l+=` in field ${r}`),i&&(l+=` in document ${s}`),l+=")"),new Xi(Ki.INVALID_ARGUMENT,o+e+l)}function zf(e,t){return e.some((e=>e.isEqual(t)))}class Bf{constructor(e,t,n,r,s){this._firestore=e,this._userDataWriter=t,this._key=n,this._document=r,this._converter=s}get id(){return this._key.path.lastSegment()}get ref(){return new cf(this._firestore,this._converter,this._key)}exists(){return null!==this._document}data(){if(this._document){if(this._converter){const e=new Uf(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(e)}return this._userDataWriter.convertValue(this._document.data.value)}}get(e){if(this._document){const t=this._document.data.field(Vf("DocumentSnapshot.get",e));if(null!==t)return this._userDataWriter.convertValue(t)}}}class Uf extends Bf{data(){return super.data()}}function Vf(e,t){return"string"==typeof t?Mf(e,t):t instanceof bf?t._internalPath:t._delegate._internalPath}function Wf(e){if("L"===e.limitType&&0===e.explicitOrderBy.length)throw new Xi(Ki.UNIMPLEMENTED,"limitToLast() queries require specifying at least one orderBy() clause")}class jf{}class Gf extends jf{}class Hf extends Gf{constructor(e,t,n){super(),this._field=e,this._op=t,this._value=n,this.type="where"}static _create(e,t,n){return new Hf(e,t,n)}_apply(e){const t=this._parse(e);return Jf(e._query,t),new uf(e.firestore,e.converter,lu(e._query,t))}_parse(e){const t=Ef(e.firestore),n=function(e,t,n,r,s,a,i){let o;if(s.isKeyField()){if("array-contains"===a||"array-contains-any"===a)throw new Xi(Ki.INVALID_ARGUMENT,`Invalid Query. You can't perform '${a}' queries on documentId().`);if("in"===a||"not-in"===a){Qf(i,a);const t=[];for(const n of i)t.push(Yf(r,e,n));o={arrayValue:{values:t}}}else o=Yf(r,e,i)}else"in"!==a&&"not-in"!==a&&"array-contains-any"!==a||Qf(i,a),o=Af(n,t,i,"in"===a||"not-in"===a);return Ol.create(s,a,o)}(e._query,"where",t,e.firestore._databaseId,this._field,this._op,this._value);return n}}class qf extends jf{constructor(e,t){super(),this.type=e,this._queryConstraints=t}static _create(e,t){return new qf(e,t)}_parse(e){const t=this._queryConstraints.map((t=>t._parse(e))).filter((e=>e.getFilters().length>0));return 1===t.length?t[0]:Dl.create(t,this._getOperator())}_apply(e){const t=this._parse(e);return 0===t.getFilters().length?e:(function(e,t){let n=e;const r=t.getFlattenedFilters();for(const s of r)Jf(n,s),n=lu(n,s)}(e._query,t),new uf(e.firestore,e.converter,lu(e._query,t)))}_getQueryConstraints(){return this._queryConstraints}_getOperator(){return"and"===this.type?"and":"or"}}class Kf extends Gf{constructor(e,t){super(),this._field=e,this._direction=t,this.type="orderBy"}static _create(e,t){return new Kf(e,t)}_apply(e){const t=function(e,t,n){if(null!==e.startAt)throw new Xi(Ki.INVALID_ARGUMENT,"Invalid query. You must not call startAt() or startAfter() before calling orderBy().");if(null!==e.endAt)throw new Xi(Ki.INVALID_ARGUMENT,"Invalid query. You must not call endAt() or endBefore() before calling orderBy().");return new Al(t,n)}(e._query,this._field,this._direction);return new uf(e.firestore,e.converter,function(e,t){const n=e.explicitOrderBy.concat([t]);return new eu(e.path,e.collectionGroup,n,e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)}(e._query,t))}}class Xf extends Gf{constructor(e,t,n){super(),this.type=e,this._limit=t,this._limitType=n}static _create(e,t,n){return new Xf(e,t,n)}_apply(e){return new uf(e.firestore,e.converter,uu(e._query,this._limit,this._limitType))}}function Yf(e,t,n){if("string"==typeof(n=Nt(n))){if(""===n)throw new Xi(Ki.INVALID_ARGUMENT,"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");if(!su(t)&&-1!==n.indexOf("/"))throw new Xi(Ki.INVALID_ARGUMENT,`Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);const r=t.path.child(po.fromString(n));if(!go.isDocumentKey(r))throw new Xi(Ki.INVALID_ARGUMENT,`Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);return ml(e,new go(r))}if(n instanceof cf)return ml(e,n._key);throw new Xi(Ki.INVALID_ARGUMENT,`Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${nf(n)}.`)}function Qf(e,t){if(!Array.isArray(e)||0===e.length)throw new Xi(Ki.INVALID_ARGUMENT,`Invalid Query. A non-empty array is required for '${t.toString()}' filters.`)}function Jf(e,t){const n=function(e,t){for(const n of e)for(const e of n.getFlattenedFilters())if(t.indexOf(e.op)>=0)return e.op;return null}(e.filters,function(e){switch(e){case"!=":return["!=","not-in"];case"array-contains-any":case"in":return["not-in"];case"not-in":return["array-contains-any","in","not-in","!="];default:return[]}}(t.op));if(null!==n)throw n===t.op?new Xi(Ki.INVALID_ARGUMENT,`Invalid query. You cannot use more than one '${t.op.toString()}' filter.`):new Xi(Ki.INVALID_ARGUMENT,`Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`)}class Zf{convertValue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";switch(il(e)){case 0:return null;case 1:return e.booleanValue;case 2:return Jo(e.integerValue||e.doubleValue);case 3:return this.convertTimestamp(e.timestampValue);case 4:return this.convertServerTimestamp(e,t);case 5:return e.stringValue;case 6:return this.convertBytes(Zo(e.bytesValue));case 7:return this.convertReference(e.referenceValue);case 8:return this.convertGeoPoint(e.geoPointValue);case 9:return this.convertArray(e.arrayValue,t);case 11:return this.convertObject(e.mapValue,t);case 10:return this.convertVectorValue(e.mapValue);default:throw Gi()}}convertObject(e,t){return this.convertObjectMap(e.fields,t)}convertObjectMap(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";const n={};return Bo(e,((e,r)=>{n[e]=this.convertValue(r,t)})),n}convertVectorValue(e){var t,n,r;const s=null===(r=null===(n=null===(t=e.fields)||void 0===t?void 0:t.value.arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.map((e=>Jo(e.doubleValue)));return new xf(s)}convertGeoPoint(e){return new wf(Jo(e.latitude),Jo(e.longitude))}convertArray(e,t){return(e.values||[]).map((e=>this.convertValue(e,t)))}convertServerTimestamp(e,t){switch(t){case"previous":const n=tl(e);return null==n?null:this.convertValue(n,t);case"estimate":return this.convertTimestamp(nl(e));default:return null}}convertTimestamp(e){const t=Qo(e);return new uo(t.seconds,t.nanos)}convertDocumentKey(e,t){const n=po.fromString(e);Hi(ch(n));const r=new sl(n.get(1),n.get(3)),s=new go(n.popFirst(5));return r.isEqual(t)||Vi(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),s}}function em(e,t,n){let r;return r=e?n&&(n.merge||n.mergeFields)?e.toFirestore(t,n):e.toFirestore(t):t,r}class tm{constructor(e,t){this.hasPendingWrites=e,this.fromCache=t}isEqual(e){return this.hasPendingWrites===e.hasPendingWrites&&this.fromCache===e.fromCache}}class nm extends Bf{constructor(e,t,n,r,s,a){super(e,t,n,r,a),this._firestore=e,this._firestoreImpl=e,this.metadata=s}exists(){return super.exists()}data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._document){if(this._converter){const t=new rm(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(t,e)}return this._userDataWriter.convertValue(this._document.data.value,e.serverTimestamps)}}get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._document){const n=this._document.data.field(Vf("DocumentSnapshot.get",e));if(null!==n)return this._userDataWriter.convertValue(n,t.serverTimestamps)}}}class rm extends nm{data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return super.data(e)}}class sm{constructor(e,t,n,r){this._firestore=e,this._userDataWriter=t,this._snapshot=r,this.metadata=new tm(r.hasPendingWrites,r.fromCache),this.query=n}get docs(){const e=[];return this.forEach((t=>e.push(t))),e}get size(){return this._snapshot.docs.size}get empty(){return 0===this.size}forEach(e,t){this._snapshot.docs.forEach((n=>{e.call(t,new rm(this._firestore,this._userDataWriter,n.key,n,new tm(this._snapshot.mutatedKeys.has(n.key),this._snapshot.fromCache),this.query.converter))}))}docChanges(){const e=!!(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).includeMetadataChanges;if(e&&this._snapshot.excludesMetadataChanges)throw new Xi(Ki.INVALID_ARGUMENT,"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");return this._cachedChanges&&this._cachedChangesIncludeMetadataChanges===e||(this._cachedChanges=function(e,t){if(e._snapshot.oldDocs.isEmpty()){let t=0;return e._snapshot.docChanges.map((n=>{const r=new rm(e._firestore,e._userDataWriter,n.doc.key,n.doc,new tm(e._snapshot.mutatedKeys.has(n.doc.key),e._snapshot.fromCache),e.query.converter);return n.doc,{type:"added",doc:r,oldIndex:-1,newIndex:t++}}))}{let n=e._snapshot.oldDocs;return e._snapshot.docChanges.filter((e=>t||3!==e.type)).map((t=>{const r=new rm(e._firestore,e._userDataWriter,t.doc.key,t.doc,new tm(e._snapshot.mutatedKeys.has(t.doc.key),e._snapshot.fromCache),e.query.converter);let s=-1,a=-1;return 0!==t.type&&(s=n.indexOf(t.doc.key),n=n.delete(t.doc.key)),1!==t.type&&(n=n.add(t.doc),a=n.indexOf(t.doc.key)),{type:am(t.type),doc:r,oldIndex:s,newIndex:a}}))}}(this,e),this._cachedChangesIncludeMetadataChanges=e),this._cachedChanges}}function am(e){switch(e){case 0:return"added";case 2:case 3:return"modified";case 1:return"removed";default:return Gi()}}class im extends Zf{constructor(e){super(),this.firestore=e}convertBytes(e){return new yf(e)}convertReference(e){const t=this.convertDocumentKey(e,this.firestore._databaseId);return new cf(this.firestore,null,t)}}function om(e,t){const n=rf(e.firestore,ff),r=function(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),s=2;s<n;s++)r[s-2]=arguments[s];if(e=Nt(e),1===arguments.length&&(t=io.newId()),Zp("doc","path",t),e instanceof of){const n=po.fromString(t,...r);return ef(n),new cf(e,null,new go(n))}{if(!(e instanceof cf||e instanceof hf))throw new Xi(Ki.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(po.fromString(t,...r));return ef(n),new cf(e.firestore,e instanceof hf?e.converter:null,new go(n))}}(e),s=em(e.converter,t);return lm(n,[Cf(Ef(e.firestore),"addDoc",r._key,s,null!==e.converter,{}).toMutation(r._key,Ku.exists(!1))]).then((()=>r))}function lm(e,t){return function(e,t){const n=new Yi;return e.asyncQueue.enqueueAndForget((async()=>async function(e,t,n){const r=Pp(e);try{const e=await function(e,t){const n=qi(e),r=uo.now(),s=t.reduce(((e,t)=>e.add(t.key)),Cu());let a,i;return n.persistence.runTransaction("Locally write mutations","readwrite",(e=>{let o=vu(),l=Cu();return n.cs.getEntries(e,s).next((e=>{o=e,o.forEach(((e,t)=>{t.isValidDocument()||(l=l.add(e))}))})).next((()=>n.localDocuments.getOverlayedDocuments(e,o))).next((s=>{a=s;const i=[];for(const e of t){const t=ec(e,a.get(e.key).overlayedDocument);null!=t&&i.push(new rc(e.key,t,Tl(t.value.mapValue),Ku.exists(!0)))}return n.mutationQueue.addMutationBatch(e,r,i,t)})).next((t=>{i=t;const r=t.applyToLocalDocumentSet(a,l);return n.documentOverlayCache.saveOverlays(e,t.batchId,r)}))})).then((()=>({batchId:i.batchId,changes:ku(a)})))}(r.localStore,t);r.sharedClientState.addPendingMutation(e.batchId),function(e,t,n){let r=e.Ba[e.currentUser.toKey()];r||(r=new Vo(oo)),r=r.insert(t,n),e.Ba[e.currentUser.toKey()]=r}(r,e.batchId,n),await Dp(r,e.changes),await Fd(r.remoteStore)}catch(e){const t=Xd(e,"Failed to persist write");n.reject(t)}}(await Kp(e),t,n))),n.promise}(mf(e),t)}function um(){return new _f("serverTimestamp")}new WeakMap;!function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!function(e){Pi=e}(Vn),Mn(new Et("firestore",((e,n)=>{let{instanceIdentifier:r,options:s}=n;const a=e.getProvider("app").getImmediate(),i=new ff(new eo(e.getProvider("auth-internal")),new so(e.getProvider("app-check-internal")),function(e,t){if(!Object.prototype.hasOwnProperty.apply(e.options,["projectId"]))throw new Xi(Ki.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new sl(e.options.projectId,t)}(a,r),a);return s=Object.assign({useFetchStreams:t},s),i._setSettings(s),i}),"PUBLIC").setMultipleInstances(!0)),Gn(Li,"4.7.4",e),Gn(Li,"4.7.4","esm2017")}();const cm=Wn({apiKey:"AIzaSyA8vD4MJ8xAKJVPFzTy68nZT47GD_e3oiI",authDomain:"globetalk-d37c8.firebaseapp.com",projectId:"globetalk-d37c8",storageBucket:"globetalk-d37c8.appspot.com",messagingSenderId:"832165372977",appId:"G-8HX5HB0C7B"}),hm=function(e,t){const n="string"==typeof e?e:t||"(default)",r=Pn("object"==typeof e?e:jn(),"firestore").getImmediate({identifier:n});if(!r._initialized){const e=(e=>{const t=ut(e);if(!t)return;const n=t.lastIndexOf(":");if(n<=0||n+1===t.length)throw new Error(`Invalid host ${t} with no separate hostname and port!`);const r=parseInt(t.substring(n+1),10);return"["===t[0]?[t.substring(1,n-1),r]:[t.substring(0,n),r]})("firestore");e&&lf(r,...e)}return r}(cm),dm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:jn();const t=Pn(e,"auth");if(t.isInitialized())return t.getImmediate();const n=function(e,t){const n=Pn(e,"auth");if(n.isInitialized()){const e=n.getImmediate();if(vt(n.getOptions(),null!==t&&void 0!==t?t:{}))return e;lr(e,"already-initialized")}return n.initialize({options:t})}(e,{popupRedirectResolver:mi,persistence:[Ta,la,ca]}),r=ht("authTokenSyncURL");if(r&&"boolean"===typeof isSecureContext&&isSecureContext){const e=new URL(r,location.origin);if(location.origin===e.origin){const t=(s=e.toString(),async e=>{const t=e&&await e.getIdTokenResult(),n=t&&((new Date).getTime()-Date.parse(t.issuedAtTime))/1e3;if(n&&n>vi)return;const r=null===t||void 0===t?void 0:t.token;wi!==r&&(wi=r,await fetch(s,{method:r?"POST":"DELETE",headers:r?{Authorization:`Bearer ${r}`}:{}}))});!function(e,t,n){Nt(e).beforeAuthStateChanged(t,n)}(n,t,(()=>t(n.currentUser))),function(e,t,n,r){Nt(e).onIdTokenChanged(t,n,r)}(n,(e=>t(e)))}}var s;const a=ut("auth");return a&&Cs(n,`http://${a}`),n}(cm),pm={colors:{primary:"#3b82f6",secondary:"#64748b",background:"#f8fafc",surface:"#ffffff",surfaceHover:"#f1f5f9",text:{primary:"#1e293b",secondary:"#64748b",light:"#94a3b8"},error:"#ef4444",success:"#22c55e",border:"#e2e8f0"},spacing:{xs:"4px",sm:"8px",md:"16px",lg:"24px",xl:"32px",xxl:"48px"},borderRadius:{sm:"4px",md:"8px",lg:"12px",xl:"16px"},shadows:{sm:"0 1px 2px rgba(0, 0, 0, 0.05)",md:"0 4px 6px rgba(0, 0, 0, 0.05)",lg:"0 10px 15px rgba(0, 0, 0, 0.05)"},typography:{fontFamily:"'Inter', -apple-system, sans-serif",sizes:{sm:"0.875rem",base:"1rem",lg:"1.125rem",xl:"1.25rem","2xl":"1.5rem"}}};var fm=n(8693),mm=n(579);const gm=(0,fm.A)((0,mm.jsx)("path",{d:"M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2m0 4-8 5-8-5V6l8 5 8-5z"}),"Email"),ym=(0,fm.A)((0,mm.jsx)("path",{d:"M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2m3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1z"}),"Lock"),bm=(0,fm.A)((0,mm.jsx)("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"}),"Error");const vm={container:{minHeight:"100vh",display:"flex",alignItems:"center",justifyContent:"center",padding:pm.spacing.xl,backgroundColor:pm.colors.background,animation:"fadeIn 0.5s ease forwards"},card:{width:"100%",maxWidth:"400px",backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,boxShadow:pm.shadows.lg,padding:pm.spacing.xxl,animation:"slideUp 0.5s ease forwards"},title:{fontSize:pm.typography.sizes["2xl"],fontWeight:"600",color:pm.colors.text.primary,textAlign:"center",marginBottom:pm.spacing.sm},subtitle:{fontSize:pm.typography.sizes.base,color:pm.colors.text.secondary,textAlign:"center",marginBottom:pm.spacing.xl},form:{display:"flex",flexDirection:"column",gap:pm.spacing.lg},inputGroup:{position:"relative",animation:"slideRight 0.5s ease forwards",animationDelay:"calc(var(--index) * 100ms)"},inputIcon:{position:"absolute",left:pm.spacing.md,top:"50%",transform:"translateY(-50%)",color:pm.colors.text.secondary,fontSize:"20px"},input:{width:"85%",padding:`${pm.spacing.md} ${pm.spacing.md} ${pm.spacing.md} ${pm.spacing.xxl}`,fontSize:pm.typography.sizes.base,border:`1px solid ${pm.colors.border}`,borderRadius:pm.borderRadius.md,outline:"none",transition:"border-color 0.2s ease","&:focus":{borderColor:pm.colors.primary}},button:{width:"100%",padding:pm.spacing.md,backgroundColor:pm.colors.primary,color:pm.colors.surface,border:"none",borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.base,fontWeight:"500",cursor:"pointer",transition:"all 0.2s ease",animation:"slideUp 0.5s ease forwards",animationDelay:"0.2s","&:hover":{backgroundColor:pm.colors.primary+"dd",transform:"translateY(-1px)"}},error:{display:"flex",alignItems:"center",gap:pm.spacing.sm,padding:pm.spacing.md,backgroundColor:`${pm.colors.error}10`,color:pm.colors.error,borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.sm},errorIcon:{fontSize:"20px"},signupPrompt:{display:"flex",justifyContent:"center",alignItems:"center",gap:pm.spacing.sm,marginTop:pm.spacing.md,animation:"fadeIn 0.5s ease forwards",animationDelay:"0.4s"},textButton:{background:"none",border:"none",color:pm.colors.primary,cursor:"pointer",fontSize:pm.typography.sizes.base,padding:0,transition:"color 0.2s ease","&:hover":{color:pm.colors.primary+"dd",textDecoration:"underline"}}},wm=function(e){let{onLogin:t,onToggleForm:n}=e;const[r,s]=(0,_.useState)(""),[a,i]=(0,_.useState)(""),[o,l]=(0,_.useState)("");return(0,mm.jsx)("div",{style:vm.container,children:(0,mm.jsxs)("div",{style:vm.card,children:[(0,mm.jsx)("h1",{style:vm.title,children:"Welcome Back"}),(0,mm.jsx)("p",{style:vm.subtitle,children:"Sign in to continue to Translator"}),(0,mm.jsxs)("form",{onSubmit:async e=>{e.preventDefault();try{const e=await function(e,t,n){return zn(e.app)?Promise.reject(hr(e)):na(Nt(e),Us.credential(t,n)).catch((async t=>{throw"auth/password-does-not-meet-requirements"===t.code&&ra(e),t}))}(dm,r,a);t(e.user)}catch(n){l(n.message)}},style:vm.form,children:[(0,mm.jsxs)("div",{style:vm.inputGroup,children:[(0,mm.jsx)(gm,{style:vm.inputIcon}),(0,mm.jsx)("input",{type:"email",placeholder:"Email",value:r,onChange:e=>s(e.target.value),required:!0,style:vm.input})]}),(0,mm.jsxs)("div",{style:vm.inputGroup,children:[(0,mm.jsx)(ym,{style:vm.inputIcon}),(0,mm.jsx)("input",{type:"password",placeholder:"Password",value:a,onChange:e=>i(e.target.value),required:!0,style:vm.input})]}),o&&(0,mm.jsxs)("div",{style:vm.error,children:[(0,mm.jsx)(bm,{style:vm.errorIcon}),o]}),(0,mm.jsx)("button",{type:"submit",style:vm.button,children:"Sign In"}),(0,mm.jsxs)("div",{style:vm.signupPrompt,children:[(0,mm.jsx)("span",{children:"Don't have an account? "}),(0,mm.jsx)("button",{onClick:()=>n("signup"),style:vm.textButton,children:"Sign up"})]})]})]})})};function xm(e,t){return function(){return e.apply(t,arguments)}}const{toString:km}=Object.prototype,{getPrototypeOf:Sm}=Object,Im=(Tm=Object.create(null),e=>{const t=km.call(e);return Tm[t]||(Tm[t]=t.slice(8,-1).toLowerCase())});var Tm;const Nm=e=>(e=e.toLowerCase(),t=>Im(t)===e),Em=e=>t=>typeof t===e,{isArray:Cm}=Array,_m=Em("undefined");const Am=Nm("ArrayBuffer");const Rm=Em("string"),$m=Em("function"),Om=Em("number"),Dm=e=>null!==e&&"object"===typeof e,Fm=e=>{if("object"!==Im(e))return!1;const t=Sm(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},Lm=Nm("Date"),Mm=Nm("File"),Pm=Nm("Blob"),zm=Nm("FileList"),Bm=Nm("URLSearchParams"),[Um,Vm,Wm,jm]=["ReadableStream","Request","Response","Headers"].map(Nm);function Gm(e,t){let n,r,{allOwnKeys:s=!1}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(null!==e&&"undefined"!==typeof e)if("object"!==typeof e&&(e=[e]),Cm(e))for(n=0,r=e.length;n<r;n++)t.call(null,e[n],n,e);else{const r=s?Object.getOwnPropertyNames(e):Object.keys(e),a=r.length;let i;for(n=0;n<a;n++)i=r[n],t.call(null,e[i],i,e)}}function Hm(e,t){t=t.toLowerCase();const n=Object.keys(e);let r,s=n.length;for(;s-- >0;)if(r=n[s],t===r.toLowerCase())return r;return null}const qm="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:global,Km=e=>!_m(e)&&e!==qm;const Xm=(Ym="undefined"!==typeof Uint8Array&&Sm(Uint8Array),e=>Ym&&e instanceof Ym);var Ym;const Qm=Nm("HTMLFormElement"),Jm=(e=>{let{hasOwnProperty:t}=e;return(e,n)=>t.call(e,n)})(Object.prototype),Zm=Nm("RegExp"),eg=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};Gm(n,((n,s)=>{let a;!1!==(a=t(n,s,e))&&(r[s]=a||n)})),Object.defineProperties(e,r)},tg="abcdefghijklmnopqrstuvwxyz",ng="0123456789",rg={DIGIT:ng,ALPHA:tg,ALPHA_DIGIT:tg+tg.toUpperCase()+ng};const sg=Nm("AsyncFunction"),ag=(ig="function"===typeof setImmediate,og=$m(qm.postMessage),ig?setImmediate:og?((e,t)=>(qm.addEventListener("message",(n=>{let{source:r,data:s}=n;r===qm&&s===e&&t.length&&t.shift()()}),!1),n=>{t.push(n),qm.postMessage(e,"*")}))(`axios@${Math.random()}`,[]):e=>setTimeout(e));var ig,og;const lg="undefined"!==typeof queueMicrotask?queueMicrotask.bind(qm):"undefined"!==typeof process&&process.nextTick||ag,ug={isArray:Cm,isArrayBuffer:Am,isBuffer:function(e){return null!==e&&!_m(e)&&null!==e.constructor&&!_m(e.constructor)&&$m(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:e=>{let t;return e&&("function"===typeof FormData&&e instanceof FormData||$m(e.append)&&("formdata"===(t=Im(e))||"object"===t&&$m(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){let t;return t="undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&Am(e.buffer),t},isString:Rm,isNumber:Om,isBoolean:e=>!0===e||!1===e,isObject:Dm,isPlainObject:Fm,isReadableStream:Um,isRequest:Vm,isResponse:Wm,isHeaders:jm,isUndefined:_m,isDate:Lm,isFile:Mm,isBlob:Pm,isRegExp:Zm,isFunction:$m,isStream:e=>Dm(e)&&$m(e.pipe),isURLSearchParams:Bm,isTypedArray:Xm,isFileList:zm,forEach:Gm,merge:function e(){const{caseless:t}=Km(this)&&this||{},n={},r=(r,s)=>{const a=t&&Hm(n,s)||s;Fm(n[a])&&Fm(r)?n[a]=e(n[a],r):Fm(r)?n[a]=e({},r):Cm(r)?n[a]=r.slice():n[a]=r};for(let s=0,a=arguments.length;s<a;s++)arguments[s]&&Gm(arguments[s],r);return n},extend:function(e,t,n){let{allOwnKeys:r}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return Gm(t,((t,r)=>{n&&$m(t)?e[r]=xm(t,n):e[r]=t}),{allOwnKeys:r}),e},trim:e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),inherits:(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:(e,t,n,r)=>{let s,a,i;const o={};if(t=t||{},null==e)return t;do{for(s=Object.getOwnPropertyNames(e),a=s.length;a-- >0;)i=s[a],r&&!r(i,e,t)||o[i]||(t[i]=e[i],o[i]=!0);e=!1!==n&&Sm(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:Im,kindOfTest:Nm,endsWith:(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},toArray:e=>{if(!e)return null;if(Cm(e))return e;let t=e.length;if(!Om(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},forEachEntry:(e,t)=>{const n=(e&&e[Symbol.iterator]).call(e);let r;for(;(r=n.next())&&!r.done;){const n=r.value;t.call(e,n[0],n[1])}},matchAll:(e,t)=>{let n;const r=[];for(;null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:Qm,hasOwnProperty:Jm,hasOwnProp:Jm,reduceDescriptors:eg,freezeMethods:e=>{eg(e,((t,n)=>{if($m(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];$m(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return Cm(e)?r(e):r(String(e).split(t)),n},toCamelCase:e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(e,t)=>null!=e&&Number.isFinite(e=+e)?e:t,findKey:Hm,global:qm,isContextDefined:Km,ALPHABET:rg,generateString:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:16,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:rg.ALPHA_DIGIT,n="";const{length:r}=t;for(;e--;)n+=t[Math.random()*r|0];return n},isSpecCompliantForm:function(e){return!!(e&&$m(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:e=>{const t=new Array(10),n=(e,r)=>{if(Dm(e)){if(t.indexOf(e)>=0)return;if(!("toJSON"in e)){t[r]=e;const s=Cm(e)?[]:{};return Gm(e,((e,t)=>{const a=n(e,r+1);!_m(a)&&(s[t]=a)})),t[r]=void 0,s}}return e};return n(e,0)},isAsyncFn:sg,isThenable:e=>e&&(Dm(e)||$m(e))&&$m(e.then)&&$m(e.catch),setImmediate:ag,asap:lg};function cg(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s,this.status=s.status?s.status:null)}ug.inherits(cg,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:ug.toJSONObject(this.config),code:this.code,status:this.status}}});const hg=cg.prototype,dg={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{dg[e]={value:e}})),Object.defineProperties(cg,dg),Object.defineProperty(hg,"isAxiosError",{value:!0}),cg.from=(e,t,n,r,s,a)=>{const i=Object.create(hg);return ug.toFlatObject(e,i,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),cg.call(i,e.message,t,n,r,s),i.cause=e,i.name=e.name,a&&Object.assign(i,a),i};const pg=cg;function fg(e){return ug.isPlainObject(e)||ug.isArray(e)}function mg(e){return ug.endsWith(e,"[]")?e.slice(0,-2):e}function gg(e,t,n){return e?e.concat(t).map((function(e,t){return e=mg(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}const yg=ug.toFlatObject(ug,{},null,(function(e){return/^is[A-Z]/.test(e)}));const bg=function(e,t,n){if(!ug.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;const r=(n=ug.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!ug.isUndefined(t[e])}))).metaTokens,s=n.visitor||u,a=n.dots,i=n.indexes,o=(n.Blob||"undefined"!==typeof Blob&&Blob)&&ug.isSpecCompliantForm(t);if(!ug.isFunction(s))throw new TypeError("visitor must be a function");function l(e){if(null===e)return"";if(ug.isDate(e))return e.toISOString();if(!o&&ug.isBlob(e))throw new pg("Blob is not supported. Use a Buffer instead.");return ug.isArrayBuffer(e)||ug.isTypedArray(e)?o&&"function"===typeof Blob?new Blob([e]):Buffer.from(e):e}function u(e,n,s){let o=e;if(e&&!s&&"object"===typeof e)if(ug.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if(ug.isArray(e)&&function(e){return ug.isArray(e)&&!e.some(fg)}(e)||(ug.isFileList(e)||ug.endsWith(n,"[]"))&&(o=ug.toArray(e)))return n=mg(n),o.forEach((function(e,r){!ug.isUndefined(e)&&null!==e&&t.append(!0===i?gg([n],r,a):null===i?n:n+"[]",l(e))})),!1;return!!fg(e)||(t.append(gg(s,n,a),l(e)),!1)}const c=[],h=Object.assign(yg,{defaultVisitor:u,convertValue:l,isVisitable:fg});if(!ug.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!ug.isUndefined(n)){if(-1!==c.indexOf(n))throw Error("Circular reference detected in "+r.join("."));c.push(n),ug.forEach(n,(function(n,a){!0===(!(ug.isUndefined(n)||null===n)&&s.call(t,n,ug.isString(a)?a.trim():a,r,h))&&e(n,r?r.concat(a):[a])})),c.pop()}}(e),t};function vg(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function wg(e,t){this._pairs=[],e&&bg(e,this,t)}const xg=wg.prototype;xg.append=function(e,t){this._pairs.push([e,t])},xg.toString=function(e){const t=e?function(t){return e.call(this,t,vg)}:vg;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};const kg=wg;function Sg(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function Ig(e,t,n){if(!t)return e;const r=n&&n.encode||Sg,s=n&&n.serialize;let a;if(a=s?s(t,n):ug.isURLSearchParams(t)?t.toString():new kg(t,n).toString(r),a){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+a}return e}const Tg=class{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){ug.forEach(this.handlers,(function(t){null!==t&&e(t)}))}},Ng={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},Eg={isBrowser:!0,classes:{URLSearchParams:"undefined"!==typeof URLSearchParams?URLSearchParams:kg,FormData:"undefined"!==typeof FormData?FormData:null,Blob:"undefined"!==typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},Cg="undefined"!==typeof window&&"undefined"!==typeof document,_g="object"===typeof navigator&&navigator||void 0,Ag=Cg&&(!_g||["ReactNative","NativeScript","NS"].indexOf(_g.product)<0),Rg="undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"===typeof self.importScripts,$g=Cg&&window.location.href||"http://localhost",Og={...e,...Eg};const Dg=function(e){function t(e,n,r,s){let a=e[s++];if("__proto__"===a)return!0;const i=Number.isFinite(+a),o=s>=e.length;if(a=!a&&ug.isArray(r)?r.length:a,o)return ug.hasOwnProp(r,a)?r[a]=[r[a],n]:r[a]=n,!i;r[a]&&ug.isObject(r[a])||(r[a]=[]);return t(e,n,r[a],s)&&ug.isArray(r[a])&&(r[a]=function(e){const t={},n=Object.keys(e);let r;const s=n.length;let a;for(r=0;r<s;r++)a=n[r],t[a]=e[a];return t}(r[a])),!i}if(ug.isFormData(e)&&ug.isFunction(e.entries)){const n={};return ug.forEachEntry(e,((e,r)=>{t(function(e){return ug.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}(e),r,n,0)})),n}return null};const Fg={transitional:Ng,adapter:["xhr","http","fetch"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,s=ug.isObject(e);s&&ug.isHTMLForm(e)&&(e=new FormData(e));if(ug.isFormData(e))return r?JSON.stringify(Dg(e)):e;if(ug.isArrayBuffer(e)||ug.isBuffer(e)||ug.isStream(e)||ug.isFile(e)||ug.isBlob(e)||ug.isReadableStream(e))return e;if(ug.isArrayBufferView(e))return e.buffer;if(ug.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let a;if(s){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return bg(e,new Og.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return Og.isNode&&ug.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((a=ug.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return bg(a?{"files[]":e}:e,t&&new t,this.formSerializer)}}return s||r?(t.setContentType("application/json",!1),function(e,t,n){if(ug.isString(e))try{return(t||JSON.parse)(e),ug.trim(e)}catch(t5){if("SyntaxError"!==t5.name)throw t5}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){const t=this.transitional||Fg.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(ug.isResponse(e)||ug.isReadableStream(e))return e;if(e&&ug.isString(e)&&(n&&!this.responseType||r)){const n=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(t5){if(n){if("SyntaxError"===t5.name)throw pg.from(t5,pg.ERR_BAD_RESPONSE,this,null,this.response);throw t5}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Og.classes.FormData,Blob:Og.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};ug.forEach(["delete","get","head","post","put","patch"],(e=>{Fg.headers[e]={}}));const Lg=Fg,Mg=ug.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),Pg=Symbol("internals");function zg(e){return e&&String(e).trim().toLowerCase()}function Bg(e){return!1===e||null==e?e:ug.isArray(e)?e.map(Bg):String(e)}function Ug(e,t,n,r,s){return ug.isFunction(r)?r.call(this,t,n):(s&&(t=n),ug.isString(t)?ug.isString(r)?-1!==t.indexOf(r):ug.isRegExp(r)?r.test(t):void 0:void 0)}class Vg{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function s(e,t,n){const s=zg(t);if(!s)throw new Error("header name must be a non-empty string");const a=ug.findKey(r,s);(!a||void 0===r[a]||!0===n||void 0===n&&!1!==r[a])&&(r[a||t]=Bg(e))}const a=(e,t)=>ug.forEach(e,((e,n)=>s(e,n,t)));if(ug.isPlainObject(e)||e instanceof this.constructor)a(e,t);else if(ug.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))a((e=>{const t={};let n,r,s;return e&&e.split("\n").forEach((function(e){s=e.indexOf(":"),n=e.substring(0,s).trim().toLowerCase(),r=e.substring(s+1).trim(),!n||t[n]&&Mg[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t})(e),t);else if(ug.isHeaders(e))for(const[i,o]of e.entries())s(o,i,n);else null!=e&&s(t,e,n);return this}get(e,t){if(e=zg(e)){const n=ug.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return function(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}(e);if(ug.isFunction(t))return t.call(this,e,n);if(ug.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=zg(e)){const n=ug.findKey(this,e);return!(!n||void 0===this[n]||t&&!Ug(0,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function s(e){if(e=zg(e)){const s=ug.findKey(n,e);!s||t&&!Ug(0,n[s],s,t)||(delete n[s],r=!0)}}return ug.isArray(e)?e.forEach(s):s(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const s=t[n];e&&!Ug(0,this[s],s,e,!0)||(delete this[s],r=!0)}return r}normalize(e){const t=this,n={};return ug.forEach(this,((r,s)=>{const a=ug.findKey(n,s);if(a)return t[a]=Bg(r),void delete t[s];const i=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}(s):String(s).trim();i!==s&&delete t[s],t[i]=Bg(r),n[i]=!0})),this}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.constructor.concat(this,...t)}toJSON(e){const t=Object.create(null);return ug.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&ug.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((e=>{let[t,n]=e;return t+": "+n})).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e){const t=new this(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return r.forEach((e=>t.set(e))),t}static accessor(e){const t=(this[Pg]=this[Pg]={accessors:{}}).accessors,n=this.prototype;function r(e){const r=zg(e);t[r]||(!function(e,t){const n=ug.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,s){return this[r].call(this,t,e,n,s)},configurable:!0})}))}(n,e),t[r]=!0)}return ug.isArray(e)?e.forEach(r):r(e),this}}Vg.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),ug.reduceDescriptors(Vg.prototype,((e,t)=>{let{value:n}=e,r=t[0].toUpperCase()+t.slice(1);return{get:()=>n,set(e){this[r]=e}}})),ug.freezeMethods(Vg);const Wg=Vg;function jg(e,t){const n=this||Lg,r=t||n,s=Wg.from(r.headers);let a=r.data;return ug.forEach(e,(function(e){a=e.call(n,a,s.normalize(),t?t.status:void 0)})),s.normalize(),a}function Gg(e){return!(!e||!e.__CANCEL__)}function Hg(e,t,n){pg.call(this,null==e?"canceled":e,pg.ERR_CANCELED,t,n),this.name="CanceledError"}ug.inherits(Hg,pg,{__CANCEL__:!0});const qg=Hg;function Kg(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new pg("Request failed with status code "+n.status,[pg.ERR_BAD_REQUEST,pg.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}const Xg=function(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s,a=0,i=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[i];s||(s=l),n[a]=o,r[a]=l;let c=i,h=0;for(;c!==a;)h+=n[c++],c%=e;if(a=(a+1)%e,a===i&&(i=(i+1)%e),l-s<t)return;const d=u&&l-u;return d?Math.round(1e3*h/d):void 0}};const Yg=function(e,t){let n,r,s=0,a=1e3/t;const i=function(t){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Date.now();s=a,n=null,r&&(clearTimeout(r),r=null),e.apply(null,t)};return[function(){const e=Date.now(),t=e-s;for(var o=arguments.length,l=new Array(o),u=0;u<o;u++)l[u]=arguments[u];t>=a?i(l,e):(n=l,r||(r=setTimeout((()=>{r=null,i(n)}),a-t)))},()=>n&&i(n)]},Qg=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3,r=0;const s=Xg(50,250);return Yg((n=>{const a=n.loaded,i=n.lengthComputable?n.total:void 0,o=a-r,l=s(o);r=a;e({loaded:a,total:i,progress:i?a/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&a<=i?(i-a)/l:void 0,event:n,lengthComputable:null!=i,[t?"download":"upload"]:!0})}),n)},Jg=(e,t)=>{const n=null!=e;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},Zg=e=>function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return ug.asap((()=>e(...n)))},ey=Og.hasStandardBrowserEnv?function(){const e=Og.navigator&&/(msie|trident)/i.test(Og.navigator.userAgent),t=document.createElement("a");let n;function r(n){let r=n;return e&&(t.setAttribute("href",r),r=t.href),t.setAttribute("href",r),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=r(window.location.href),function(e){const t=ug.isString(e)?r(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return!0},ty=Og.hasStandardBrowserEnv?{write(e,t,n,r,s,a){const i=[e+"="+encodeURIComponent(t)];ug.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),ug.isString(r)&&i.push("path="+r),ug.isString(s)&&i.push("domain="+s),!0===a&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function ny(e,t){return e&&!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)?function(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}const ry=e=>e instanceof Wg?{...e}:e;function sy(e,t){t=t||{};const n={};function r(e,t,n){return ug.isPlainObject(e)&&ug.isPlainObject(t)?ug.merge.call({caseless:n},e,t):ug.isPlainObject(t)?ug.merge({},t):ug.isArray(t)?t.slice():t}function s(e,t,n){return ug.isUndefined(t)?ug.isUndefined(e)?void 0:r(void 0,e,n):r(e,t,n)}function a(e,t){if(!ug.isUndefined(t))return r(void 0,t)}function i(e,t){return ug.isUndefined(t)?ug.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,s,a){return a in t?r(n,s):a in e?r(void 0,n):void 0}const l={url:a,method:a,data:a,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(e,t)=>s(ry(e),ry(t),!0)};return ug.forEach(Object.keys(Object.assign({},e,t)),(function(r){const a=l[r]||s,i=a(e[r],t[r],r);ug.isUndefined(i)&&a!==o||(n[r]=i)})),n}const ay=e=>{const t=sy({},e);let n,{data:r,withXSRFToken:s,xsrfHeaderName:a,xsrfCookieName:i,headers:o,auth:l}=t;if(t.headers=o=Wg.from(o),t.url=Ig(ny(t.baseURL,t.url),e.params,e.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),ug.isFormData(r))if(Og.hasStandardBrowserEnv||Og.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[e,...t]=n?n.split(";").map((e=>e.trim())).filter(Boolean):[];o.setContentType([e||"multipart/form-data",...t].join("; "))}if(Og.hasStandardBrowserEnv&&(s&&ug.isFunction(s)&&(s=s(t)),s||!1!==s&&ey(t.url))){const e=a&&i&&ty.read(i);e&&o.set(a,e)}return t},iy="undefined"!==typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){const r=ay(e);let s=r.data;const a=Wg.from(r.headers).normalize();let i,o,l,u,c,{responseType:h,onUploadProgress:d,onDownloadProgress:p}=r;function f(){u&&u(),c&&c(),r.cancelToken&&r.cancelToken.unsubscribe(i),r.signal&&r.signal.removeEventListener("abort",i)}let m=new XMLHttpRequest;function g(){if(!m)return;const r=Wg.from("getAllResponseHeaders"in m&&m.getAllResponseHeaders());Kg((function(e){t(e),f()}),(function(e){n(e),f()}),{data:h&&"text"!==h&&"json"!==h?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:r,config:e,request:m}),m=null}m.open(r.method.toUpperCase(),r.url,!0),m.timeout=r.timeout,"onloadend"in m?m.onloadend=g:m.onreadystatechange=function(){m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))&&setTimeout(g)},m.onabort=function(){m&&(n(new pg("Request aborted",pg.ECONNABORTED,e,m)),m=null)},m.onerror=function(){n(new pg("Network Error",pg.ERR_NETWORK,e,m)),m=null},m.ontimeout=function(){let t=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const s=r.transitional||Ng;r.timeoutErrorMessage&&(t=r.timeoutErrorMessage),n(new pg(t,s.clarifyTimeoutError?pg.ETIMEDOUT:pg.ECONNABORTED,e,m)),m=null},void 0===s&&a.setContentType(null),"setRequestHeader"in m&&ug.forEach(a.toJSON(),(function(e,t){m.setRequestHeader(t,e)})),ug.isUndefined(r.withCredentials)||(m.withCredentials=!!r.withCredentials),h&&"json"!==h&&(m.responseType=r.responseType),p&&([l,c]=Qg(p,!0),m.addEventListener("progress",l)),d&&m.upload&&([o,u]=Qg(d),m.upload.addEventListener("progress",o),m.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(i=t=>{m&&(n(!t||t.type?new qg(null,e,m):t),m.abort(),m=null)},r.cancelToken&&r.cancelToken.subscribe(i),r.signal&&(r.signal.aborted?i():r.signal.addEventListener("abort",i)));const y=function(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}(r.url);y&&-1===Og.protocols.indexOf(y)?n(new pg("Unsupported protocol "+y+":",pg.ERR_BAD_REQUEST,e)):m.send(s||null)}))},oy=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let n,r=new AbortController;const s=function(e){if(!n){n=!0,i();const t=e instanceof Error?e:this.reason;r.abort(t instanceof pg?t:new qg(t instanceof Error?t.message:t))}};let a=t&&setTimeout((()=>{a=null,s(new pg(`timeout ${t} of ms exceeded`,pg.ETIMEDOUT))}),t);const i=()=>{e&&(a&&clearTimeout(a),a=null,e.forEach((e=>{e.unsubscribe?e.unsubscribe(s):e.removeEventListener("abort",s)})),e=null)};e.forEach((e=>e.addEventListener("abort",s)));const{signal:o}=r;return o.unsubscribe=()=>ug.asap(i),o}},ly=function*(e,t){let n=e.byteLength;if(!t||n<t)return void(yield e);let r,s=0;for(;s<n;)r=s+t,yield e.slice(s,r),s=r},uy=async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}},cy=(e,t,n,r)=>{const s=async function*(e,t){for await(const n of uy(e))yield*ly(n,t)}(e,t);let a,i=0,o=e=>{a||(a=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:r}=await s.next();if(t)return o(),void e.close();let a=r.byteLength;if(n){let e=i+=a;n(e)}e.enqueue(new Uint8Array(r))}catch(t){throw o(t),t}},cancel:e=>(o(e),s.return())},{highWaterMark:2})},hy="function"===typeof fetch&&"function"===typeof Request&&"function"===typeof Response,dy=hy&&"function"===typeof ReadableStream,py=hy&&("function"===typeof TextEncoder?(fy=new TextEncoder,e=>fy.encode(e)):async e=>new Uint8Array(await new Response(e).arrayBuffer()));var fy;const my=function(e){try{for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return!!e(...n)}catch(t5){return!1}},gy=dy&&my((()=>{let e=!1;const t=new Request(Og.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})),yy=dy&&my((()=>ug.isReadableStream(new Response("").body))),by={stream:yy&&(e=>e.body)};var vy;hy&&(vy=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((e=>{!by[e]&&(by[e]=ug.isFunction(vy[e])?t=>t[e]():(t,n)=>{throw new pg(`Response type '${e}' is not supported`,pg.ERR_NOT_SUPPORT,n)})})));const wy=async(e,t)=>{const n=ug.toFiniteNumber(e.getContentLength());return null==n?(async e=>{if(null==e)return 0;if(ug.isBlob(e))return e.size;if(ug.isSpecCompliantForm(e)){const t=new Request(Og.origin,{method:"POST",body:e});return(await t.arrayBuffer()).byteLength}return ug.isArrayBufferView(e)||ug.isArrayBuffer(e)?e.byteLength:(ug.isURLSearchParams(e)&&(e+=""),ug.isString(e)?(await py(e)).byteLength:void 0)})(t):n},xy=hy&&(async e=>{let{url:t,method:n,data:r,signal:s,cancelToken:a,timeout:i,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:c,withCredentials:h="same-origin",fetchOptions:d}=ay(e);u=u?(u+"").toLowerCase():"text";let p,f=oy([s,a&&a.toAbortSignal()],i);const m=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let g;try{if(l&&gy&&"get"!==n&&"head"!==n&&0!==(g=await wy(c,r))){let e,n=new Request(t,{method:"POST",body:r,duplex:"half"});if(ug.isFormData(r)&&(e=n.headers.get("content-type"))&&c.setContentType(e),n.body){const[e,t]=Jg(g,Qg(Zg(l)));r=cy(n.body,65536,e,t)}}ug.isString(h)||(h=h?"include":"omit");const s="credentials"in Request.prototype;p=new Request(t,{...d,signal:f,method:n.toUpperCase(),headers:c.normalize().toJSON(),body:r,duplex:"half",credentials:s?h:void 0});let a=await fetch(p);const i=yy&&("stream"===u||"response"===u);if(yy&&(o||i&&m)){const e={};["status","statusText","headers"].forEach((t=>{e[t]=a[t]}));const t=ug.toFiniteNumber(a.headers.get("content-length")),[n,r]=o&&Jg(t,Qg(Zg(o),!0))||[];a=new Response(cy(a.body,65536,n,(()=>{r&&r(),m&&m()})),e)}u=u||"text";let y=await by[ug.findKey(by,u)||"text"](a,e);return!i&&m&&m(),await new Promise(((t,n)=>{Kg(t,n,{data:y,headers:Wg.from(a.headers),status:a.status,statusText:a.statusText,config:e,request:p})}))}catch(y){if(m&&m(),y&&"TypeError"===y.name&&/fetch/i.test(y.message))throw Object.assign(new pg("Network Error",pg.ERR_NETWORK,e,p),{cause:y.cause||y});throw pg.from(y,y&&y.code,e,p)}}),ky={http:null,xhr:iy,fetch:xy};ug.forEach(ky,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(t5){}Object.defineProperty(e,"adapterName",{value:t})}}));const Sy=e=>`- ${e}`,Iy=e=>ug.isFunction(e)||null===e||!1===e,Ty=e=>{e=ug.isArray(e)?e:[e];const{length:t}=e;let n,r;const s={};for(let a=0;a<t;a++){let t;if(n=e[a],r=n,!Iy(n)&&(r=ky[(t=String(n)).toLowerCase()],void 0===r))throw new pg(`Unknown adapter '${t}'`);if(r)break;s[t||"#"+a]=r}if(!r){const e=Object.entries(s).map((e=>{let[t,n]=e;return`adapter ${t} `+(!1===n?"is not supported by the environment":"is not available in the build")}));let n=t?e.length>1?"since :\n"+e.map(Sy).join("\n"):" "+Sy(e[0]):"as no adapter specified";throw new pg("There is no suitable adapter to dispatch the request "+n,"ERR_NOT_SUPPORT")}return r};function Ny(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new qg(null,e)}function Ey(e){Ny(e),e.headers=Wg.from(e.headers),e.data=jg.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1);return Ty(e.adapter||Lg.adapter)(e).then((function(t){return Ny(e),t.data=jg.call(e,e.transformResponse,t),t.headers=Wg.from(t.headers),t}),(function(t){return Gg(t)||(Ny(e),t&&t.response&&(t.response.data=jg.call(e,e.transformResponse,t.response),t.response.headers=Wg.from(t.response.headers))),Promise.reject(t)}))}const Cy="1.7.7",_y={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{_y[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const Ay={};_y.transitional=function(e,t,n){function r(e,t){return"[Axios v1.7.7] Transitional option '"+e+"'"+t+(n?". "+n:"")}return(n,s,a)=>{if(!1===e)throw new pg(r(s," has been removed"+(t?" in "+t:"")),pg.ERR_DEPRECATED);return t&&!Ay[s]&&(Ay[s]=!0,console.warn(r(s," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,s,a)}};const Ry={assertOptions:function(e,t,n){if("object"!==typeof e)throw new pg("options must be an object",pg.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const a=r[s],i=t[a];if(i){const t=e[a],n=void 0===t||i(t,a,e);if(!0!==n)throw new pg("option "+a+" must be "+n,pg.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new pg("Unknown option "+a,pg.ERR_BAD_OPTION)}},validators:_y},$y=Ry.validators;class Oy{constructor(e){this.defaults=e,this.interceptors={request:new Tg,response:new Tg}}async request(e,t){try{return await this._request(e,t)}catch(n){if(n instanceof Error){let e;Error.captureStackTrace?Error.captureStackTrace(e={}):e=new Error;const t=e.stack?e.stack.replace(/^.+\n/,""):"";try{n.stack?t&&!String(n.stack).endsWith(t.replace(/^.+\n.+\n/,""))&&(n.stack+="\n"+t):n.stack=t}catch(t5){}}throw n}}_request(e,t){"string"===typeof e?(t=t||{}).url=e:t=e||{},t=sy(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:s}=t;void 0!==n&&Ry.assertOptions(n,{silentJSONParsing:$y.transitional($y.boolean),forcedJSONParsing:$y.transitional($y.boolean),clarifyTimeoutError:$y.transitional($y.boolean)},!1),null!=r&&(ug.isFunction(r)?t.paramsSerializer={serialize:r}:Ry.assertOptions(r,{encode:$y.function,serialize:$y.function},!0)),t.method=(t.method||this.defaults.method||"get").toLowerCase();let a=s&&ug.merge(s.common,s[t.method]);s&&ug.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete s[e]})),t.headers=Wg.concat(a,s);const i=[];let o=!0;this.interceptors.request.forEach((function(e){"function"===typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,i.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let c,h=0;if(!o){const e=[Ey.bind(this),void 0];for(e.unshift.apply(e,i),e.push.apply(e,l),c=e.length,u=Promise.resolve(t);h<c;)u=u.then(e[h++],e[h++]);return u}c=i.length;let d=t;for(h=0;h<c;){const e=i[h++],t=i[h++];try{d=e(d)}catch(p){t.call(this,p);break}}try{u=Ey.call(this,d)}catch(p){return Promise.reject(p)}for(h=0,c=l.length;h<c;)u=u.then(l[h++],l[h++]);return u}getUri(e){return Ig(ny((e=sy(this.defaults,e)).baseURL,e.url),e.params,e.paramsSerializer)}}ug.forEach(["delete","get","head","options"],(function(e){Oy.prototype[e]=function(t,n){return this.request(sy(n||{},{method:e,url:t,data:(n||{}).data}))}})),ug.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,s){return this.request(sy(s||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Oy.prototype[e]=t(),Oy.prototype[e+"Form"]=t(!0)}));const Dy=Oy;class Fy{constructor(e){if("function"!==typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;for(;t-- >0;)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,s){n.reason||(n.reason=new qg(e,r,s),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}toAbortSignal(){const e=new AbortController,t=t=>{e.abort(t)};return this.subscribe(t),e.signal.unsubscribe=()=>this.unsubscribe(t),e.signal}static source(){let e;return{token:new Fy((function(t){e=t})),cancel:e}}}const Ly=Fy;const My={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(My).forEach((e=>{let[t,n]=e;My[n]=t}));const Py=My;const zy=function e(t){const n=new Dy(t),r=xm(Dy.prototype.request,n);return ug.extend(r,Dy.prototype,n,{allOwnKeys:!0}),ug.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(sy(t,n))},r}(Lg);zy.Axios=Dy,zy.CanceledError=qg,zy.CancelToken=Ly,zy.isCancel=Gg,zy.VERSION=Cy,zy.toFormData=bg,zy.AxiosError=pg,zy.Cancel=zy.CanceledError,zy.all=function(e){return Promise.all(e)},zy.spread=function(e){return function(t){return e.apply(null,t)}},zy.isAxiosError=function(e){return ug.isObject(e)&&!0===e.isAxiosError},zy.mergeConfig=sy,zy.AxiosHeaders=Wg,zy.formToJSON=e=>Dg(ug.isHTMLForm(e)?new FormData(e):e),zy.getAdapter=Ty,zy.HttpStatusCode=Py,zy.default=zy;const By=zy,Uy=async(e,t,n)=>{const r={method:"POST",url:"https://free-google-translator.p.rapidapi.com/external-api/free-google-translator",params:{from:e,to:t,query:n},headers:{"x-rapidapi-key":"96c686385bmsh55ef47aac625486p110f2ajsnb8dea4c52c35","x-rapidapi-host":"free-google-translator.p.rapidapi.com","Content-Type":"application/json"}};try{return(await By.request(r)).data}catch(s){if(s.response)throw new Error(`Translation failed: ${s.response.data.message||s.message}`)}},Vy=JSON.parse('{"e":{"Afrikaans":"af","Albanian":"sq","Arabic":"ar","Armenian":"hy","Azerbaijani":"az","Basque":"eu","Belarusian":"be","Bengali":"bn","Bosnian":"bs","Bulgarian":"bg","Catalan":"ca","Chinese (Simplified)":"zh-CN","Chinese (Traditional)":"zh-TW","Croatian":"hr","Czech":"cs","Danish":"da","Dutch":"nl","English":"en","Estonian":"et","Filipino":"tl","Finnish":"fi","French":"fr","Galician":"gl","Georgian":"ka","German":"de","Greek":"el","Gujarati":"gu","Haitian Creole":"ht","Hebrew":"he","Hindi":"hi","Hungarian":"hu","Icelandic":"is","Indonesian":"id","Irish":"ga","Italian":"it","Japanese":"ja","Javanese":"jv","Kannada":"kn","Kazakh":"kk","Khmer":"km","Korean":"ko","Kurdish (Kurmanji)":"ku","Kyrgyz":"ky","Lao":"lo","Latin":"la","Latvian":"lv","Lithuanian":"lt","Luxembourgish":"lb","Macedonian":"mk","Malagasy":"mg","Malay":"ms","Maltese":"mt","Maori":"mi","Marathi":"mr","Mongolian":"mn","Nepali":"ne","Norwegian":"no","Persian":"fa","Polish":"pl","Portuguese":"pt","Punjabi":"pa","Romanian":"ro","Russian":"ru","Serbian":"sr","Slovak":"sk","Slovenian":"sl","Somali":"so","Spanish":"es","Sundanese":"su","Swahili":"sw","Swedish":"sv","Tajik":"tg","Tamil":"ta","Tatar":"tt","Telugu":"te","Thai":"th","Turkish":"tr","Ukrainian":"uk","Urdu":"ur","Uzbek":"uz","Vietnamese":"vi","Welsh":"cy","Xhosa":"xh","Yiddish":"yi","Yoruba":"yo","Zulu":"zu"}}');var Wy=n(6081);const jy={container:{padding:pm.spacing.xl,maxWidth:"1200px",margin:"0 auto",animation:"fadeIn 0.5s ease forwards"},translationCard:{backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,boxShadow:pm.shadows.md,padding:pm.spacing.xl,animation:"slideUp 0.5s ease forwards"},languageBar:{display:"flex",alignItems:"center",gap:pm.spacing.md,marginBottom:pm.spacing.lg,padding:pm.spacing.md,backgroundColor:pm.colors.background,borderRadius:pm.borderRadius.lg},select:{flex:1,padding:pm.spacing.md,borderRadius:pm.borderRadius.md,border:`1px solid ${pm.colors.border}`,fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,backgroundColor:pm.colors.surface,cursor:"pointer",outline:"none",transition:"border-color 0.2s ease","&:hover":{borderColor:pm.colors.primary}},swapButton:{padding:pm.spacing.md,borderRadius:pm.borderRadius.md,border:"none",backgroundColor:pm.colors.surface,color:pm.colors.primary,cursor:"pointer",transition:"all 0.2s ease",display:"flex",alignItems:"center",justifyContent:"center","&:hover":{backgroundColor:pm.colors.surfaceHover}},textareaContainer:{display:"grid",gridTemplateColumns:"1fr 1px 1fr",gap:pm.spacing.lg,marginBottom:pm.spacing.lg,minHeight:"300px"},textarea:{padding:pm.spacing.lg,borderRadius:pm.borderRadius.lg,border:`1px solid ${pm.colors.border}`,fontSize:pm.typography.sizes.base,lineHeight:"1.5",resize:"none",outline:"none",transition:"border-color 0.2s ease","&:focus":{borderColor:pm.colors.primary},animation:"slideRight 0.5s ease forwards",animationDelay:"calc(var(--index) * 100ms)"},divider:{backgroundColor:pm.colors.border},translatedContent:{padding:pm.spacing.lg,fontSize:pm.typography.sizes.base,lineHeight:"1.5",color:pm.colors.text.primary,backgroundColor:pm.colors.background,borderRadius:pm.borderRadius.lg,border:`1px solid ${pm.colors.border}`},translateButton:{width:"100%",padding:pm.spacing.md,backgroundColor:pm.colors.primary,color:pm.colors.surface,border:"none",borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.base,fontWeight:"500",cursor:"pointer",transition:"all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",position:"relative",overflow:"hidden","&:hover":{backgroundColor:pm.colors.primary+"dd",transform:"translateY(-2px)",boxShadow:"0 4px 12px rgba(59, 130, 246, 0.2)"},"&:active":{transform:"translateY(0)"},"&::after":{content:'""',position:"absolute",top:"50%",left:"50%",width:0,height:0,backgroundColor:"rgba(255, 255, 255, 0.2)",borderRadius:"50%",transform:"translate(-50%, -50%)",transition:"width 0.3s ease, height 0.3s ease"},"&:active::after":{width:"200px",height:"200px"},animation:"scaleIn 0.5s ease forwards",animationDelay:"0.3s"}},Gy=e=>{let{user:t}=e;const[n,r]=(0,_.useState)(""),[s,a]=(0,_.useState)(""),[i,o]=(0,_.useState)("en"),[l,u]=(0,_.useState)("fr"),c=Object.entries(Vy.e).map((e=>{let[t,n]=e;return{code:n,name:t}}));return(0,mm.jsx)("div",{style:jy.container,children:(0,mm.jsxs)("div",{style:jy.translationCard,children:[(0,mm.jsx)("h1",{style:jy.title,children:"GlobeTalk Text Translation"}),(0,mm.jsxs)("div",{style:jy.languageBar,children:[(0,mm.jsx)("select",{value:i,onChange:e=>o(e.target.value),style:jy.select,children:c.map((e=>(0,mm.jsx)("option",{value:e.code,children:e.name},e.code)))}),(0,mm.jsx)("button",{onClick:()=>{o(l),u(i)},style:jy.swapButton,children:(0,mm.jsx)(Wy.A,{})}),(0,mm.jsx)("select",{value:l,onChange:e=>u(e.target.value),style:jy.select,children:c.map((e=>(0,mm.jsx)("option",{value:e.code,children:e.name},e.code)))})]}),(0,mm.jsxs)("div",{style:jy.textareaContainer,children:[(0,mm.jsx)("textarea",{style:jy.textarea,value:n,onChange:e=>r(e.target.value),placeholder:"Enter text to translate"}),(0,mm.jsx)("div",{style:jy.divider}),(0,mm.jsx)("div",{style:jy.translatedContent,children:s||"Translation will appear here"})]}),(0,mm.jsx)("button",{style:jy.translateButton,onClick:async()=>{if(t)try{const e=await Uy(i,l,n);a(e.translation);await om(df(hm,"history"),{uid:t.uid,original:n,translated:e.translation,fromLanguage:i,toLanguage:l,timestamp:um()})}catch(e){console.error("Translation error:",e),a("Translation failed. Please try again.")}else console.error("User not authenticated")},children:"Translate"})]})})},Hy=(0,fm.A)((0,mm.jsx)("path",{d:"M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3m5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72z"}),"Mic"),qy=(0,fm.A)((0,mm.jsx)("path",{d:"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2M8.5 13.5l2.5 3.01L14.5 12l4.5 6H5z"}),"Image"),Ky=(0,fm.A)((0,mm.jsx)("path",{d:"m12.87 15.07-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2zm-2.62 7 1.62-4.33L19.12 17z"}),"Translate"),Xy=(0,fm.A)([(0,mm.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"},"0"),(0,mm.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"},"1")],"AccessTime"),Yy=(0,fm.A)((0,mm.jsx)("path",{d:"M6.99 11 3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z"}),"SwapHoriz"),Qy=e=>{let{type:t}=e;const n={fontSize:"20px",color:pm.colors.primary};switch(t){case"voice":return(0,mm.jsx)(Hy,{style:n});case"image":return(0,mm.jsx)(qy,{style:n});default:return(0,mm.jsx)(Ky,{style:n})}},Jy={container:{padding:pm.spacing.xl,maxWidth:"1000px",margin:"0 auto"},title:{fontSize:pm.typography.sizes["2xl"],fontWeight:"600",color:pm.colors.text.primary,marginBottom:pm.spacing.xl,textAlign:"center"},loading:{textAlign:"center",color:pm.colors.text.secondary,padding:pm.spacing.xl},emptyState:{textAlign:"center",color:pm.colors.text.secondary,padding:pm.spacing.xl,backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,border:`1px solid ${pm.colors.border}`},historyList:{display:"flex",flexDirection:"column",gap:pm.spacing.lg},historyItem:{backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,border:`1px solid ${pm.colors.border}`,overflow:"hidden",transition:"transform 0.2s ease, box-shadow 0.2s ease","&:hover":{transform:"translateY(-2px)",boxShadow:pm.shadows.md}},itemHeader:{padding:pm.spacing.lg,backgroundColor:pm.colors.background,borderBottom:`1px solid ${pm.colors.border}`,display:"flex",justifyContent:"space-between",alignItems:"center"},timestamp:{display:"flex",alignItems:"center",gap:pm.spacing.sm,color:pm.colors.text.secondary,fontSize:pm.typography.sizes.sm},languagePair:{display:"flex",alignItems:"center",gap:pm.spacing.sm,color:pm.colors.primary,fontWeight:"500"},icon:{fontSize:"1.2em"},translationContent:{padding:pm.spacing.lg,display:"grid",gridTemplateColumns:"1fr 1fr",gap:pm.spacing.xl},textBlock:{display:"flex",flexDirection:"column",gap:pm.spacing.sm},label:{fontSize:pm.typography.sizes.sm,color:pm.colors.text.secondary,fontWeight:"500"},text:{fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,lineHeight:"1.5"},headerLeft:{display:"flex",alignItems:"center",gap:pm.spacing.md},translationType:{display:"flex",alignItems:"center",padding:`${pm.spacing.xs} ${pm.spacing.sm}`,backgroundColor:`${pm.colors.primary}10`,borderRadius:pm.borderRadius.sm}},Zy=e=>{let{user:t}=e;const[n,r]=(0,_.useState)([]),[s,a]=(0,_.useState)(!0);return(0,_.useEffect)((()=>{(async()=>{var e;if(t)try{const n=function(e,t){let n=[];for(var r=arguments.length,s=new Array(r>2?r-2:0),a=2;a<r;a++)s[a-2]=arguments[a];t instanceof jf&&n.push(t),n=n.concat(s),function(e){const t=e.filter((e=>e instanceof qf)).length,n=e.filter((e=>e instanceof Hf)).length;if(t>1||t>0&&n>0)throw new Xi(Ki.INVALID_ARGUMENT,"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")}(n);for(const i of n)e=i._apply(e);return e}(df(hm,"history"),function(e,t,n){const r=t,s=Vf("where",e);return Hf._create(s,r,n)}("uid","==",t.uid),function(e){const t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"asc",n=Vf("orderBy",e);return Kf._create(n,t)}("timestamp","desc"),(sf("limit",e=50),Xf._create("limit",e,"F"))),s=await function(e){e=rf(e,uf);const t=rf(e.firestore,ff),n=mf(t),r=new im(t);return Wf(e._query),Yp(n,e._query).then((n=>new sm(t,r,e,n)))}(n),a=s.docs.map((e=>{var t;return{id:e.id,...e.data(),timestamp:null===(t=e.data().timestamp)||void 0===t?void 0:t.toDate()}}));r(a)}catch(n){console.error("Error fetching history:",n)}finally{a(!1)}})()}),[t]),(0,mm.jsxs)("div",{style:Jy.container,children:[(0,mm.jsx)("h2",{style:Jy.title,children:"Translation History"}),s?(0,mm.jsx)("div",{style:Jy.loading,children:"Loading history..."}):0===n.length?(0,mm.jsx)("div",{style:Jy.emptyState,children:"No translation history yet"}):(0,mm.jsx)("div",{style:Jy.historyList,children:n.map((e=>(0,mm.jsxs)("div",{style:Jy.historyItem,children:[(0,mm.jsxs)("div",{style:Jy.itemHeader,children:[(0,mm.jsxs)("div",{style:Jy.headerLeft,children:[(0,mm.jsxs)("div",{style:Jy.timestamp,children:[(0,mm.jsx)(Xy,{style:Jy.icon}),e.timestamp?e.timestamp.toLocaleString():"Date not available"]}),(0,mm.jsx)("div",{style:Jy.translationType,children:(0,mm.jsx)(Qy,{type:e.type})})]}),(0,mm.jsxs)("div",{style:Jy.languagePair,children:[e.fromLanguage,(0,mm.jsx)(Yy,{style:Jy.icon}),e.toLanguage]})]}),(0,mm.jsxs)("div",{style:Jy.translationContent,children:[(0,mm.jsxs)("div",{style:Jy.textBlock,children:[(0,mm.jsx)("div",{style:Jy.label,children:"Original"}),(0,mm.jsx)("div",{style:Jy.text,children:e.original})]}),(0,mm.jsxs)("div",{style:Jy.textBlock,children:[(0,mm.jsx)("div",{style:Jy.label,children:"Translated"}),(0,mm.jsx)("div",{style:Jy.text,children:e.translated})]})]})]},e.id)))})]})},eb=(0,fm.A)((0,mm.jsx)("path",{d:"m12.49 13-.93-1.86c-.37-.74-.07-1.64.67-2.01l.26-.13 5.73 5.46c.5.47.78 1.13.78 1.81v5.23c0 1.38-1.12 2.5-2.5 2.5h-11c-.55 0-1-.45-1-1s.45-1 1-1H10v-1H4c-.55 0-1-.45-1-1s.45-1 1-1h6v-1H3c-.55 0-1-.45-1-1s.45-1 1-1h7v-1H4.5c-.55 0-1-.45-1-1s.45-1 1-1zm-.71-5.88c-.84.4-1.17.62-1.63 1.19l-2.7-2.85c-.38-.4-.36-1.03.04-1.41.4-.38 1.03-.36 1.41.04zM9.64 9.21c-.23.55-.29 1.24-.2 1.79h-.86L6.31 8.61c-.38-.4-.37-1.03.04-1.41.4-.38 1.03-.36 1.41.04zm10.69 4.7.88-.83c.5-.47.79-1.13.79-1.82V3.35l-.27-.1c-.78-.28-1.64.12-1.92.9l-.71 1.96-5.5-5.8c-.38-.4-1.01-.42-1.41-.04-.4.38-.42 1.01-.04 1.41l3.79 3.99-.73.69-4.82-5.08c-.38-.4-1.01-.42-1.41-.04-.4.38-.42 1.01-.04 1.41l3.78 3.98L15.38 9l3.61 3.43.61.58c.29.27.53.57.73.9"}),"SignLanguage");const tb={container:{padding:pm.spacing.xl,maxWidth:"1200px",margin:"0 auto"},hero:{textAlign:"center",marginBottom:pm.spacing.xxl,padding:`${pm.spacing.xxl} 0`},title:{fontSize:"2.5rem",fontWeight:"700",color:pm.colors.text.primary,marginBottom:pm.spacing.md},subtitle:{fontSize:pm.typography.sizes.lg,color:pm.colors.text.secondary,maxWidth:"600px",margin:"0 auto"}},nb=function(){const e=Ee(),t=[{title:"Text Translation",description:"Translate text between multiple languages instantly",icon:(0,mm.jsx)(Ky,{className:"feature-icon"}),path:"/translate"},{title:"Voice Translation",description:"Speak and get real-time translations",icon:(0,mm.jsx)(Hy,{className:"feature-icon"}),path:"/voice-translation"},{title:"Image Translation",description:"Extract and translate text from images",icon:(0,mm.jsx)(qy,{className:"feature-icon"}),path:"/image-translation"},{title:"Sign Language",description:"Translate sign language in real-time",icon:(0,mm.jsx)(eb,{className:"feature-icon"}),path:"/sign-language"}];return(0,mm.jsxs)("div",{style:tb.container,children:[(0,mm.jsxs)("div",{style:tb.hero,children:[(0,mm.jsx)("h1",{style:tb.title,children:"Welcome to Universal Translator"}),(0,mm.jsx)("p",{style:tb.subtitle,children:"Break language barriers with our comprehensive translation tools"})]}),(0,mm.jsx)("div",{className:"features-grid",children:t.map(((t,n)=>(0,mm.jsxs)("div",{className:"feature-card",onClick:()=>e(t.path),style:{animationDelay:100*n+"ms"},children:[t.icon,(0,mm.jsx)("h3",{className:"feature-title",children:t.title}),(0,mm.jsx)("p",{className:"feature-description",children:t.description})]},t.title)))})]})},rb=(0,fm.A)((0,mm.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2m6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56M12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96M4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56m2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8M12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96M14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2m.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56M16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2z"}),"Language"),sb=(0,fm.A)((0,mm.jsx)("path",{d:"M6 6h12v12H6z"}),"Stop"),ab=(0,fm.A)((0,mm.jsx)("path",{d:"M3 9v6h4l5 5V4L7 9zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02M14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77"}),"VolumeUp"),ib={container:{padding:pm.spacing.xl,maxWidth:"1200px",margin:"0 auto"},translationCard:{backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,boxShadow:pm.shadows.md,padding:pm.spacing.xl,border:`1px solid ${pm.colors.border}`},title:{fontSize:pm.typography.sizes["2xl"],fontWeight:"600",color:pm.colors.text.primary,marginBottom:pm.spacing.xl,textAlign:"center"},languageSelector:{marginBottom:pm.spacing.xl},languageBar:{display:"flex",alignItems:"center",gap:pm.spacing.md,padding:pm.spacing.md,backgroundColor:pm.colors.background,borderRadius:pm.borderRadius.lg},select:{flex:1,padding:pm.spacing.md,borderRadius:pm.borderRadius.md,border:`1px solid ${pm.colors.border}`,fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,backgroundColor:pm.colors.surface,cursor:"pointer",outline:"none",transition:"border-color 0.2s ease"},languageIcon:{color:pm.colors.primary,fontSize:"24px"},recordingSection:{display:"flex",justifyContent:"center",marginBottom:pm.spacing.xl},recordButton:{display:"flex",alignItems:"center",gap:pm.spacing.sm,padding:`${pm.spacing.md} ${pm.spacing.xl}`,backgroundColor:pm.colors.primary,color:pm.colors.surface,border:"none",borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.base,cursor:"pointer",transition:"all 0.2s ease",animation:"scaleIn 0.5s ease forwards","&:hover":{transform:"translateY(-2px)",backgroundColor:pm.colors.primary+"dd"}},recordingActive:{backgroundColor:pm.colors.error},buttonIcon:{fontSize:"24px"},resultsContainer:{display:"flex",flexDirection:"column",gap:pm.spacing.lg},textBlock:{padding:pm.spacing.lg,backgroundColor:pm.colors.background,borderRadius:pm.borderRadius.lg,border:`1px solid ${pm.colors.border}`,animation:"slideUp 0.5s ease forwards",animationDelay:"calc(var(--index) * 100ms)"},resultTitle:{fontSize:pm.typography.sizes.lg,fontWeight:"500",color:pm.colors.text.primary,marginBottom:pm.spacing.md,display:"flex",alignItems:"center",justifyContent:"space-between"},textContent:{fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,lineHeight:"1.5"},speakButton:{backgroundColor:"transparent",border:"none",color:pm.colors.primary,cursor:"pointer",padding:pm.spacing.xs,borderRadius:pm.borderRadius.sm,display:"flex",alignItems:"center",transition:"all 0.2s ease","&:hover":{backgroundColor:`${pm.colors.primary}10`}},speakIcon:{fontSize:"20px"},error:{color:"red",marginTop:pm.spacing.md,textAlign:"center"},processing:{color:pm.colors.text.secondary,marginTop:pm.spacing.md,textAlign:"center"},languageSelector:{display:"flex",justifyContent:"center",gap:pm.spacing.md,marginBottom:pm.spacing.lg},select:{padding:pm.spacing.sm,borderRadius:pm.borderRadius.sm,border:`1px solid ${pm.colors.border}`}},ob=e=>{let{user:t}=e;const[n,r]=(0,_.useState)(!1),[s,a]=(0,_.useState)(""),[i,o]=(0,_.useState)(""),[l,u]=(0,_.useState)("en"),[c,h]=(0,_.useState)("fr"),[d,p]=(0,_.useState)(!1),[f,m]=((0,_.useRef)(null),(0,_.useState)("")),[g,y]=(0,_.useState)(!1),b=(0,_.useRef)(null),v=Object.entries(Vy.e).map((e=>{let[t,n]=e;return{code:n,name:t}})),w=async()=>{if(b.current&&(b.current.stop(),r(!1),i.trim())){y(!0);try{const e=await Uy(l,c,i.trim());a(e.translation),t&&await om(df(hm,"history"),{uid:t.uid,original:i.trim(),translated:e.translation,fromLanguage:l,toLanguage:c,timestamp:um(),type:"voice"})}catch(f){console.error("Translation error:",f),m("Translation failed. Please try again.")}finally{y(!1)}}};return(0,mm.jsx)("div",{style:ib.container,children:(0,mm.jsxs)("div",{style:ib.translationCard,children:[(0,mm.jsx)("h1",{style:ib.title,children:"GlobeTalk Voice Translation"}),(0,mm.jsx)("div",{style:ib.languageSelector,children:(0,mm.jsxs)("div",{style:ib.languageBar,children:[(0,mm.jsx)("select",{value:l,onChange:e=>u(e.target.value),style:ib.select,children:v.map((e=>(0,mm.jsx)("option",{value:e.code,children:e.name},e.code)))}),(0,mm.jsx)(rb,{style:ib.languageIcon}),(0,mm.jsx)("select",{value:c,onChange:e=>h(e.target.value),style:ib.select,children:v.map((e=>(0,mm.jsx)("option",{value:e.code,children:e.name},e.code)))})]})}),(0,mm.jsx)("div",{style:ib.recordingSection,children:(0,mm.jsx)("button",{onClick:n?w:async()=>{if(m(""),a(""),(()=>{const e=window.SpeechRecognition||window.webkitSpeechRecognition;return e?(b.current=new e,b.current.continuous=!0,b.current.interimResults=!0,b.current.lang=l,b.current.onresult=e=>{let t="",n="";for(let r=e.resultIndex;r<e.results.length;r++){const s=e.results[r][0].transcript;e.results[r].isFinal?n+=s+" ":t+=s}o(n||t)},b.current.onerror=e=>{console.error("Speech recognition error:",e.error),m(`Recognition error: ${e.error}`),w()},!0):(m("Speech recognition is not supported in this browser."),!1)})())try{b.current.start(),r(!0)}catch(f){console.error("Error starting recording:",f),m("Failed to start recording. Please try again.")}},style:{...ib.recordButton,...n&&ib.recordingActive},disabled:g,children:n?(0,mm.jsxs)(mm.Fragment,{children:[(0,mm.jsx)(sb,{style:ib.buttonIcon}),"Stop Recording"]}):(0,mm.jsxs)(mm.Fragment,{children:[(0,mm.jsx)(Hy,{style:ib.buttonIcon}),"Start Recording"]})})}),f&&(0,mm.jsx)("div",{style:ib.error,children:f}),g&&(0,mm.jsx)("div",{style:ib.processing,children:"Processing..."}),(i||s)&&(0,mm.jsxs)("div",{style:ib.resultsContainer,children:[i&&(0,mm.jsxs)("div",{style:ib.textBlock,children:[(0,mm.jsx)("h3",{style:ib.resultTitle,children:"Original Text"}),(0,mm.jsx)("div",{style:ib.textContent,children:i})]}),s&&(0,mm.jsxs)("div",{style:ib.textBlock,children:[(0,mm.jsxs)("h3",{style:ib.resultTitle,children:["Translation",(0,mm.jsx)("button",{onClick:()=>(e=>{const t=new SpeechSynthesisUtterance(e);t.lang=c,window.speechSynthesis.speak(t)})(s),style:ib.speakButton,children:(0,mm.jsx)(ab,{style:ib.speakIcon})})]}),(0,mm.jsx)("div",{style:ib.textContent,children:s})]})]})]})})};var lb=n(9938),ub=n.n(lb);const cb=(0,fm.A)((0,mm.jsx)("path",{d:"M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96M14 13v4h-4v-4H7l5-5 5 5z"}),"CloudUpload"),hb={container:{padding:pm.spacing.xl,maxWidth:"800px",margin:"0 auto",animation:"fadeIn 0.5s ease forwards"},card:{backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,boxShadow:pm.shadows.md,padding:pm.spacing.xl,border:`1px solid ${pm.colors.border}`},title:{fontSize:pm.typography.sizes["2xl"],fontWeight:"600",color:pm.colors.text.primary,marginBottom:pm.spacing.xl,textAlign:"center"},languageSelector:{marginBottom:pm.spacing.xl,display:"flex",alignItems:"center",gap:pm.spacing.md},label:{fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,fontWeight:"500"},select:{flex:1,padding:pm.spacing.md,borderRadius:pm.borderRadius.md,border:`1px solid ${pm.colors.border}`,fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,backgroundColor:pm.colors.surface,cursor:"pointer",outline:"none",transition:"border-color 0.2s ease","&:hover":{borderColor:pm.colors.primary}},uploadSection:{marginBottom:pm.spacing.xl,animation:"slideUp 0.5s ease forwards"},fileInput:{display:"none"},uploadLabel:{display:"flex",flexDirection:"column",alignItems:"center",gap:pm.spacing.md,padding:pm.spacing.xl,border:`2px dashed ${pm.colors.border}`,borderRadius:pm.borderRadius.lg,cursor:"pointer",transition:"all 0.2s ease","&:hover":{borderColor:pm.colors.primary,backgroundColor:`${pm.colors.primary}05`}},uploadIcon:{fontSize:"48px",color:pm.colors.primary},previewContainer:{marginBottom:pm.spacing.xl,borderRadius:pm.borderRadius.lg,overflow:"hidden",border:`1px solid ${pm.colors.border}`},preview:{width:"100%",height:"auto",display:"block"},translateButton:{width:"100%",padding:pm.spacing.md,backgroundColor:pm.colors.primary,color:pm.colors.surface,border:"none",borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.base,fontWeight:"500",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:pm.spacing.sm,transition:"background-color 0.2s ease","&:hover":{backgroundColor:pm.colors.primary+"dd"},"&:disabled":{backgroundColor:pm.colors.secondary,cursor:"not-allowed"}},buttonIcon:{fontSize:"20px"},resultContainer:{marginTop:pm.spacing.xl,padding:pm.spacing.lg,backgroundColor:pm.colors.background,borderRadius:pm.borderRadius.lg,border:`1px solid ${pm.colors.border}`},resultTitle:{fontSize:pm.typography.sizes.lg,fontWeight:"500",color:pm.colors.text.primary,marginBottom:pm.spacing.md},translatedText:{fontSize:pm.typography.sizes.base,color:pm.colors.text.primary,lineHeight:"1.5"},imagePreview:{animation:"scaleIn 0.5s ease forwards",animationDelay:"0.2s"}},db=e=>{let{user:t}=e;const[n,r]=(0,_.useState)(null),[s,a]=(0,_.useState)(null),[i,o]=(0,_.useState)(""),[l,u]=(0,_.useState)(!1),[c,h]=(0,_.useState)("fr"),d=Object.entries(Vy.e).map((e=>{let[t,n]=e;return{code:n,name:t}}));return(0,mm.jsx)("div",{style:hb.container,children:(0,mm.jsxs)("div",{style:hb.card,children:[(0,mm.jsx)("h1",{style:hb.title,children:"GlobeTalk Image Translation"}),(0,mm.jsxs)("div",{style:hb.languageSelector,children:[(0,mm.jsx)("label",{style:hb.label,children:"Translate to:"}),(0,mm.jsx)("select",{value:c,onChange:e=>h(e.target.value),style:hb.select,children:d.map((e=>(0,mm.jsx)("option",{value:e.code,children:e.name},e.code)))})]}),(0,mm.jsxs)("div",{style:hb.uploadSection,children:[(0,mm.jsx)("input",{type:"file",accept:"image/*",onChange:e=>{const t=e.target.files[0];t&&(r(t),a(URL.createObjectURL(t)))},style:hb.fileInput,id:"image-upload"}),(0,mm.jsxs)("label",{htmlFor:"image-upload",style:hb.uploadLabel,children:[(0,mm.jsx)(cb,{style:hb.uploadIcon}),(0,mm.jsx)("span",{children:"Choose an image"})]})]}),s&&(0,mm.jsx)("div",{style:hb.previewContainer,children:(0,mm.jsx)("img",{src:s,alt:"Preview",style:hb.preview})}),(0,mm.jsx)("button",{style:hb.translateButton,onClick:async()=>{if(n&&t){u(!0);try{const e=(await ub().recognize(n,"eng")).data.text,r=await Uy("en",c,e);o(r.translation),await om(df(hm,"history"),{uid:t.uid,original:e,translated:r.translation,fromLanguage:"en",toLanguage:c,timestamp:um(),type:"image"})}catch(e){console.error("Translation error:",e),o("Translation failed. Please try again.")}finally{u(!1)}}else console.error("No image selected or user not authenticated")},disabled:!n||l,children:l?"Processing...":(0,mm.jsxs)(mm.Fragment,{children:[(0,mm.jsx)(Ky,{style:hb.buttonIcon}),"Translate Image"]})}),i&&(0,mm.jsxs)("div",{style:hb.resultContainer,children:[(0,mm.jsx)("h3",{style:hb.resultTitle,children:"Translation Result"}),(0,mm.jsx)("div",{style:hb.translatedText,children:i})]})]})})};class pb{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class fb{refCount(e){return mb("refCount")}incRef(e){return mb("incRef")}timerAvailable(){return!0}time(e){return mb("time")}read(e){return mb("read")}readSync(e){return mb("readSync")}readToGPU(e,t){return mb("readToGPU")}numDataIds(){return mb("numDataIds")}disposeData(e,t){return mb("disposeData")}write(e,t,n){return mb("write")}move(e,t,n,r,s){return mb("move")}createTensorFromGPUData(e,t,n){return mb("createTensorFromGPUData")}memory(){return mb("memory")}floatPrecision(){return mb("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return mb("dispose")}}function mb(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function gb(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,vb(e,t,n)}function yb(e,t,n){return Math.max(e,Math.min(t,n))}function bb(e){return e%2===0?e:e+1}function vb(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function wb(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function xb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";wb(Ib(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function kb(e){wb(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Sb(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Ib(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Tb(e){return e%1===0}function Nb(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Eb(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Cb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function _b(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Ab(e,t){const n=t.length;return wb((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),wb(e.every((e=>Tb(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Rb(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Ab(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function $b(e,t){return Ob(e,t)}function Ob(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Db(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Fb(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Lb(e){return"string"===typeof e||e instanceof String}function Mb(e){return"number"===typeof e}function Pb(e){return Array.isArray(e)?Pb(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Mb(e)?"float32":Lb(e)?"string":"boolean"===typeof e?"bool":"float32"}function zb(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Bb(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Ub(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Vb(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=Vb(e+t*o,i,n,r)}return s}function Wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Vb(0,e,t,n)}function jb(e,t){const n=Gb(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Gb(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Hb(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Wb(e,new Float32Array(n));if("int32"===t)return Wb(e,new Int32Array(n));if("bool"===t)return Wb(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function qb(e){e.forEach((t=>{wb(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Kb(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Xb(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function Yb(e){return e&&e.then&&"function"===typeof e.then}const Qb="tfjsflags";class Jb{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Zb,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(ev().getBool("IS_TEST")||ev().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];ev().getBool("IS_TEST")||ev().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Yb(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(Qb in e){e[Qb].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function Zb(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function ev(){return nv}let tv,nv=null;function rv(){if(null==tv){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}tv=e}return tv}function sv(e,t){const n=function(){const e=rv();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const av="Abs",iv="Acos",ov="Acosh",lv="Add",uv="AddN",cv="All",hv="Any",dv="ArgMax",pv="ArgMin",fv="Asin",mv="Asinh",gv="Atan",yv="Atanh",bv="Atan2",vv="AvgPool",wv="AvgPoolGrad",xv="AvgPool3D",kv="AvgPool3DGrad",Sv="BatchMatMul",Iv="BatchToSpaceND",Tv="Bincount",Nv="BitwiseAnd",Ev="BroadcastArgs",Cv="Cast",_v="Ceil",Av="ClipByValue",Rv="Complex",$v="ComplexAbs",Ov="Concat",Dv="Conv2D",Fv="Conv2DBackpropFilter",Lv="Conv2DBackpropInput",Mv="Conv3D",Pv="Conv3DBackpropFilterV2",zv="Conv3DBackpropInputV2",Bv="Cos",Uv="Cosh",Vv="Cumprod",Wv="Cumsum",jv="CropAndResize",Gv="DenseBincount",Hv="DepthToSpace",qv="DepthwiseConv2dNative",Kv="DepthwiseConv2dNativeBackpropFilter",Xv="DepthwiseConv2dNativeBackpropInput",Yv="Diag",Qv="Dilation2D",Jv="Dilation2DBackpropInput",Zv="Dilation2DBackpropFilter",ew="Draw",tw="RealDiv",nw="Einsum",rw="Elu",sw="EluGrad",aw="Erf",iw="Equal",ow="Exp",lw="ExpandDims",uw="Expm1",cw="FFT",hw="Fill",dw="FlipLeftRight",pw="Floor",fw="FloorDiv",mw="FusedBatchNorm",gw="GatherV2",yw="GatherNd",bw="Greater",vw="GreaterEqual",ww="Identity",xw="IFFT",kw="Imag",Sw="IsFinite",Iw="IsInf",Tw="IsNan",Nw="LeakyRelu",Ew="Less",Cw="LessEqual",_w="LinSpace",Aw="Log",Rw="Log1p",$w="LogicalAnd",Ow="LogicalNot",Dw="LogicalOr",Fw="LRN",Lw="LRNGrad",Mw="Max",Pw="Maximum",zw="MaxPool",Bw="MaxPoolGrad",Uw="MaxPool3D",Vw="MaxPool3DGrad",Ww="MaxPoolWithArgmax",jw="Mean",Gw="Min",Hw="Minimum",qw="MirrorPad",Kw="Mod",Xw="Multinomial",Yw="Multiply",Qw="Neg",Jw="NotEqual",Zw="NonMaxSuppressionV3",ex="NonMaxSuppressionV4",tx="NonMaxSuppressionV5",nx="OnesLike",rx="OneHot",sx="Pack",ax="PadV2",ix="Pow",ox="Prelu",lx="Prod",ux="RaggedGather",cx="RaggedRange",hx="RaggedTensorToTensor",dx="Range",px="Real",fx="Reciprocal",mx="Relu",gx="Reshape",yx="ResizeNearestNeighbor",bx="ResizeNearestNeighborGrad",vx="ResizeBilinear",wx="ResizeBilinearGrad",xx="Relu6",kx="Reverse",Sx="Round",Ix="Rsqrt",Tx="ScatterNd",Nx="TensorScatterUpdate",Ex="SearchSorted",Cx="Select",_x="Selu",Ax="Slice",Rx="Sin",$x="Sinh",Ox="Sign",Dx="Sigmoid",Fx="Softplus",Lx="Sqrt",Mx="Sum",Px="SpaceToBatchND",zx="SplitV",Bx="Softmax",Ux="SparseFillEmptyRows",Vx="SparseReshape",Wx="SparseSegmentMean",jx="SparseSegmentSum",Gx="SparseToDense",Hx="SquaredDifference",qx="Square",Kx="StaticRegexReplace",Xx="StridedSlice",Yx="StringNGrams",Qx="StringSplit",Jx="StringToHashBucketFast",Zx="Sub",ek="Tan",tk="Tanh",nk="Tile",rk="TopK",sk="Transform",ak="Transpose",ik="Unique",ok="Unpack",lk="UnsortedSegmentSum",uk="ZerosLike",ck="Step",hk="FromPixels",dk="RotateWithOffset",pk="_FusedMatMul",fk="FusedConv2D",mk="FusedDepthwiseConv2D";function gk(){ev().getBool("IS_TEST")||ev().getBool("PROD")||console.warn(...arguments)}function yk(){ev().getBool("IS_TEST")||ev().getBool("PROD")||console.log(...arguments)}const bk=sv("kernelRegistry",(()=>new Map)),vk=sv("gradRegistry",(()=>new Map));function wk(e,t){const n=Tk(e,t);return bk.get(n)}function xk(e){return vk.get(e)}function kk(e){const t=bk.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Sk(e){const{kernelName:t,backendName:n}=e,r=Tk(t,n);bk.has(r)&&gk(`The kernel '${t}' for backend '${n}' is already registered`),bk.set(r,e)}function Ik(e){const{kernelName:t}=e;vk.has(t)&&ev().getBool("DEBUG")&&gk(`Overriding the gradient for '${t}'`),vk.set(t,e)}function Tk(e,t){return`${t}_${e}`}function Nk(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Ek=n(8818);const Ck=n.n(Ek)()||Ek;function _k(e){return Ck.fromString(e,!0,16)}const Ak=_k("c3a5c85c97cb3127"),Rk=_k("b492b66fbe98f273"),$k=_k("9ae16a3b2f90404f");function Ok(e){return e.xor(e.shru(47))}function Dk(e,t,n){const r=e.slice(t,t+n);return Ck.fromBytes(Array.from(r),!0,!0)}function Fk(e,t){return Dk(e,t,8)}function Lk(e,t){return Dk(e,t,4)}function Mk(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Pk(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_k("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function zk(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=Mk(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(Mk(s,44)),[s.add(r),a.add(i)]}(Fk(e,t),Fk(e,t+8),Fk(e,t+16),Fk(e,t+24),n,r)}function Bk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Ck.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=$k.add(2*t),r=Fk(e,0).add($k),s=Fk(e,t-8);return Pk(Mk(s,37).mul(n).add(r),Mk(r,25).add(s).mul(n),n)}if(t>=4){const n=$k.add(2*t);return Pk(Lk(e,0).shl(3).add(t),Lk(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Ok($k.mul(n).xor(Ak.mul(r))).mul($k)}return $k}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=$k.add(2*t),r=Fk(e,0).mul(Rk),s=Fk(e,8),a=Fk(e,t-8).mul(n),i=Fk(e,t-16).mul($k);return Pk(Mk(r.add(s),43).add(Mk(a,30)).add(i),r.add(Mk(s.add($k),18)).add(a),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=$k.add(2*t),r=Fk(e,0).mul($k),s=Fk(e,8),a=Fk(e,t-8).mul(n),i=Fk(e,t-16).mul($k),o=Mk(r.add(s),43).add(Mk(a,30)).add(i),l=Pk(o,r.add(Mk(s.add($k),18)).add(a),n),u=Fk(e,16).mul(n),c=Fk(e,24),h=o.add(Fk(e,t-32)).mul(n),d=l.add(Fk(e,t-24)).mul(n);return Pk(Mk(u.add(c),43).add(Mk(h,30)).add(d),u.add(Mk(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(Rk).add(113),a=Ok(s.mul($k).add(113)).mul($k),i=[Ck.UZERO,Ck.UZERO],o=[Ck.UZERO,Ck.UZERO];r=r.mul($k).add(Fk(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Mk(r.add(s).add(i[0]).add(Fk(e,l+8)),37).mul(Rk),s=Mk(s.add(i[1]).add(Fk(e,l+48)),42).mul(Rk),r=r.xor(o[1]),s=s.add(i[0]).add(Fk(e,l+40)),a=Mk(a.add(o[0]),33).mul(Rk),i=zk(e,l,i[1].mul(Rk),r.add(o[0])),o=zk(e,l+32,a.add(o[1]),s.add(Fk(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const h=Rk.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Mk(r.add(s).add(i[0]).add(Fk(e,l+8)),37).mul(h),s=Mk(s.add(i[1]).add(Fk(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Fk(e,l+40))),a=Mk(a.add(o[0]),33).mul(h),i=zk(e,l,i[1].mul(h),r.add(o[0])),o=zk(e,l+32,a.add(o[1]),s.add(Fk(e,l+16))),[a,r]=[r,a],Pk(Pk(i[0],o[0],h).add(Ok(s).mul(Ak)).add(a),Pk(i[1],o[1],h).add(r),h)}function Uk(e,t){return"string"===t?jk(e):Vk([e],t)}function Vk(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=qk(e)),ev().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Wk(){return ev().platform.now()}function jk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",ev().platform.encode(e,t)}function Gk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",ev().platform.decode(e,t)}function Hk(e){return null!=ev().platform.isTypedArray?ev().platform.isTypedArray(e):Nk(e)}function qk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||Yb(e)||null==e||Hk(e)&&n)t.push(e);else if(Array.isArray(e)||Hk(e))for(let r=0;r<e.length;++r)qk(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)qk(e[s],t,n)}return t}class Kk{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Yk)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=Wk();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:Wk()-i})}if(ev().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{Xk(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function Xk(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class Yk{logKernelProfile(e,t,n,r,s,a){const i="number"===typeof r?Eb(`${r}ms`,9):r.error,o=Eb(e,25),l=t.rank,u=t.size,c=Eb(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Qk(e,t,n,r){const s=Ub(t),a=function(e,t,n,r){const s=Sb(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?tS(e):e;if(o>1)for(let u=0;u<s/a;u++){const e=u*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],Jk(l[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=eS(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function Jk(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Lb(e)?`'${e}'`:"bool"===n?Zk(e):parseFloat(e.toFixed(7)).toString(),Eb(r,t)}function Zk(e){return 0===e?"false":"true"}function eS(e,t,n,r,s){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[Jk(tS(e)[0],0,n)]}return"bool"===n?[Zk(e[0])]:[e[0].toString()]}if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=tS(r),a=tS(a)),["["+r.map(((e,t)=>Jk(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>Jk(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?tS(e):Array.from(e)).map(((e,t)=>Jk(e,s[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h,a=r+h;d.push(...eS(e.slice(r,a),u,n,c,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h,a=r+h;d.push(...eS(e.slice(r,a),u,n,c,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h,r=t+h;d.push(...eS(e.slice(t,r),u,n,c,s,m===o-1))}const p=2===l?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function tS(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class nS{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Sb(e),null!=n){const e=n.length;wb(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Ob(t,this.size),this.strides=Ub(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),wb(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const a of t){if(a<0||a>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let s=t[t.length-1];for(let a=0;a<t.length-1;++a)s+=this.strides[a]*t[a];return this.values[s]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return rS().makeTensor(this.values,this.shape,this.dtype)}}let rS=null,sS=null,aS=null;class iS{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Sb(e),this.strides=Ub(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return sS.buffer(this.shape,this.dtype,e)}bufferSync(){return sS.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Wb(this.shape,e,"complex64"===this.dtype)}arraySync(){return Wb(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=rS().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Gk(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),rS().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=rS().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Gk(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await rS().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),rS().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return sS.print(this,e)}clone(){return this.throwIfDisposed(),sS.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Qk(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),sS.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),rS().makeVariable(this,e,t,n)}}function oS(){return sv("Tensor",(()=>iS))}Object.defineProperty(iS,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),oS();class lS extends iS{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ib(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);rS().disposeTensor(this),this.dataId=e.dataId,rS().incRef(this,null)}dispose(){rS().disposeVariable(this),this.isDisposedInternal=!0}}var uS,cS,hS,dS,pS;Object.defineProperty(lS,Symbol.hasInstance,{value:e=>e instanceof iS&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(uS||(uS={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(cS||(cS={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(hS||(hS={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(dS||(dS={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(pS||(pS={}));const fS={float32:dS,int32:cS,bool:hS,complex64:pS};function mS(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return fS[e][t]}function gS(e){return mS(e,"int32")}function yS(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function bS(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function vS(e,t){if(e.dtype===t.dtype)return[e,t];const n=mS(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function wS(e,t){return t.some((t=>t.id===e.id))}function xS(e){const t=[];return kS(e,t,new Set),t}function kS(e,t,n){if(null==e)return;if(e instanceof iS)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const s=e;for(const a in s){const e=s[a];n.has(e)||(n.add(e),kS(e,t,n))}}function SS(e){return null!=e.kernelName}class IS{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class TS{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new IS}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(gk(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Kk(this.backendInstance),!0}setupRegisteredKernels(){kk(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){kk(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof fb||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,gk(`Initialization of backend ${e} failed`),gk(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return gk(`Initialization of backend ${e} failed`),gk(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return TS.nextTensorId++}nextVariableId(){return TS.nextVariableId++}clone(e){const t=ES.runKernel(ww,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return ES.runKernel(Cv,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=wk(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=SS(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(SS(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const l=wk(t,this.backendName);wb(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,h=SS(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()})),r&&this.addTapeNode(l,u,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=xk(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(wb(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Lb(e[0])&&(s=e.map((e=>jk(e))));const a=r.write(s,t,n),i=new iS(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new iS(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new lS(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Fb(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof lS||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Fb(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=xk(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=Gb(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=xS(e),n=new Set(t.map((e=>e.id)));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(wb(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));wb(s instanceof iS,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=jb(Sb(e),"float32");return ES.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!Ib(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),CS);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){var t=this;return wb(zb(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];let a;wb(r.every((e=>e instanceof iS)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(a=e(...r,n),wb(a.value instanceof iS,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),wb(zb(a.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),a.value),backwardsFunc:(e,t)=>{const n=a.gradFunc(e,t),s=Array.isArray(n)?n:[n];wb(s.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),wb(s.every((e=>e instanceof iS)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Wk(),n=await this.backend.time(e);return n.wallMs=Wk()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new IS;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function NS(){const e=rv();if(null==e._tfengine){const t=new Jb(e);e._tfengine=new TS(t)}var t;return t=e._tfengine.ENV,nv=t,rS=()=>e._tfengine,e._tfengine}TS.nextTensorId=0,TS.nextVariableId=0;const ES=NS();function CS(e,t){const n={a:e,b:t};return ES.runKernel(lv,n)}let _S;function AS(e){if(void 0!==_S)return _S;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function RS(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const $S=ev();function OS(e,t){let n=e;if(Hk(e))return"string"===t?[]:[e.length];if(yS(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(bS(e))return[e.buffer.size/(null==t?4:Fb(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Hk(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&ev().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&DS(e,r,[]),r}function DS(e,t,n){if(n=n||[],!Array.isArray(e)&&!Hk(e))return void wb(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));wb(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),wb(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let s=0;s<e.length;++s)DS(e[s],r,n.concat(s))}function FS(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function LS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof oS())return FS(r,e.dtype,t,n),e;let s=Pb(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),FS(r,s,t,n),null==e||!Hk(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=OS(e,s);Hk(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Vk(e,s):qk(e,[],!0);return ES.makeTensor(i,a,s)}function MS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>LS(e,`${t}[${s}]`,n,r)))}$S.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),$S.registerFlag("IS_BROWSER",(()=>RS())),$S.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),$S.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),$S.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),$S.registerFlag("PROD",(()=>!1)),$S.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>$S.getBool("DEBUG"))),$S.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),$S.registerFlag("IS_TEST",(()=>!1)),$S.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>$S.getBool("DEBUG"))),$S.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),$S.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),$S.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const PS="__op";function zS(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=PS;const s=function(){ES.startScope(n);try{const e=r(...arguments);return Yb(e)&&console.error("Cannot return a Promise inside of tidy."),ES.endScope(e),e}catch(e){throw ES.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const BS=zS({complex_:function(e,t){const n=LS(e,"real","complex"),r=LS(t,"imag","complex");xb(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return ES.runKernel(Rv,s)}});function US(e,t,n,r){if(null==r)r=Pb(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(bS(e)||yS(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ES.backend.createTensorFromGPUData(e,t||n,r)}if(!Hk(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){qb(t);const e=Sb(t),r=Sb(n);wb(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Sb(t.slice(s));wb(n[s]===t[s]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Hk(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Vk(e,r):qk(e,[],!0),ES.makeTensor(e,t,r)}function VS(e,t,n){return US(e,t,OS(e,n),n)}const WS={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class jS{static join(e){return new jS(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>Hk(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function GS(){return ES}function HS(){return ES.memory()}function qS(e,t){return ES.tidy(e,t)}function KS(e){xS(e).forEach((e=>e.dispose()))}function XS(e){return ES.keep(e)}function YS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return ES.registerBackend(e,t,n)}function QS(){return ES.backend}aS=function(e){ev().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const JS=4;async function ZS(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+JS*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=JS,r.set(e,s),s+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:iI(await Promise.all(r)),specs:n}}function eI(e,t){const n=new jS(e),r={};let s=0;for(const a of t){const e=tI(a,((e,t)=>n.slice(s+e,s+t)));r[a.name]=rI(a,n.slice(s,s+e)),s+=e}return r}function tI(e,t){const n=Sb(e.shape);let r;if("quantization"in e){const t=e.quantization;r=WS[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=JS+new Uint32Array(t(e,e+JS))[0];return e}r=WS[e.dtype]}return n*r}async function nI(e,t){const n=Sb(e.shape);let r;if("quantization"in e){const t=e.quantization;r=WS[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=JS+new Uint32Array(await t(e,e+JS))[0];return e}r=WS[e.dtype]}return n*r}function rI(e,t){const n=e.name,r=e.dtype,s=e.shape,a=Sb(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const l=WS[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];a[i]=o}return new Float32Array(s)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*l}else if("string"===r){const n=Sb(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+JS))[0];o+=JS;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=WS[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=VS(e,s,"float32"),a=VS(n,s,"float32"),o=BS(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return VS(i,s,r)}async function sI(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function aI(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const a of t){const e=await nI(a,(async(e,t)=>(s=await sI(r,s,t),s.slice(e,t))));s=await sI(r,s,e);const t=s.slice(0,e);s=s.slice(e);const i=rI(a,t);if(n[a.name]=i,"webgpu"===ES.backendName){const e=QS();"uploadToGPU"in e&&Sb(i.shape)>=ev().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function iI(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const oI="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function lI(e){return oI?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function uI(e){return jS.join(e)}function cI(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function hI(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function dI(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function pI(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),dI(e,n,r)}function fI(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:lI(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:lI(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new jS(e.weightData).byteLength}}function mI(e){const t=[];for(const n of e)t.push(...n.weights);return t}class gI{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==gI.instance&&(gI.instance=new gI),gI.instance}static registerSaveRouter(e){gI.getInstance().saveRouters.push(e)}static registerLoadRouter(e){gI.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return gI.getHandlers(e,"save")}static getLoadHandlers(e,t){return gI.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?gI.getInstance().loadRouters:gI.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const yI=e=>gI.registerSaveRouter(e),bI=e=>gI.registerLoadRouter(e),vI=e=>gI.getSaveHandlers(e),wI=(e,t)=>gI.getLoadHandlers(e,t),xI="tensorflowjs",kI="models_store",SI="model_info_store";function II(){if(!ev().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function TI(e){const t=e.result;t.createObjectStore(kI,{keyPath:"modelPath"}),t.createObjectStore(SI,{keyPath:"modelPath"})}class NI{constructor(e){if(this.indexedDB=II(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(xI,1);r.onupgradeneeded=()=>TI(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(kI,"readonly"),r=t.objectStore(kI).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=jS.join(t.weightData);const r=fI(t),i=s.transaction(SI,"readwrite");let o,l,u=i.objectStore(SI);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(a){return n(a)}o.onsuccess=()=>{l=s.transaction(kI,"readwrite");const o=l.objectStore(kI);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(a){return n(a)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(SI);const t=u.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(c.error)),t.onerror=e=>(s.close(),n(c.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}NI.URL_SCHEME="indexeddb://";const EI=e=>{return ev().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(NI.URL_SCHEME)?(t=e.slice(NI.URL_SCHEME.length),new NI(t)):null;var t};gI.registerSaveRouter(EI),gI.registerLoadRouter(EI);class CI{constructor(){this.indexedDB=II()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(xI,1);n.onupgradeneeded=()=>TI(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(SI,"readonly"),a=s.objectStore(SI).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(NI.URL_SCHEME)?t.slice(NI.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(xI,1);r.onupgradeneeded=()=>TI(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(SI,"readwrite"),i=a.objectStore(SI),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(kI,"readwrite");const r=l.objectStore(kI).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const _I="/",AI="tensorflowjs_models",RI="info",$I="model_topology",OI="weight_specs",DI="weight_data",FI="model_metadata";function LI(e){return{info:[AI,e,RI].join(_I),topology:[AI,e,$I].join(_I),weightSpecs:[AI,e,OI].join(_I),weightData:[AI,e,DI].join(_I),modelMetadata:[AI,e,FI].join(_I)}}function MI(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function PI(e){const t=e.split(_I);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(_I)}class zI{constructor(e){if(!ev().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=LI(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=fI(e),a=jS.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(oI)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(a));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw MI(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(oI){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(a),t}}zI.URL_SCHEME="localstorage://";const BI=e=>{return ev().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(zI.URL_SCHEME)?(t=e.slice(zI.URL_SCHEME.length),new zI(t)):null;var t};gI.registerSaveRouter(BI),gI.registerLoadRouter(BI);class UI{constructor(){wb(ev().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),wb("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=AI+_I,n=_I+RI;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[PI(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=LI(e=(t=e).startsWith(zI.URL_SCHEME)?t.slice(zI.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return MI(n),r}}const VI="://";class WI{constructor(){this.managers={}}static getInstance(){return null==WI.instance&&(WI.instance=new WI),WI.instance}static registerManager(e,t){wb(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(VI)&&(e=e.slice(0,e.indexOf(VI))),wb(e.length>0,(()=>"scheme must not be an empty string."));const n=WI.getInstance();wb(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=WI.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(WI.getInstance().managers)}}function jI(e){if(-1===e.indexOf(VI))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${WI.getSchemes().join(",")}`);return{scheme:e.split(VI)[0],path:e.split(VI)[1]}}async function GI(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];wb(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=gI.getLoadHandlers(e);wb(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),wb(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=gI.getSaveHandlers(t);wb(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),wb(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=jI(e).scheme,l=jI(e).path,u=o===jI(e).scheme,c=await s.load();n&&u&&await WI.getManager(o).removeModel(l);const h=await i.save(c);return n&&!u&&await WI.getManager(o).removeModel(l),h.modelArtifactsInfo}async function HI(){const e=WI.getSchemes(),t={};for(const n of e){const e=await WI.getManager(n).listModels();for(const r in e){t[n+VI+r]=e[r]}}return t}async function qI(e){const t=jI(e);return WI.getManager(t.scheme).removeModel(t.path)}async function KI(e,t){return GI(e,t,!1)}async function XI(e,t){return GI(e,t,!0)}class YI{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&ev().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Nk(e)}}if(ev().get("IS_BROWSER")){ev().setPlatform("browser",new YI);try{WI.registerManager(zI.URL_SCHEME,new UI)}catch(n5){}try{WI.registerManager(NI.URL_SCHEME,new CI)}catch(n5){}}const QI=()=>n(5817);let JI;class ZI{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=ev().global.fetch?ev().global.fetch(e,t):(null==JI&&(JI=QI()),JI(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function eT(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",qb(e),new nS(e,t,n)}ev().get("IS_NODE")&&!ev().get("IS_BROWSER")&&ev().setPlatform("node",new ZI);const tT=zS({cast_:function(e,t){const n=LS(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return ES.runKernel(Cv,r,s)}});const nT=zS({clone_:function(e){const t={x:LS(e,"x","clone","string_or_numeric")};return ES.runKernel(ww,t)}});function rT(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}NS();sS={buffer:eT,cast:tT,clone:nT,print:rT};const sT=zS({add_:function(e,t){let n=LS(e,"a","add"),r=LS(t,"b","add");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(lv,s)}});const aT=zS({floorDiv_:function(e,t){let n=LS(e,"a","floorDiv"),r=LS(t,"b","floorDiv");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(fw,s)}});const iT=zS({div_:function(e,t){let n=LS(e,"a","div"),r=LS(t,"b","div");if([n,r]=vS(n,r),"int32"===n.dtype&&"int32"===r.dtype)return aT(n,r);const s={a:n,b:r};return ES.runKernel(tw,s,{})}});const oT=zS({mul_:function(e,t){let n=LS(e,"a","mul"),r=LS(t,"b","mul");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(Yw,s)}});const lT=zS({sqrt_:function(e){const t={x:LS(e,"x","sqrt","float32")};return ES.runKernel(Lx,t)}});const uT=zS({square_:function(e){const t=LS(e,"x","square");return ES.runKernel("Square",{x:t},{})}});const cT=zS({zerosLike_:function(e){const t={x:LS(e,"x","zerosLike")};return ES.runKernel(uk,t)}});function hT(e){return ES.customGrad(e)}function dT(e,t){if((Hk(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Hk(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return US(e,[],[],t)}const pT=new Map,fT=new Map;class mT{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class gT{constructor(){this.classNameMap={}}static getMap(){return null==gT.instance&&(gT.instance=new gT),gT.instance}static register(e){gT.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function yT(e,t,n){wb(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),wb("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),wb(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return gT.register(e),pT.set(r,e),fT.set(e,r),e}class bT extends mT{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return KS(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){wb(zb(e),(()=>"The f passed in variableGrads(f) must be a function")),wb(null==t||Array.isArray(t)&&t.every((e=>e instanceof lS)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in ES.registeredVariables)t.push(ES.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),wb(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=ES.gradients(e,t,null,!0);wb(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),wb(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&KS(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:dT(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(bT,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class vT extends bT{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ES.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ES.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:qS((()=>cT(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:qS((()=>cT(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;qS((()=>{const e=sT(oT(i,this.rho),oT(uT(a),1-this.rho)),t=oT(iT(lT(sT(o,this.epsilon)),lT(sT(i,this.epsilon))),a),n=sT(oT(o,this.rho),oT(uT(t),1-this.rho));i.assign(e),o.assign(n);const s=sT(oT(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(KS(this.accumulatedGrads.map((e=>e.variable))),KS(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function wT(e,t,n){qb(e);const r={shape:e,value:t,dtype:n=n||Pb(t)};return ES.runKernel(hw,{},r)}class xT extends bT{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ES.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:qS((()=>wT(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;qS((()=>{const e=sT(a,uT(s));a.assign(e);const t=sT(oT(iT(s,lT(sT(e,ES.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&KS(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const kT=zS({pow_:function(e,t){let n=LS(e,"base","pow"),r=LS(t,"exp","pow");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(ix,s)}});const ST=zS({sub_:function(e,t){let n=LS(e,"a","sub"),r=LS(t,"b","sub");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(Zx,s)}});class IT extends bT{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],qS((()=>{this.accBeta1=dT(t).variable(),this.accBeta2=dT(n).variable()})),null==r&&(this.epsilon=ES.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);qS((()=>{const n=ST(1,this.accBeta1),r=ST(1,this.accBeta2);t.forEach(((t,s)=>{const a=ES.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:qS((()=>cT(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:qS((()=>cT(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=sT(oT(l,this.beta1),oT(o,1-this.beta1)),h=sT(oT(u,this.beta2),oT(uT(o),1-this.beta2)),d=iT(c,n),p=iT(h,r);l.assign(c),u.assign(h);const f=sT(oT(iT(d,sT(lT(p),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(oT(this.accBeta1,this.beta1)),this.accBeta2.assign(oT(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&KS(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&KS(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),qS((()=>{this.accBeta1.assign(kT(this.beta1,this.iterations_+1)),this.accBeta2.assign(kT(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const TT=zS({abs_:function(e){const t=LS(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return ES.runKernel($v,e)}{const e={x:t};return ES.runKernel(av,e)}}});function NT(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function ET(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function CT(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-s-1]=a}}return r}const _T=zS({maximum_:function(e,t){let n=LS(e,"a","maximum"),r=LS(t,"b","maximum");[n,r]=vS(n,r),"bool"===n.dtype&&(n=tT(n,"int32"),r=tT(r,"int32")),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Pw,s)}});class AT extends bT{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],qS((()=>{this.iteration=dT(0).variable(),this.accBeta1=dT(t).variable()})),null==r&&(this.epsilon=ES.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);qS((()=>{const n=ST(1,this.accBeta1),r=iT(-this.learningRate,sT(oT(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=ES.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:cT(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:cT(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=sT(oT(l,this.beta1),oT(o,1-this.beta1)),h=oT(u,this.beta2),d=TT(o),p=_T(h,d);l.assign(c),u.assign(p);const f=sT(oT(iT(r,n),iT(c,sT(p,this.epsilon))),a);a.assign(f)})),this.iteration.assign(sT(this.iteration,1)),this.accBeta1.assign(oT(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&KS(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&KS(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class RT extends bT{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=ES.registeredVariables[t];qS((()=>{const e=sT(oT(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=XS(dT(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class $T extends RT{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=dT(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ES.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:qS((()=>cT(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&qS((()=>{let e;const t=sT(oT(this.m,s),a);e=this.useNesterov?sT(oT(this.c,sT(a,oT(t,this.m))),r):sT(oT(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&KS(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class OT extends bT{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=ES.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ES.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:qS((()=>cT(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:qS((()=>cT(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:qS((()=>cT(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;qS((()=>{const e=sT(oT(i,this.decay),oT(uT(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=sT(oT(t,this.decay),oT(a,1-this.decay)),l=iT(oT(a,this.learningRate),lT(ST(e,sT(uT(s),this.epsilon)))),u=sT(oT(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=ST(r,u);r.assign(c)}else{const e=sT(oT(i,this.decay),oT(uT(a),1-this.decay)),t=sT(oT(o,this.momentum),iT(oT(a,this.learningRate),lT(sT(e,this.epsilon))));i.assign(e),o.assign(t);const n=ST(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&KS(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&KS(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&KS(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const DT=[vT,xT,IT,AT,$T,OT,RT];function FT(e){return new Promise((e=>setTimeout(e))).then(e)}class LT{constructor(e){if(!ev().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(LT.URL_SCHEME)&&(e=e.slice(LT.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=jS.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=hI(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await FT((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await FT((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:fI(e)}}}}LT.URL_SCHEME="downloads://";class MT{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=pI(r,(e=>this.loadWeights(e)));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>cI(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=cI(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function PT(e){return new MT(e)}function zT(e,t,n,r){!function(e){wb(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){wb(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),wb(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),wb(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function BT(e,t){null==t&&(t={});const n=null==t.fetchFunc?ev().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await zT(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await zT(s,t.onProgress,.5,1)}async function UT(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return VT((e=>BT(e,{requestInit:r})))(e,t,n)}function VT(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=WS[l]*Sb(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),h={};let d=0;return l.forEach((e=>{const n=t[e].paths.length,r=new jS(c.slice(d,d+n));a[e].forEach((e=>{const t=eI(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)h[n]=t[n]})),d+=n})),h}}gI.registerSaveRouter((e=>ev().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(LT.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new LT(e)}(e.slice(LT.URL_SCHEME.length)):null));class WT{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(wb("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=ev().platform.fetch,wb(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&wb(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=hI(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=jS.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:fI(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(t5){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return pI(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=mI(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?ev().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[mI(e),await BT(t,this.loadOptions)]}}function jT(e){return null!=e.match(WT.URL_SCHEME_REGEX)}WT.URL_SCHEME_REGEX=/^https?:\/\//;const GT=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>jT(e))):jT(e),n)return HT(e,t)}return null};function HT(e,t){return new WT(e,t)}function qT(e,t){return HT(e,t)}gI.registerSaveRouter(GT),gI.registerLoadRouter(GT);class KT{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class XT{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class YT{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function QT(e,t,n,r){return new YT(JT(...arguments))}function JT(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new KT(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new KT({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new KT({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function ZT(e){return new XT(e)}function eN(e){return new XT(e)}function tN(e,t,n){if(kb(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=OS(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return US(e,t,r,n)}let nN;function rN(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=wk(hk,ES.backendName)){const n={pixels:e},r={numChannels:t};return ES.runKernel(hk,n,r)}const[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,h;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(null==nN)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");nN=new OffscreenCanvas(1,1).getContext("2d")}else nN=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});nN.canvas.width=l,nN.canvas.height=u,nN.drawImage(e,0,0,l,u),c=nN.getImageData(0,0,l,u).data}if(4===t)h=new Int32Array(c);else{const e=l*u;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=c[4*n+e]}return tN(h,[u,l,t],"int32")}const sN=zS({fromPixels_:rN}),aN=-2,iN=-1;function oN(e,t,n){const r=e.shape.length;wb(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),wb(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)wb(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function lN(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function uN(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function cN(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)0===a?s[t]=1:(s.splice(t,0,1),s.pop());return s}function hN(e,t,n){return n<=e?n:n-(t-1)}function dN(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function pN(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=fN(i,l,u,r,e),h=mN(o,l,u,s,e),d=cN(a,l,u,e)}else for(let p=0;p<u;p++)c[p]=yN(i,r,a,e,p,l),h[p]=bN(o,s,a,e,p,l),d[p]=gN(a,p,l);return{begin:c,end:h,strides:d}}function fN(e,t,n,r,s){const a=[...s],i=dN(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const s=hN(t,n,o);let i=r[s];e&1<<s&&(i=0),a[o]=i}return a}function mN(e,t,n,r,s){const a=[...s],i=dN(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const s=hN(t,n,o);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=s[o];a[o]<0&&(a[o]+=e),a[o]=yb(0,a[o],s[o])}return a}function gN(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function yN(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=yb(0,i,l-1),i}function bN(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?yb(0,i,l):yb(-1,i,l-1),i}function vN(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function wN(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function xN(e,t,n){let r;const s=e.shape.length;let a;return r="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{wb(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(wb(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function kN(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)c&&0!==(1<<b&o)&&h.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(aN),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(iN),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error(`strides[${b}] must be non-zero`);const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const r=[d.beginMask&1<<b,d.endMask&1<<b],s=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const a=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=SN(d.begin[b],0,d.strides[b],n,r,s),d.end[b]=SN(d.end[b],1,d.strides[b],n,r,s);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&a,f=f&&(0===b&&1===d.strides[b]||a);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[b]-d.begin[b],o=!0):t?(i=1,o=!0):a&&n>=0&&(i=d.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==d.strides[b]<0?0:Math.trunc(i/d.strides[b])+(i%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===aN&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==aN)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function SN(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const IN=zS({acos_:function(e){const t={x:LS(e,"x","acos")};return ES.runKernel(iv,t)}});const TN=zS({acosh_:function(e){const t={x:LS(e,"x","acosh")};return ES.runKernel(ov,t)}});const NN=zS({addN_:function(e){wb(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),wb(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>LS(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!Ib(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return ES.runKernel(uv,r)}});const EN=zS({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:LS(e,"x","all","bool")},s={axis:t,keepDims:n};return ES.runKernel(cv,r,s)}});const CN=zS({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:LS(e,"x","any","bool")},s={axis:t,keepDims:n};return ES.runKernel(hv,r,s)}});const _N=zS({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:LS(e,"x","argMax")},r={axis:t};return ES.runKernel(dv,n,r)}});const AN=zS({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:LS(e,"x","argMin")},r={axis:t};return ES.runKernel(pv,n,r)}});const RN=zS({asin_:function(e){const t={x:LS(e,"x","asin")};return ES.runKernel(fv,t)}});const $N=zS({asinh_:function(e){const t={x:LS(e,"x","asinh")};return ES.runKernel(mv,t)}});const ON=zS({atan_:function(e){const t={x:LS(e,"x","atan")};return ES.runKernel(gv,t)}});const DN=zS({atan2_:function(e,t){let n=LS(e,"a","atan2"),r=LS(t,"b","atan2");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(bv,s)}});const FN=zS({atanh_:function(e){const t={x:LS(e,"x","atanh")};return ES.runKernel(yv,t)}});function LN(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5?arguments[5]:void 0;return zN(e,[...t,e[3]],n,a,r,null,null,XN(s))}function MN(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=VN(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return zN(e,u,n,r,s,a,!1,i)}function PN(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=WN(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,l,u,e[1],e[1]]}return BN(e,c,n,r,s,!1,h,a)}function zN(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=e}const[d,p,,f]=t,[m,g]=VN(n),[y,b]=VN(r),v=jN(d,y),w=jN(p,b),{padInfo:x,outHeight:k,outWidth:S}=function(e,t,n,r,s,a,i,o,l){let u,c,h;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=UN(e,t,n));const a=e[0],i=e[1],o=GN((a-t+2*r)/n+1,s),l=GN((i-t+2*r)/n+1,s);return[o,l]}([t,n],a,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),l=Math.floor(e/2),d=e-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=GN((t-a+d+p)/r+1,o),h=GN((n-i+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,m,g,v,w,a,o),I=i?f*h:f;let T;return"channelsFirst"===o?T=[l,I,k,S]:"channelsLast"===o&&(T=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:T,filterShape:t}}function BN(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c,h]=e}const[p,f,m,,g]=t,[y,b,v]=WN(n),[w,x,k]=WN(r),S=jN(p,w),I=jN(f,x),T=jN(m,k),{padInfo:N,outDepth:E,outHeight:C,outWidth:_}=function(e,t,n,r,s,a,i,o,l,u,c){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=UN(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=GN((e[o]-t[o]+2*s)/r[o]+1,a));return i}([t,n,r,1],[o,l,u],1,[s,a,i],e,c);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+o-t,c=(p-1)*a+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,w=Math.floor(m/2);h={top:b,bottom:v,left:w,right:m-w,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,y,b,v,S,I,T,o),A=a?g*d:g;let R;return"channelsFirst"===i?R=[l,A,E,C,_]:"channelsLast"===i&&(R=[l,E,C,_,A]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:E,outHeight:C,outWidth:_,outChannels:A,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:T,dilationDepth:w,dilationHeight:x,dilationWidth:k,inShape:e,outShape:R,filterShape:t}}function UN(e,t,n){const r=jN(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function VN(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function WN(e){return"number"===typeof e?[e,e,e]:e}function jN(e,t){return t<=1?e:e+(e-1)*(t-1)}function GN(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function HN(e){const[t,n,r]=VN(e);return 1===t&&1===n&&1===r}function qN(e,t){return HN(e)||HN(t)}function KN(e){return VN(e).every((e=>e>0))}function XN(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function YN(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)wb(Tb(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{wb(Tb(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const QN=zS({reshape_:function(e,t){const n={x:LS(e,"x","reshape","string_or_numeric")},r={shape:t};return ES.runKernel(gx,n,r)}});const JN=zS({avgPool_:function(e,t,n,r,s){const a=LS(e,"x","avgPool","float32");wb(qN(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=QN(a,[1,a.shape[0],a.shape[1],a.shape[2]])),wb(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),YN("avgPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=ES.runKernel(vv,l,u);return c=tT(c,a.dtype),o?QN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const ZN=zS({avgPool3d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=LS(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=QN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),wb(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),wb("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),wb("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),YN("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=ES.runKernel(xv,u,c);return h=tT(h,o.dtype),l?QN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const eE=zS({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;wb(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=MS(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return nT(n[0]);const r=n,s={axis:t};return ES.runKernel(Ov,r,s)}});const tE=zS({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=LS(e,"a","matMul"),a=LS(t,"b","matMul");[s,a]=vS(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return ES.runKernel(Sv,i,o)}});const nE=zS({sigmoid_:function(e){const t={x:LS(e,"x","sigmoid","float32")};return ES.runKernel(Dx,t)}});const rE=zS({slice_:function(e,t,n){const r=LS(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return ES.runKernel(Ax,s,a)}});const sE=zS({tanh_:function(e){const t={x:LS(e,"x","tanh","float32")};return ES.runKernel(tk,t)}});const aE=zS({basicLSTMCell_:function(e,t,n,r,s,a){const i=LS(e,"forgetBias","basicLSTMCell"),o=LS(t,"lstmKernel","basicLSTMCell"),l=LS(n,"lstmBias","basicLSTMCell"),u=LS(r,"data","basicLSTMCell"),c=LS(s,"c","basicLSTMCell"),h=LS(a,"h","basicLSTMCell"),d=eE([u,h],1),p=tE(d,o),f=sT(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=rE(f,[0,0],y),v=rE(f,[0,g],y),w=rE(f,[0,2*g],y),x=rE(f,[0,3*g],y),k=sT(oT(nE(b),sE(v)),oT(c,nE(sT(i,w))));return[k,oT(sE(k),nE(x))]}});const iE=zS({batchToSpaceND_:function(e,t,n){const r=LS(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));wb(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),wb(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),wb(r.shape[0]%s===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return ES.runKernel(Iv,a,i)}});const oE=zS({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=LS(e,"x","batchNorm"),o=LS(t,"mean","batchNorm"),l=LS(n,"variance","batchNorm");let u,c;null!=s&&(u=LS(s,"scale","batchNorm")),null!=r&&(c=LS(r,"offset","batchNorm")),wb(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),wb(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),wb(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h=function(e){let t;return t=0===e.rank||1===e.rank?QN(e,[1,1,1,e.size]):2===e.rank?QN(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?QN(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),d={x:h,scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:a},f=ES.runKernel(mw,d,p);return QN(f,i.shape)}});const lE=zS({batchNorm2d_:function(e,t,n,r,s,a){const i=LS(e,"x","batchNorm"),o=LS(t,"mean","batchNorm"),l=LS(n,"variance","batchNorm");let u,c;return null!=s&&(u=LS(s,"scale","batchNorm")),null!=r&&(c=LS(r,"offset","batchNorm")),wb(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),wb(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),wb(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&wb(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&wb(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),oE(i,o,l,c,u,a)}});const uE=zS({batchNorm3d_:function(e,t,n,r,s,a){const i=LS(e,"x","batchNorm"),o=LS(t,"mean","batchNorm"),l=LS(n,"variance","batchNorm");let u,c;return null!=s&&(u=LS(s,"scale","batchNorm")),null!=r&&(c=LS(r,"offset","batchNorm")),wb(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),wb(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),wb(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&wb(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&wb(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),oE(i,o,l,c,u,a)}});const cE=zS({batchNorm4d_:function(e,t,n,r,s,a){const i=LS(e,"x","batchNorm"),o=LS(t,"mean","batchNorm"),l=LS(n,"variance","batchNorm");let u,c;return null!=s&&(u=LS(s,"scale","batchNorm")),null!=r&&(c=LS(r,"offset","batchNorm")),wb(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),wb(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),wb(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&wb(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&wb(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),oE(i,o,l,c,u,a)}});const hE=zS({bincount_:function(e,t,n){const r=LS(e,"x","bincount"),s=LS(t,"weights","bincount");wb("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),wb(n>=0,(()=>`size must be non-negative, but got ${n}.`)),wb(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return ES.runKernel(Tv,a,i)}});const dE=zS({bitwiseAnd_:function(e,t){const n=LS(e,"x","bitwiseAnd"),r=LS(t,"y","bitwiseAnd");if(!Ib(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return ES.runKernel(Nv,s)}});const pE=zS({broadcastArgs_:function(e,t){const n=LS(e,"s0","broadcastArgs","int32"),r=LS(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return ES.runKernel(Ev,s)}});const fE=zS({broadcastTo_:function(e,t){let n=LS(e,"broadcastTo","x");const r=n.shape;if(qb(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=QN(n,e)}const s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return nT(n);const i={x:n},o={reps:a};return ES.runKernel(nk,i,o)}});const mE=zS({ceil_:function(e){const t={x:LS(e,"x","ceil","float32")};return ES.runKernel(_v,t)}});const gE=zS({clipByValue_:function(e,t,n){const r=LS(e,"x","clipByValue");if(wb(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return wT(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return ES.runKernel(Av,s,a)}});const yE=zS({concat1d_:function(e){return eE(e,0)}});const bE=zS({concat2d_:function(e,t){return eE(e,t)}});const vE=zS({concat3d_:function(e,t){return eE(e,t)}});const wE=zS({concat4d_:function(e,t){return eE(e,t)}});const xE=zS({conv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=LS(e,"x","conv2d","float32"),l=LS(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=QN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),wb(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),wb(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),YN("conv2d",r,i);const h="NHWC"===s?u.shape[3]:u.shape[1];wb(h===l.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`)),wb(qN(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),wb(KN(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),wb(KN(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ES.runKernel(Dv,d,p);return c?QN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const kE=zS({conv1d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=LS(e,"x","conv1d"),l=LS(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=QN(o,[1,o.shape[0],o.shape[1]])),wb(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),wb(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),YN("conv1d",r,i),wb(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),wb(qN(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),wb(KN(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),wb(KN(n),(()=>"Error in conv1D: Stride should be larger than 0.")),wb("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const h=QN(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=QN(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=xE(d,h,[1,n],r,"NHWC",[1,a],i);return QN(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const SE=zS({conv2DBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;wb(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=QN(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),wb(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),wb(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),wb(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?l.shape[3]:l.shape[1];wb(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),wb(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),YN("conv2dDerInput",s,i);const d={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=ES.runKernel(Lv,d,p);return u?QN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const IE=zS({conv2dTranspose_:function(e,t,n,r,s,a){const i=LS(e,"x","conv2dTranspose"),o=LS(t,"filter","conv2dTranspose");return SE(n,i,o,r,s,"NHWC",a)}});const TE=zS({conv3d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=LS(e,"x","conv3d"),o=LS(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=QN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),wb(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),wb(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),wb(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),wb(qN(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),wb("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),wb(KN(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),wb(KN(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},d=ES.runKernel(Mv,c,h);return u?QN(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const NE=zS({conv3DBackpropInput_:function(e,t,n,r,s){wb(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=QN(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];wb(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),wb(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),wb(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),wb(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),wb(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},d=ES.runKernel(zv,c,h);return o?QN(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const EE=zS({conv3dTranspose_:function(e,t,n,r,s){const a=LS(e,"x","conv3dTranspose"),i=LS(t,"filter","conv3dTranspose");return NE(n,a,i,r,s)}});const CE=zS({cos_:function(e){const t={x:LS(e,"x","cos","float32")};return ES.runKernel(Bv,t)}});const _E=zS({cosh_:function(e){const t={x:LS(e,"x","cosh","float32")};return ES.runKernel(Uv,t)}});const AE=zS({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:LS(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return ES.runKernel(Vv,s,a)}});const RE=zS({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:LS(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return ES.runKernel(Wv,s,a)}});const $E=zS({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=LS(e,"x","denseBincount"),a=LS(t,"weights","denseBincount");wb("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),wb(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),wb(n>=0,(()=>`size must be non-negative, but got ${n}.`)),wb(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return ES.runKernel(Gv,i,o)}});const OE=zS({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=LS(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];wb(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),wb(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),wb(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),wb(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return ES.runKernel(Hv,o,l)}});const DE=zS({depthwiseConv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=LS(e,"x","depthwiseConv2d","float32"),l=LS(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=QN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),wb(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),wb(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const h="NHWC"===s?u.shape[3]:u.shape[1];wb(h===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`)),YN("depthwiseConv2d",r,i);const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ES.runKernel(qv,d,p);return c?QN(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const FE=zS({diag_:function(e){const t={x:LS(e,"x","diag")};return ES.runKernel(Yv,t)}});const LE=zS({dilation2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=LS(e,"x","dilation2d"),o=LS(t,"filter","dilation2d");wb(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),wb(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),wb("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let l=i,u=!1;3===i.rank&&(l=QN(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),wb(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},h={strides:n,pad:r,dilations:s},d=ES.runKernel(Qv,c,h);return u?QN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const ME=zS({equal_:function(e,t){let n=LS(e,"a","equal","string_or_numeric"),r=LS(t,"b","equal","string_or_numeric");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(iw,s)}});const PE=zS({where_:function(e,t,n){const r=LS(t,"a","where"),s=LS(n,"b","where"),a=LS(e,"condition","where","bool"),i=CT(CT(a.shape,r.shape),s.shape),o={condition:fE(a,i),t:fE(r,i),e:fE(s,i)};return ES.runKernel(Cx,o)}});const zE=zS({divNoNan_:function(e,t){let n=LS(e,"a","div"),r=LS(t,"b","div");[n,r]=vS(n,r);const s=iT(n,r),a=cT(s),i=ME(r,a);return PE(i,a,s)}});const BE=zS({dot_:function(e,t){const n=LS(e,"t1","dot"),r=LS(t,"t2","dot");wb((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(wb(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=QN(n,[1,-1]),t=QN(r,[-1,1]),s=tE(e,t);return QN(s,[])}if(1===n.rank&&2===r.rank){const e=QN(n,[1,-1]),t=QN(r,[r.shape[0],r.shape[1]]),s=tE(e,t);return QN(s,[s.size])}if(2===n.rank&&1===r.rank){const e=QN(r,[-1,1]),t=tE(n,e);return QN(t,[t.size])}{const e=QN(r,[r.shape[0],r.shape[1]]);return tE(n,e)}}});const UE=zS({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(((e,t)=>LS(e,`tensors${t}`,"einsum"))),a={equation:e};return ES.runKernel(nw,s,a)}});const VE=zS({elu_:function(e){const t={x:LS(e,"x","elu","float32")};return ES.runKernel(rw,t)}});const WE=zS({ensureShape_:function(e,t){const n=LS(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const jE=zS({erf_:function(e){let t=LS(e,"x","erf");wb("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=tT(t,"float32"));const n={x:t};return ES.runKernel(aw,n)}});function GE(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function HE(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function qE(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function KE(e,t){return HE(e,t.map((e=>1)),t)}function XE(e,t,n){wb(GE(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function YE(e,t){if(GE(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function QE(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function JE(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const ZE=zS({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:LS(e,"x","max")},s={reductionIndices:t,keepDims:n};return ES.runKernel(Mw,r,s)}});const eC=zS({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:LS(e,"x","min")},s={axis:t,keepDims:n};return ES.runKernel(Gw,r,s)}});const tC=zS({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=LS(e,"x","sum");"bool"===r.dtype&&(r=tT(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return ES.runKernel(Mx,s,a)}});function nC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return TT(e);if(1!==e.rank&&null===n)return nC(QN(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return tC(TT(e),n);if(t===1/0)return ZE(TT(e),n);if(t===-1/0)return eC(TT(e),n);if("euclidean"===t||2===t)return lT(tC(kT(TT(e),dT(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return ZE(tC(TT(e),n[0]),n[1]-1);if(t===1/0)return ZE(tC(TT(e),n[1]),n[0]);if(t===-1/0)return eC(tC(TT(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return lT(tC(uT(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const rC=zS({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=nC(e=LS(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Ab(n,e.shape);a=KE(s.shape,t)}return QN(s,a)}});const sC=zS({euclideanNorm_:function(e){return rC(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const aC=zS({exp_:function(e){const t={x:LS(e,"x","exp")};return ES.runKernel(ow,t)}});const iC=zS({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=LS(e,"x","expandDims","string_or_numeric");wb(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return ES.runKernel(lw,r,s)}});const oC=zS({expm1_:function(e){const t={x:LS(e,"x","expm1")};return ES.runKernel(uw,t)}});const lC=zS({tile_:function(e,t){const n=LS(e,"x","tile","string_or_numeric");wb(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return ES.runKernel(nk,r,s)}});const uC=zS({eye_:function(e,t,n){null==t&&(t=e);const r=eT([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=e<=t?e:t;for(let i=0;i<s;++i)r.set(1,i,i);const a=QN(r.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return lC(iC(a,0),[n[0],1,1]);if(2===n.length)return lC(iC(iC(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return lC(iC(iC(iC(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const cC=zS({floor_:function(e){const t={x:LS(e,"x","floor","float32")};return ES.runKernel(pw,t)}});const hC=zS({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const s={x:LS(e,"x","gather"),indices:LS(t,"indices","gather","int32")},a={axis:n,batchDims:r};return ES.runKernel(gw,s,a)}});const dC=zS({greater_:function(e,t){let n=LS(e,"a","greater","string_or_numeric"),r=LS(t,"b","greater","string_or_numeric");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(bw,s)}});const pC=zS({greaterEqual_:function(e,t){let n=LS(e,"a","greaterEqual","string_or_numeric"),r=LS(t,"b","greaterEqual","string_or_numeric");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(vw,s)}});const fC=zS({imag_:function(e){const t={input:LS(e,"input","imag")};return ES.runKernel(kw,t)}});const mC=zS({isFinite_:function(e){const t={x:LS(e,"x","isFinite")};return ES.runKernel(Sw,t)}});const gC=zS({isInf_:function(e){const t={x:LS(e,"x","isInf")};return ES.runKernel(Iw,t)}});const yC=zS({isNaN_:function(e){const t={x:LS(e,"x","isNaN")};return ES.runKernel(Tw,t)}});const bC=zS({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:LS(e,"x","leakyRelu")},r={alpha:t};return ES.runKernel(Nw,n,r)}});const vC=zS({less_:function(e,t){let n=LS(e,"a","less","string_or_numeric"),r=LS(t,"b","less","string_or_numeric");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Ew,s)}});const wC=zS({lessEqual_:function(e,t){let n=LS(e,"a","lessEqual","string_or_numeric"),r=LS(t,"b","lessEqual","string_or_numeric");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Cw,s)}});function xC(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return ES.runKernel(_w,{},r)}const kC=zS({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const a=LS(e,"x","localResponseNormalization");wb(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),wb(Tb(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=QN(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=ES.runKernel(Fw,l,u);return o?QN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const SC=zS({log_:function(e){const t={x:LS(e,"x","log","float32")};return ES.runKernel(Aw,t)}});const IC=zS({log1p_:function(e){const t={x:LS(e,"x","log1p")};return ES.runKernel(Rw,t)}});const TC=zS({neg_:function(e){const t={x:LS(e,"x","neg")};return ES.runKernel(Qw,t)}});const NC=zS({softplus_:function(e){const t={x:LS(e,"x","softplus")};return ES.runKernel(Fx,t)}});const EC=zS({logSigmoid_:function(e){const t=LS(e,"x","logSigmoid"),n=hT((e=>({value:TC(NC(TC(e))),gradFunc:t=>oT(t,nE(TC(e)))})));return n(t)}});const CC=zS({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=LS(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=hT(((e,n)=>{const r=ZE(e,t,!0),s=ST(e,r),a=ST(tT(s,"float32"),SC(tC(aC(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=aC(r);return ST(e,oT(tC(e,t,!0),s))}}}));return r(n)}});const _C=zS({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=LS(e,"x","logSumExp"),s=Ab(t,r.shape),a=ZE(r,s,!0),i=ST(r,a),o=aC(i),l=tC(o,s),u=SC(l),c=sT(QN(a,u.shape),u);if(n){const e=KE(c.shape,s);return QN(c,e)}return c}});const AC=zS({logicalAnd_:function(e,t){const n=LS(e,"a","logicalAnd","bool"),r=LS(t,"b","logicalAnd","bool");CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel($w,s)}});const RC=zS({logicalNot_:function(e){const t={x:LS(e,"x","logicalNot","bool")};return ES.runKernel(Ow,t)}});const $C=zS({logicalOr_:function(e,t){const n=LS(e,"a","logicalOr","bool"),r=LS(t,"b","logicalOr","bool");CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Dw,s)}});const OC=zS({logicalXor_:function(e,t){const n=LS(e,"a","logicalXor","bool"),r=LS(t,"b","logicalXor","bool");return CT(n.shape,r.shape),AC($C(e,t),RC(AC(e,t)))}}),DC=2147483648;const FC=zS({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=LS(e,"sortedSequence","searchSorted"),s=LS(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=QN(r,[-1,a]),l=QN(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Sb(l.shape)>=DC)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=DC)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return ES.runKernel(Ex,u,c)}});function LC(e,t){return FC(e,t,"left")}const MC=zS({maxPool_:function(e,t,n,r,s){const a=LS(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=QN(a,[1,a.shape[0],a.shape[1],a.shape[2]])),wb(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),wb(qN(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),YN("maxPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=ES.runKernel(zw,l,u);return o?QN(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const PC=zS({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=LS(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=QN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),wb(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),wb("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),YN("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=ES.runKernel(Uw,u,c);return l?QN(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const zC=zS({maxPoolWithArgmax_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const a={x:LS(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=ES.runKernel(Ww,a,i);return{result:o[0],indexes:o[1]}}});const BC=zS({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:LS(e,"x","mean")},s={axis:t,keepDims:n};return ES.runKernel(jw,r,s)}});function UC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(qb(e),"complex64"===t){const t=UC(e,"float32"),n=UC(e,"float32");return BS(t,n)}const n=Gb(Sb(e),t);return ES.makeTensor(n,e,t)}function VC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(qb(e),"complex64"===t){const t=VC(e,"float32"),n=UC(e,"float32");return BS(t,n)}const n=jb(Sb(e),t);return ES.makeTensor(n,e,t)}function WC(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=LS(e,"x","meshgrid",e instanceof iS?e.dtype:"float32");if(void 0===t)return[r];let s=LS(t,"y","meshgrid",t instanceof iS?t.dtype:"float32");const a=Sb(r.shape),i=Sb(s.shape);return"xy"===n?(r=QN(r,[1,-1]),s=QN(s,[-1,1]),[tE(VC([i,1],r.dtype),r),tE(s,VC([1,a],s.dtype))]):(r=QN(r,[-1,1]),s=QN(s,[1,-1]),[tE(r,VC([1,i],r.dtype)),tE(VC([a,1],s.dtype),s)])}const jC=zS({minimum_:function(e,t){let n=LS(e,"a","minimum"),r=LS(t,"b","minimum");[n,r]=vS(n,r),"bool"===n.dtype&&(n=tT(n,"int32"),r=tT(r,"int32")),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Hw,s)}});const GC=zS({mirrorPad_:function(e,t,n){wb("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=LS(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");wb(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)wb(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),wb(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return ES.runKernel(qw,i,a)}});const HC=zS({mod_:function(e,t){let n=LS(e,"a","mod"),r=LS(t,"b","mod");[n,r]=vS(n,r);const s={a:n,b:r};return ES.runKernel(Kw,s)}});const qC=zS({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Ab(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=LS(e,"x","moments")).shape),r=BC(e,n,t);let s=r.shape;t||(s=KE(r.shape,n));const a=uT(ST(tT(e,"float32"),QN(r,s)));return{mean:r,variance:BC(a,n,t)}}});const KC=zS({multiRNNCell_:function(e,t,n,r){const s=LS(t,"data","multiRNNCell"),a=MS(n,"c","multiRNNCell"),i=MS(r,"h","multiRNNCell");let o=s;const l=[];for(let h=0;h<e.length;h++){const t=e[h](o,a[h],i[h]);l.push(t[0]),l.push(t[1]),o=t[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}});const XC=zS({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=LS(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?QN(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=ES.runKernel(Xw,o,l);return 1===i?QN(u,[u.size]):u}});const YC=zS({notEqual_:function(e,t){let n=LS(e,"a","notEqual","string_or_numeric"),r=LS(t,"b","notEqual","string_or_numeric");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Jw,s)}});const QC=zS({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:LS(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return ES.runKernel(rx,a,i)}});const JC=zS({onesLike_:function(e){const t={x:LS(e,"x","onesLike")};return ES.runKernel(nx,t)}});const ZC=zS({outerProduct_:function(e,t){const n=LS(e,"v1","outerProduct"),r=LS(t,"v2","outerProduct");wb(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=QN(n,[-1,1]),a=QN(r,[1,-1]);return tE(s,a)}});const e_=zS({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=LS(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return ES.runKernel(ax,a,s)}});const t_=zS({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return wb(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),e_(e,[t],n)}});const n_=zS({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return wb(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),e_(e,t,n)}});const r_=zS({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return wb(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),e_(e,t,n)}});const s_=zS({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return wb(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),e_(e,t,n)}});const a_=zS({spaceToBatchND_:function(e,t,n){const r=LS(e,"x","spaceToBatchND");wb(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),wb(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),wb(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return ES.runKernel(Px,s,a)}});const i_=zS({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=LS(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=QN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),wb(qN(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=MN(l.shape,t,a,s,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",y=p?l:a_(l,h,f),b=("avg"===n?()=>JN(y,t,a,g,i):()=>MC(y,t,a,g,i))(),v=p?b:iE(b,h,m);return u?QN(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const o_=zS({prelu_:function(e,t){const n={x:LS(e,"x","prelu"),alpha:LS(t,"alpha","prelu")};return ES.runKernel(ox,n)}});const l_=zS({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=LS(e,"x","prod");"bool"===r.dtype&&(r=tT(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return ES.runKernel(lx,s,a)}});const u_=zS({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>LS(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:LS(t,"paramsDenseValues","raggedGather"),indices:LS(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=ES.runKernel(ux,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const c_=zS({raggedRange_:function(e,t,n){const r=LS(e,"starts","raggedRange"),s={starts:r,limits:LS(t,"limits","raggedRange",r.dtype),deltas:LS(n,"deltas","raggedRange",r.dtype)},a=ES.runKernel(cx,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}});const h_=zS({raggedTensorToTensor_:function(e,t,n,r,s){const a=LS(e,"shape","raggedTensorToTensor","int32"),i=LS(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:LS(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>LS(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:s};return ES.runKernel(hx,o,l)}});const d_=zS({rand_:function(e,t,n){qb(e);const r=Sb(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let a=0;a<r;a++)s[a]=t();return ES.makeTensor(s,e,n)}});var p_=n(4334);class f_{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=p_.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class m_{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=p_.alea(s.toString()),this.randn=new f_(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class g_{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=p_.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const y_=zS({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;if(qb(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new m_(t,n,r,s),i=eT(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const b_=zS({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(qb(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new f_(t,n,r,!1,s),i=eT(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const v_=zS({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return b_(e,0,1,t,n)}});const w_=zS({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;qb(e);const a=eT(e,r),i=new g_(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});const x_=zS({randomUniformInt_:function(e,t,n,r){return w_(e,t,n,"int32",r)}});function k_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return ES.runKernel(dx,{},s)}const S_=zS({real_:function(e){const t={input:LS(e,"input","real")};return ES.runKernel(px,t)}});const I_=zS({reciprocal_:function(e){const t={x:LS(e,"x","reciprocal")};return ES.runKernel(fx,t)}});const T_=zS({relu_:function(e){const t={x:LS(e,"x","relu")};return ES.runKernel(mx,t)}});const N_=zS({relu6_:function(e){const t={x:LS(e,"x","relu6")};return ES.runKernel(xx,t)}});const E_=zS({reverse_:function(e,t){const n={x:LS(e,"x","reverse")},r={dims:t};return ES.runKernel(kx,n,r)}});const C_=zS({reverse1d_:function(e){const t=LS(e,"x","reverse");return wb(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),E_(t,0)}});const __=zS({reverse2d_:function(e,t){const n=LS(e,"x","reverse");return wb(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),E_(n,t)}});const A_=zS({reverse3d_:function(e,t){const n=LS(e,"x","reverse");return wb(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),E_(n,t)}});const R_=zS({reverse4d_:function(e,t){const n=LS(e,"x","reverse");return wb(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),E_(n,t)}});const $_=zS({round_:function(e){const t={x:LS(e,"x","round")};return ES.runKernel(Sx,t)}});const O_=zS({rsqrt_:function(e){const t={x:LS(e,"x","rsqrt","float32")};return ES.runKernel(Ix,t)}});const D_=zS({selu_:function(e){const t={x:LS(e,"x","selu")};return ES.runKernel(_x,t)}});const F_=zS({separableConv2d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=LS(e,"x","separableConv2d"),l=LS(t,"depthwiseFilter","separableConv2d"),u=LS(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=QN(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");wb(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),wb(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),wb(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),wb(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),wb(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];wb(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=DE(c,l,r,s,i,a),m=xE(f,u,1,"valid",i);return h?QN(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const L_=async function(e,t){const n=LS(e,"x","setdiff1d"),r=LS(t,"y","setdiff1d");wb(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),wb(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),wb(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const l=new nS([o],n.dtype),u=new nS([o],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]};const M_=zS({sign_:function(e){const t={x:LS(e,"x","sign")};return ES.runKernel(Ox,t)}});const P_=zS({sin_:function(e){const t={x:LS(e,"x","sin","float32")};return ES.runKernel(Rx,t)}});const z_=zS({sinh_:function(e){const t={x:LS(e,"x","sinh")};return ES.runKernel($x,t)}});const B_=zS({slice1d_:function(e,t,n){const r=LS(e,"x","slice1d");return wb(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),rE(r,[t],[n])}});const U_=zS({slice2d_:function(e,t,n){const r=LS(e,"x","slice2d");return wb(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),rE(r,t,n)}});const V_=zS({slice3d_:function(e,t,n){const r=LS(e,"x","slice3d");return wb(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),rE(r,t,n)}});const W_=zS({slice4d_:function(e,t,n){const r=LS(e,"x","slice4d");return wb(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),rE(r,t,n)}});const j_=zS({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=LS(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return ES.runKernel(Bx,r,s)}});const G_=zS({fft_:function(e){wb("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ES.runKernel(cw,t)}});const H_=zS({ifft_:function(e){wb("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ES.runKernel(xw,t)}});const q_=zS({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=QN(e,[n,t]);r=H_(s)}else{const s=[n,2*(t-1)],a=QN(S_(e),[n,t]),i=QN(fC(e),[n,t]),o=E_(rE(a,[0,1],[n,t-2]),1),l=oT(E_(rE(i,[0,1],[n,t-2]),1),dT(-1)),u=eE([a,o],1),c=eE([i,l],1),h=QN(BS(u,c),[s[0],s[1]]);r=H_(h)}if(r=S_(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=QN(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const K_=zS({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:LS(e,"x","split")},s={numOrSizeSplits:t,axis:n};return ES.runKernel(zx,r,s)}});const X_=zS({rfft_:function(e,t){wb("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=rE(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=eE([e,UC(r)],e.shape.length-1),n=t}else s=e;const a=cT(s),i=QN(BS(s,a),[r,n]),o=G_(i),l=Math.floor(n/2)+1,u=S_(o),c=fC(o),h=K_(u,[l,n-l],u.shape.length-1),d=K_(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,QN(BS(h[0],d[0]),p)}});const Y_=zS({squaredDifference_:function(e,t){let n=LS(e,"a","squaredDifference"),r=LS(t,"b","squaredDifference");[n,r]=vS(n,r),CT(n.shape,r.shape);const s={a:n,b:r};return ES.runKernel(Hx,s,{})}});const Q_=zS({squeeze_:function(e,t){const n=LS(e,"x","squeeze","string_or_numeric");return QN(n,Rb(n.shape,t).newShape)}});const J_=zS({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=MS(e,"tensors","stack","string_or_numeric");wb(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&wb(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return ES.runKernel(sx,r,s)}});const Z_=zS({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:LS(e,"x","step")},r={alpha:t};return ES.runKernel(ck,n,r)}});const eA=zS({stridedSlice_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:LS(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ES.runKernel(Xx,u,c)}});const tA=zS({tan_:function(e){const t={x:LS(e,"x","tan","float32")};return ES.runKernel(ek,t)}});function nA(e,t){kb(e);const n=OS(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return US(e,null,n,t)}function rA(e,t,n){if(kb(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=OS(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return US(e,t,r,n)}function sA(e,t,n){if(kb(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=OS(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return US(e,t,r,n)}function aA(e,t,n){if(kb(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=OS(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return US(e,t,r,n)}function iA(e,t,n){if(kb(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=OS(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return US(e,t=t||r,r,n)}function oA(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function lA(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}oA(n,t,e)}function uA(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let l=s;l<a;++l)i*=n[l];const o=s<1?1:s;return{sliceRank:s,numUpdates:Sb(t.shape)/o,sliceSize:i,strides:[...Ub(n.slice(0,s)),1],outputSize:Sb(n)}}const cA=zS({tensorScatterUpdate_:function(e,t,n){const r=LS(e,"tensor","tensorScatterupdate"),s=LS(t,"indices","tensorScatterupdate","int32"),a=LS(n,"updates","tensorScatterupdate");if(lA(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return ES.runKernel(Nx,i,{})}});const hA=zS({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=LS(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=ES.runKernel(rk,a,i);return{values:o,indices:l}}});const dA=zS({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(qb(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new f_(t,n,r,!0,s),i=eT(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const pA=zS({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=LS(e,"x","unique","string_or_numeric");wb(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=ES.runKernel(ik,r,s);return{values:a,indices:i}}});const fA=zS({unsortedSegmentSum_:function(e,t,n){const r=LS(e,"x","unsortedSegmentSum"),s=LS(t,"segmentIds","unsortedSegmentSum","int32");wb(Tb(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return ES.runKernel(lk,a,i)}});const mA=zS({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=LS(e,"x","unstack","string_or_numeric");wb(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return ES.runKernel(ok,r,s)}});function gA(e,t){return FC(e,t,"right")}function yA(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return ES.makeVariable(e,t,n,r)}function bA(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=eT(e,"int32"),s=eT([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}const vA=async function(e){const t=LS(e,"condition","whereAsync","bool"),n=await t.data(),r=bA(t.shape,n);return e!==t&&t.dispose(),r};const wA=async function(e,t,n){const r=LS(e,"tensor","boolMask"),s=LS(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;wb(i>0,(()=>"mask cannot be scalar")),xb(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=QN(r,u),h=QN(s,[-1]),d=await vA(h),p=Q_(d,[1]),f=hC(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f};const xA=zS({transpose_:function(e,t,n){const r=LS(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),wb(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{wb(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?qS((()=>{let e=S_(r),t=fC(r);return e=ES.runKernel(ak,{x:e},a),t=ES.runKernel(ak,{x:t},a),n&&(t=TC(t)),BS(e,t)})):ES.runKernel(ak,s,a)}});const kA=zS({movingAverage_:function(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const a=LS(e,"v","movingAverage"),i=LS(t,"x","movingAverage"),o=LS(n,"decay","movingAverage");!function(e,t){wb(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}(a,i),wb(Ib(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const l=dT(1),u=ST(l,o);let c=oT(ST(i,a),u);if(s){wb(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=LS(r,"step","movingAverage");c=iT(c,ST(l,kT(o,e)))}return sT(a,c)}});const SA=zS({scatterND_:function(e,t,n){qb(n);const r=LS(e,"indices","scatterND","int32"),s=LS(t,"updates","scatterND");lA(s,r,n);const a={indices:r,updates:s},i={shape:n};return ES.runKernel(Tx,a,i)}});const IA=zS({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;qb(n);const s=LS(e,"sparseIndices","sparseToDense","int32"),a=LS(t,"sparseValues","sparseToDense","string_or_numeric"),i=LS(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return ES.runKernel(Gx,o,l)}});const TA=zS({gatherND_:function(e,t){const n=LS(t,"indices","gatherND","int32"),r={params:LS(e,"x","gatherND","string_or_numeric"),indices:n};return ES.runKernel(yw,r)}});const NA=zS({dropout_:function(e,t,n,r){const s=LS(e,"x","dropout");if(wb("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),wb(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof iS?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(Ib(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=iT(cC(sT(w_(a,0,1,"float32",r),i)),i);return oT(s,o)}});function EA(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function CA(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return nA(s,"float32")}const _A=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=LS(e,"predictions","inTopK"),s=LS(t,"targets","inTopK");wb(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),wb(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),xb(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];wb(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=$b("bool",l);for(let h=0;h<l;h++){const e=h*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[h]=0;for(let s=0;s<n;s++)if(r[s].index===o[h]){c[h]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),VS(c,s.shape,"bool")};const AA=zS({conv2DBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=QN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=QN(t,[1,t.shape[0],t.shape[1],t.shape[2]])),wb(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),wb(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),wb(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];wb(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),wb(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),YN("conv2dDerFilter",s,i);const h={x:o,dy:l},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return ES.runKernel(Fv,h,d)}});function RA(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return oT(e,Z_(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function $A(e,t){let n=t;const r=ET(e.shape,t.shape);return r.length>0&&(n=tC(n,r)),QN(n,e.shape)}function OA(e,t,n,r){if("linear"===t)return e;if("relu"===t)return T_(e);if("elu"===t)return VE(e);if("relu6"===t)return N_(e);if("prelu"===t)return o_(e,n);if("leakyrelu"===t)return bC(e,r);if("sigmoid"===t)return nE(e);throw new Error(`Unknown fused activation ${t}.`)}const DA=(e,t)=>!(e>0)||"linear"===t;const FA=zS({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}=e;if(u=u||"linear",!1===DA(ES.state.gradientDepth,u)){wb("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=xE(t,n,r,s,a,i,o);return null!=l&&(e=sT(e,l)),OA(e,u,c,h)}const d=LS(t,"x","conv2d","float32"),p=LS(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=QN(d,[1,d.shape[0],d.shape[1],d.shape[2]])),wb(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),wb(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),YN("fused conv2d",s,o);const g="NHWC"===a?f.shape[3]:f.shape[1];wb(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),wb(qN(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const y=zN(f.shape,p.shape,r,i,s,o);let b,v;if(null!=l&&(b=LS(l,"bias","fused conv2d"),[b]=vS(b,d),"NHWC"===a?CT(y.outShape,b.shape):(wb(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),wb(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=c){const e=c.shape;if(wb(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)wb(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{CT(e,y.outShape)}catch(t5){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}v=LS(c,"prelu weights","fused conv2d")}const w=(e,t)=>{wb("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));const[n,o,l,c]=t,h=RA(e,l,u);wb(HN(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const d=[SE(o.shape,h,n,r,s),AA(o,h,n.shape,r,s)];if(null!=c){const e=$A(c,h);d.push(e)}return d},x={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};if(null==l){const e=hT(((e,t,n)=>{let r=ES.runKernel(fk,x,k);return n([t,e,r]),m&&(r=QN(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return e(f,p)}{const e=hT(((e,t,n,r)=>{let s=ES.runKernel(fk,x,k);return r([t,e,s,n]),m&&(s=QN(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:w}}));return e(f,p,b)}}});const LA=zS({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=QN(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=QN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return ES.runKernel(Kv,u,c)}});const MA=zS({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=QN(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},h=ES.runKernel(Xv,u,c);return l?QN(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const PA=zS({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}=e;if(!1===DA(ES.state.gradientDepth,u)){let e=DE(t,n,r,s,a,i,o);return null!=l&&(e=sT(e,l)),OA(e,u,c,h)}const d=LS(t,"x","depthwiseConv2d","float32"),p=LS(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=QN(d,[1,d.shape[0],d.shape[1],d.shape[2]])),wb(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),wb(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),wb(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),wb(qN(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),YN("fused depthwiseConv2d",s,o);const g=zN(f.shape,p.shape,r,i,s,o,!0);let y,b;null!=l&&(y=LS(l,"bias","fused conv2d"),[y]=vS(y,d),CT(g.outShape,y.shape)),null!=c&&(b=LS(c,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{wb(HN(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,a,l,c]=t,h=RA(e,l,u),d=MA(a.shape,h,n,r,s,i,o),p=LA(a,h,n.shape,r,s,i,o);if(null!=c){return[d,p,$A(y,h)]}return[d,p]},w={x:f,filter:p,bias:y,preluActivationWeights:b},x={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};if(null==l){const e=hT(((e,t,n)=>{let r=ES.runKernel(mk,w,x);return n([t,e,r]),m&&(r=QN(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p)}{const e=hT(((e,t,n,r)=>{let s=ES.runKernel(mk,w,x);return r([t,e,s,n]),m&&(s=QN(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}}));return e(f,p,y)}}});const zA=zS({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:s=!1,bias:a,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===DA(ES.state.gradientDepth,i)){let e=tE(t,n,r,s);return null!=a&&(e=sT(e,a)),OA(e,i,o,l)}let u=LS(t,"a","fused matMul"),c=LS(n,"b","fused matMul");[u,c]=vS(u,c);const h=r?u.shape[u.rank-2]:u.shape[u.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=s?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=Sb(m),b=Sb(g);wb(h===d,(()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${s} must match.`));const v=CT(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),w=QN(u,r?[y,h,p]:[y,p,h]),x=QN(c,s?[b,f,d]:[b,d,f]);let k,S;null!=a&&(k=LS(a,"bias","fused matMul"),[k]=vS(k,u),CT(v,k.shape)),null!=o&&(S=LS(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,o,l,u]=t,c=RA(QN(e,l.shape),l,i);let h,d;if(r||s?!r&&s?(h=tE(c,o,!1,!1),d=tE(c,n,!0,!1)):r&&!s?(h=tE(o,c,!1,!0),d=tE(n,c,!1,!1)):(h=tE(o,c,!0,!0),d=tE(c,n,!0,!0)):(h=tE(c,o,!1,!0),d=tE(n,c,!0,!1)),null!=a){return[h,d,$A(u,c)]}return[h,d]},T={a:w,b:x,bias:k,preluActivationWeights:S},N={transposeA:r,transposeB:s,activation:i,leakyreluAlpha:l};if(null==a){const e=hT(((e,t,n)=>{const r=ES.runKernel(pk,T,N);return n([e,t,r]),{value:QN(r,v),gradFunc:I}}));return e(w,x)}{const e=hT(((e,t,n,r)=>{const s=ES.runKernel(pk,T,N);return r([e,t,s,n]),{value:QN(s,v),gradFunc:I}}));return e(w,x,k)}}});const BA=zS({hammingWindow_:function(e){return CA(e,.54,.46)}});const UA=zS({hannWindow_:function(e){return CA(e,.5,.5)}});const VA=zS({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=0;const i=[];for(;a+t<=e.size;)i.push(rE(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=eE([rE(e,a,t-r),wT([r],s)]);i.push(o),a+=n}return 0===i.length?rA([],[0,t]):QN(eE(i),[i.length,t])}});const WA=zS({stft_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:UA;null==r&&(r=EA(t));const a=VA(e,t,n),i=oT(a,s(t));return X_(i,r)}});const jA=zS({cropAndResize_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=LS(e,"image","cropAndResize"),o=LS(t,"boxes","cropAndResize","float32"),l=LS(n,"boxInd","cropAndResize","int32"),u=o.shape[0];wb(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),wb(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),wb(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),wb(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),wb(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),wb("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:l},h={method:s,extrapolationValue:a,cropSize:r};return ES.runKernel(jv,c,h)}});const GA=zS({flipLeftRight_:function(e){const t=LS(e,"image","flipLeftRight","float32");wb(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return ES.runKernel(dw,n,{})}});const HA=zS({grayscaleToRGB_:function(e){const t=LS(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];wb(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),wb(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,lC(t,s)}});const qA=zS({rgbToGrayscale_:function(e){const t=LS(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];wb(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),wb(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=tT(t,"float32"),i=nA([.2989,.587,.114]);let o;switch(t.rank){case 2:o=UE("ij,j->i",a,i);break;case 3:o=UE("ijk,k->ij",a,i);break;case 4:o=UE("ijkl,l->ijk",a,i);break;case 5:o=UE("ijklm,m->ijkl",a,i);break;case 6:o=UE("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=iC(o,-1),tT(o,s)}});const KA=zS({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=LS(e,"image","rotateWithOffset","float32");wb(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return ES.runKernel(dk,a,i)}});function XA(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),wb(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),wb(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),wb(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),wb(1===t.rank,(()=>"scores must be a 1D tensor")),wb(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),wb(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const YA=zS({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=LS(e,"boxes","nonMaxSuppression","float32"),i=LS(t,"scores","nonMaxSuppression","float32"),o=XA(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return ES.runKernel(Zw,{boxes:a,scores:i},l)}});function QA(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||JA)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function JA(e,t){return e>t?1:e<t?-1:0}function ZA(e,t,n,r,s){return nR(e,t,n,r,s,0)}function eR(e,t,n,r,s,a){return nR(e,t,n,r,s,0,!1,a,!0)}function tR(e,t,n,r,s,a){return nR(e,t,n,r,s,a,!0)}function nR(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(aR);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let l=h.length-1;l>=i;--l){const n=rR(e,a,h[l]);if(n>=r){o=!0;break}if(t.score=t.score*sR(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>s&&QA(u,t,aR))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function rR(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function sR(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function aR(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const iR=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=LS(e,"boxes","nonMaxSuppressionAsync"),i=LS(t,"scores","nonMaxSuppressionAsync"),o=XA(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=ZA(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),nA(h,"int32")};const oR=zS({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=LS(e,"boxes","nonMaxSuppression"),o=LS(t,"scores","nonMaxSuppression"),l=XA(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=ES.runKernel(tx,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}});const lR=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=LS(e,"boxes","nonMaxSuppressionAsync"),o=LS(t,"scores","nonMaxSuppressionAsync"),l=XA(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=tR(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:nA(d,"int32"),selectedScores:nA(p)}};const uR=zS({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=LS(e,"boxes","nonMaxSuppression"),o=LS(t,"scores","nonMaxSuppression"),l=XA(i,o,n,r,s,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},h=ES.runKernel(ex,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}});const cR=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=LS(e,"boxes","nonMaxSuppressionAsync"),o=LS(t,"scores","nonMaxSuppressionAsync"),l=XA(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=eR(d,p,u,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:nA(f,"int32"),validOutputs:dT(m,"int32")}};const hR=zS({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=LS(e,"images","resizeBilinear");wb(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),wb(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),wb(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=QN(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ES.runKernel(vx,o,l);return i?QN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const dR=zS({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=LS(e,"images","resizeNearestNeighbor");wb(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),wb(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),wb("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),wb(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=QN(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ES.runKernel(yx,o,l);return i?QN(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const pR=zS({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=LS(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=oT(nA([r]),255);if(wb(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),wb(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),wb("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),wb("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,o,l]=K_(s,[1,1,1],-1);const e=oT(i,.2989),t=oT(o,.587),n=oT(l,.114);u=sT(sT(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,s,a,i,o,l=nA([-1]),u=nA([0]),c=nA([0]);for(let h=0;h<e.size-1;h++){n=rE(e,0,h+1),r=rE(e,h+1),i=iT(tC(n),t),o=iT(tC(r),t);const d=tC(oT(n,k_(0,n.size)));s=iT(d,tC(n));const p=wT(r.shape,n.size),f=sT(k_(0,r.size),p),m=oT(r,f);a=iT(tC(m),tC(r));const g=ST(s,a),y=ST(s,a),b=oT(i,o);c=oT(oT(b,g),y);const v=dC(c,u);u=PE(v,c,u),l=PE(v,nA([h]),l)}return l}(hE(tT($_(u),"int32"),VS([]),256),a)}const h=n?wC(u,c):dC(u,c);return tT(oT(h,255),"int32")}});const fR=zS({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5?arguments[5]:void 0;const i=LS(e,"image","transform","float32"),o=LS(t,"transforms","transform","float32");wb(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),wb(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),wb(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return ES.runKernel(sk,l,u)}});const mR=zS({bandPart_:function(e,t,n){const r=LS(e,"a","bandPart");wb(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"===typeof t?(wb(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),wb(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=LS(t<0?a:t,"numLower","bandPart")):(wb("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=PE(vC(t,0),a,jC(t,a))),"number"===typeof n?(wb(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),wb(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=LS(n<0?i:n,"numUpper","bandPart")):(wb("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=PE(vC(n,0),i,jC(n,i)));const u=QN(k_(0,a,1,"int32"),[-1,1]),c=k_(0,i,1,"int32"),h=ST(u,c),d=AC(wC(h,o),pC(h,TC(l))),p=UC([a,i],r.dtype);return QN(J_(mA(QN(r,[-1,a,i])).map((e=>PE(d,e,p)))),s)}});const gR=zS({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,wb(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)wb(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=K_(e,e.shape[0],0).map((e=>Q_(e,[0])));wb(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let s=0;s<e.length;++s)n.push(ES.tidy((()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=oT(tC(oT(n[t],e)),n[t]);e=ST(e,r)}return iT(e,rC(e,"euclidean"))})));return t?J_(n,0):n}});function yR(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return ES.tidy((()=>{wb(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=uC(n),a=nT(e);const i=rA([[1]],[1,1]);let o=nT(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=ES.tidy((()=>{const t=rE(a,[e,e],[n-e,1]),l=rC(t),u=rE(a,[e,e],[1,1]),c=PE(dC(u,0),rA([[-1]]),rA([[1]])),h=ST(u,oT(c,l)),d=iT(t,h);o=1===d.shape[0]?nT(i):eE([i,rE(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=TC(iT(tE(c,h),l)),f=rE(a,[e,0],[n-e,r]),m=oT(p,o),g=xA(o);if(0===e)a=ST(f,tE(m,tE(g,f)));else{const t=ST(f,tE(m,tE(g,f)));a=eE([rE(a,[0,0],[e,r]),t],0)}const y=xA(m),b=rE(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=ST(b,tE(tE(b,o),y));else{const t=ST(b,tE(tE(b,o),y));s=eE([rE(s,[0,0],[n,e]),t],1)}return[o,a,s]})),KS([t,l,u])}return!t&&n>r&&(s=rE(s,[0,0],[n,r]),a=rE(a,[0,0],[r,r])),[s,a]}))}const bR=zS({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(wb(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return yR(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=mA(QN(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=yR(e,t);s.push(n),a.push(r)}));return[QN(J_(s,0),e.shape),QN(J_(a,0),e.shape)]}}});var vR;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(vR||(vR={}));const wR=zS({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:vR.SUM_BY_NONZERO_WEIGHTS;const r=LS(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=LS(t,"weights","computeWeightedLoss"));const a=null==s?r:oT(r,s);if(n===vR.NONE)return a;if(n===vR.SUM)return tC(a);if(n===vR.MEAN){if(null==s)return BC(a);{const e=r.size/s.size,t=iT(tC(a),tC(s));return e>1?iT(t,dT(e)):t}}if(n===vR.SUM_BY_NONZERO_WEIGHTS){if(null==s)return iT(tC(a),dT(r.size));{const e=oT(s,VC(r.shape)),t=tT(tC(YC(e,dT(0))),"float32");return iT(tC(a),t)}}throw Error(`Unknown reduction: ${n}`)}});const xR=zS({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:vR.SUM_BY_NONZERO_WEIGHTS;const s=LS(e,"labels","absoluteDifference"),a=LS(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=LS(n,"weights","absoluteDifference")),xb(s.shape,a.shape,"Error in absoluteDifference: ");const o=TT(ST(s,a));return wR(o,i,r)}});const kR=zS({cosineDistance_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:vR.SUM_BY_NONZERO_WEIGHTS;const a=LS(e,"labels","cosineDistance"),i=LS(t,"predictions","cosineDistance");let o=null;null!=r&&(o=LS(r,"weights","cosineDistance")),xb(a.shape,i.shape,"Error in cosineDistance: ");const l=dT(1),u=ST(l,tC(oT(a,i),n,!0));return wR(u,o,s)}});const SR=zS({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:vR.SUM_BY_NONZERO_WEIGHTS,s=LS(e,"labels","hingeLoss");const a=LS(t,"predictions","hingeLoss");let i=null;null!=n&&(i=LS(n,"weights","hingeLoss")),xb(s.shape,a.shape,"Error in hingeLoss: ");const o=dT(1);s=ST(oT(dT(2),s),o);const l=T_(ST(o,oT(s,a)));return wR(l,i,r)}});const IR=zS({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:vR.SUM_BY_NONZERO_WEIGHTS;const a=LS(e,"labels","huberLoss"),i=LS(t,"predictions","huberLoss");let o=null;null!=n&&(o=LS(n,"weights","huberLoss")),xb(a.shape,i.shape,"Error in huberLoss: ");const l=dT(r),u=TT(ST(i,a)),c=jC(u,l),h=ST(u,c),d=sT(oT(dT(.5),uT(c)),oT(l,h));return wR(d,o,s)}});const TR=zS({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:vR.SUM_BY_NONZERO_WEIGHTS;const a=LS(e,"labels","logLoss"),i=LS(t,"predictions","logLoss");let o=null;null!=n&&(o=LS(n,"weights","logLoss")),xb(a.shape,i.shape,"Error in logLoss: ");const l=dT(1),u=dT(r),c=TC(oT(a,SC(sT(i,u)))),h=oT(ST(l,a),SC(sT(ST(l,i),u))),d=ST(c,h);return wR(d,o,s)}});const NR=zS({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:vR.SUM_BY_NONZERO_WEIGHTS;const s=LS(e,"labels","meanSquaredError"),a=LS(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=LS(n,"weights","meanSquaredError")),xb(s.shape,a.shape,"Error in meanSquaredError: ");const o=Y_(s,a);return wR(o,i,r)}});const ER=zS({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:vR.SUM_BY_NONZERO_WEIGHTS,a=LS(e,"multiClassLabels","sigmoidCrossEntropy");const i=LS(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=LS(n,"weights","sigmoidCrossEntropy")),xb(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=dT(r),t=dT(1),n=dT(.5);a=sT(oT(a,ST(t,e)),oT(n,e))}const l=function(e,t){const n=LS(e,"labels","sigmoidCrossEntropyWithLogits"),r=LS(t,"logits","sigmoidCrossEntropyWithLogits");xb(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=T_(r),a=oT(r,n),i=IC(aC(TC(TT(r))));return sT(ST(s,a),i)}(a,i);return wR(l,o,s)}});const CR=zS({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:vR.SUM_BY_NONZERO_WEIGHTS,a=LS(e,"onehotLabels","softmaxCrossEntropy");const i=LS(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=LS(n,"weights","softmaxCrossEntropy")),xb(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=dT(r),t=dT(1),n=dT(a.shape[1]);a=sT(oT(a,ST(t,e)),iT(e,n))}const l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=hT(((e,t,r)=>{const s=_C(t,[n],!0),a=ST(tT(t,"float32"),s);r([e,a]);const i=TC(oT(a,e));return{value:tC(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=KE(e.shape,[n]);return[oT(QN(e,a),ST(tT(r,"float32"),aC(s))),oT(QN(e,a),ST(aC(s),tT(r,"float32")))]}}}));return r(e,t)}(a,i);return wR(l,o,s)}});const _R=zS({sparseFillEmptyRows_:function(e,t,n,r){const s=LS(e,"indices","sparseFillEmptyRows","int32"),a=LS(t,"values","sparseFillEmptyRows"),i=LS(n,"denseShape","sparseFillEmptyRows","int32"),o=LS(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=ES.runKernel(Ux,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});const AR=zS({sparseReshape_:function(e,t,n){const r=LS(e,"inputIndices","sparseReshape","int32"),s=LS(t,"inputShape","sparseReshape","int32"),a=LS(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=ES.runKernel(Vx,i);return{outputIndices:o[0],outputShape:o[1]}}});const RR=zS({sparseSegmentMean_:function(e,t,n){const r=LS(e,"data","sparseSegmentMean"),s=LS(t,"indices","sparseSegmentMean","int32"),a=LS(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return ES.runKernel(Wx,i)}});const $R=zS({sparseSegmentSum_:function(e,t,n){const r=LS(e,"data","sparseSegmentSum"),s=LS(t,"indices","sparseSegmentSum","int32"),a=LS(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return ES.runKernel(jx,i)}});const OR=zS({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=LS(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=LS(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},d=ES.runKernel(Yx,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}});const DR=zS({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=LS(e,"input","stringSplit","string"),s=LS(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=ES.runKernel(Qx,i,a);return{indices:o[0],values:o[1],shape:o[2]}}});const FR=zS({stringToHashBucketFast_:function(e,t){const n=LS(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return ES.runKernel(Jx,s,r)}});const LR=zS({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=LS(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return ES.runKernel(Kx,{x:s},a)}}),MR={fft:G_,ifft:H_,rfft:X_,irfft:q_},PR={hammingWindow:BA,hannWindow:UA,frame:VA,stft:WA},zR={flipLeftRight:GA,grayscaleToRGB:HA,resizeNearestNeighbor:dR,resizeBilinear:hR,rgbToGrayscale:qA,rotateWithOffset:KA,cropAndResize:jA,nonMaxSuppression:YA,nonMaxSuppressionAsync:iR,nonMaxSuppressionWithScore:oR,nonMaxSuppressionWithScoreAsync:lR,nonMaxSuppressionPadded:uR,nonMaxSuppressionPaddedAsync:cR,threshold:pR,transform:fR},BR={bandPart:mR,gramSchmidt:gR,qr:bR},UR={absoluteDifference:xR,computeWeightedLoss:wR,cosineDistance:kR,hingeLoss:SR,huberLoss:IR,logLoss:TR,meanSquaredError:NR,sigmoidCrossEntropy:ER,softmaxCrossEntropy:CR},VR={sparseFillEmptyRows:_R,sparseReshape:AR,sparseSegmentMean:RR,sparseSegmentSum:$R},WR={stringNGrams:OR,stringSplit:DR,stringToHashBucketFast:FR,staticRegexReplace:LR};const jR=class{static sgd(e){return new RT(e)}static momentum(e,t){return new $T(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new OT(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new IT(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new vT(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new AT(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new xT(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},GR="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function HR(){return new Promise((e=>GR((()=>e()))))}function qR(e,t){const n=e[0].length;e.forEach(((e,t)=>{wb(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),wb(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)wb(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function KR(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var XR;function YR(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function QR(e){const t={FIRST_DIM_SIZE:XR.FIRST_DIM_SIZE,VALUE_ROWIDS:XR.VALUE_ROWIDS,ROW_LENGTHS:XR.ROW_LENGTHS,ROW_SPLITS:XR.ROW_SPLITS,ROW_LIMITS:XR.ROW_LIMITS,ROW_STARTS:XR.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function JR(e){return 0===e.length?0:e[0]===XR.FIRST_DIM_SIZE?e.length-1:e.length}function ZR(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(XR||(XR={}));const e$=30;function t$(e){return e<=e$?e:Bb(e,Math.floor(Math.sqrt(e)))}function n$(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function r$(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(n+1))}return r}function s$(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],s=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?s.push(n):r.push(n);n.push(...r),n.push(0),n.push(...s)}return n}function a$(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function i$(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function o$(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function l$(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Sb(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,l=s.slice();l.pop();let u=1;for(let h=a;h<n;++h)u*=o[h],l.push(o[h]);const c=[...Ub(e.shape).map((e=>e/u)),1].slice(0,a);return[l,i,u,c]}const u$=1.7580993408473768,c$=1.0507009873554805,h$=.3275911,d$=.254829592,p$=-.284496736,f$=1.421413741,m$=-1.453152027,g$=1.061405429;function y$(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function b$(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function v$(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function w$(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function x$(e,t){return{real:e[2*t],imag:e[2*t+1]}}function k$(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function S$(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function I$(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const T$="->",N$=/->/g,E$=",",C$="...";function _$(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(N$,"").length)/T$.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${T$}").`);const[r,s]=e.split(T$);wb(-1===r.indexOf(C$),(()=>`The ellipsis notation ("${C$}") is not supported yet.`));const a=r.split(E$),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!a.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===o.indexOf(e)&&e!==E$&&o.push(e)}const l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let e=0;e<a[h].length;++e)l[h].push(o.indexOf(a[h][e]))}const u=o.length,c=[];for(let h=s.length;h<u;++h)c.push(h);return{allDims:o,summedDims:c,idDims:l}}function A$(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function R$(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:wb(r[t[s][n]]===e[n],(()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function $$(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=D$(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}function O$(e){return e.every(((e,t)=>e===t))}function D$(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function F$(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)wb(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);wb(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}wb(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function L$(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function M$(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function P$(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function z$(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function B$(e,t){return`size ${e} must be non-negative, not ${t}`}function U$(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function V$(e,t){return`Input to reshape is a SparseTensor with ${Sb(e)}\n  dense values, but the requested shape requires a multiple of ${Sb(t)}. inputShape=${e} outputShape= ${t}`}function W$(e,t){return`Input to reshape is a tensor with ${Sb(e)} dense values, but the requested shape has ${Sb(t)}. inputShape=${e} outputShape=${t}`}function j$(){return"segment ids must be >= 0"}function G$(){return"segment ids are not increasing"}function H$(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function q$(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function K$(e,t){let n,r=!1;for(e<=e$?(n=e,r=!0):n=Bb(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Bb(e,n+1);return n}function X$(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function Y$(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<a;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function Q$(e){try{return e.map((e=>Gk(e)))}catch(n5){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n5}`)}}function J$(e){return e.map((e=>jk(e)))}!function(){for(const e of DT)yT(e)}();const Z$={kernelName:av,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,Z_(tT(n,"float32"),-1))}}},eO={kernelName:iv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=uT(tT(n,"float32")),r=lT(ST(dT(1),t));return TC(iT(e,r))}}}},tO={kernelName:ov,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=lT(ST(uT(tT(n,"float32")),1));return iT(e,t)}}}},nO={kernelName:lv,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{let t=e;const r=ET(n.shape,s);return r.length>0&&(t=tC(t,r)),QN(t,n.shape)},b:()=>{let t=e;const n=ET(r.shape,s);return n.length>0&&(t=tC(t,n)),QN(t,r.shape)}}}},rO={kernelName:uv,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},sO={kernelName:dv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cT(n)}}},aO={kernelName:pv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cT(n)}}},iO={kernelName:fv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,lT(ST(dT(1),uT(tT(n,"float32")))))}}},oO={kernelName:mv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=lT(sT(dT(1),uT(tT(n,"float32"))));return iT(e,t)}}}},lO={kernelName:bv,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{const t=sT(uT(n),uT(r));let a=oT(e,iT(r,t));const i=ET(n.shape,s);return i.length>0&&(a=tC(a,i)),QN(a,n.shape)},b:()=>{const t=sT(uT(n),uT(r));let a=TC(oT(e,iT(n,t)));const i=ET(r.shape,s);return i.length>0&&(a=tC(a,i)),QN(a,r.shape)}}}},uO={kernelName:gv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,sT(uT(tT(n,"float32")),1))}}},cO={kernelName:yv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,ST(dT(1),uT(tT(n,"float32"))))}}};const hO=zS({avgPool3dGrad_:function(e,t,n,r,s,a){const i=LS(e,"dy","avgPool3dGrad"),o=LS(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=QN(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=QN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),wb(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),wb(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),YN("avgPool3dGrad",s,a);const h={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=ES.runKernel(kv,h,d);return c?QN(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),dO={kernelName:xv,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>hO(e,r,s,a,i,o)}}};const pO=zS({avgPoolGrad_:function(e,t,n,r,s){const a=LS(e,"dy","avgPoolGrad"),i=LS(t,"input","avgPoolGrad");wb(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=QN(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=QN(a,[1,a.shape[0],a.shape[1],a.shape[2]])),wb(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),wb(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:r,pad:s},d=ES.runKernel(wv,c,h);return u?QN(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),fO={kernelName:vv,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>pO(e,r,s,a,i)}}},mO={kernelName:Sv,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>tE(e,s,!1,!1),b:()=>tE(e,r,!0,!1)}:a&&!i?{a:()=>tE(s,e,!1,!0),b:()=>tE(r,e,!1,!1)}:{a:()=>tE(s,e,!0,!0),b:()=>tE(e,r,!0,!0)}:{a:()=>tE(e,s,!1,!0),b:()=>tE(r,e,!0,!1)}}},gO={kernelName:Iv,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>a_(e,r,s)}}},yO={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>tC(e,o,!0)}}},bO={kernelName:Cv,gradFunc:e=>({x:()=>e.clone()})},vO={kernelName:_v,gradFunc:e=>({x:()=>cT(e)})},wO={kernelName:Av,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>PE(AC(pC(r,s),wC(r,a)),e,cT(e))}}},xO={kernelName:$v,inputsToSave:["x"],gradFunc:Z$.gradFunc},kO={kernelName:Ov,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=Ab(s,t[0].shape)[0],i=r.map((e=>e[a]));return K_(e,i,a).map((e=>()=>e))}},SO={kernelName:Dv,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return wb(HN(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>SE(r.shape,e,s,i,o,l),filter:()=>AA(r,e,s.shape,i,o,l)}}},IO={kernelName:Lv,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>xE(e,s,a,i,o,1,l),filter:()=>AA(e,r,s.shape,a,i,o,l)}}};const TO=zS({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=QN(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=QN(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),wb(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),wb(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),wb(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),wb(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),wb(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return ES.runKernel(Pv,o,l)}}),NO={kernelName:Mv,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;wb(HN(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>NE(i.shape,e,o,s,a),filter:()=>TO(i,e,o.shape,s,a)}}},EO={kernelName:Bv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(TC(P_(tT(n,"float32"))),e)}}},CO={kernelName:Uv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(z_(tT(n,"float32")),e)}}},_O={kernelName:Wv,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=YE([s],r.rank);let n=RE(e,s,a,!i);return null!=t&&(n=xA(n,t)),n}}}},AO={kernelName:qv,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;wb(HN(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return wb(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),wb(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),wb(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),wb(qN(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),YN("depthwiseConv2d",a,i),{x:()=>MA(l.shape,e,u,s,a,o,i),filter:()=>LA(l,e,u.shape,s,a,o,i)}}},RO={kernelName:Qv,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>ES.runKernel(Jv,a,n),filter:()=>ES.runKernel(Zv,i,n)}}},$O={kernelName:rw,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>ES.runKernel(sw,r)}}},OO={kernelName:aw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=oT(aC(TC(uT(n))),2/Math.sqrt(Math.PI));return{x:()=>oT(e,r)}}},DO={kernelName:ow,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,n)}}},FO={kernelName:lw,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>QN(e,n.shape)}}},LO={kernelName:uw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,aC(n))}}},MO={kernelName:pw,gradFunc:e=>({x:()=>cT(e)})},PO={kernelName:fw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{const t=iT(e,tT(r,"float32")),a=ET(n.shape,s);return a.length>0?QN(tC(t,a),n.shape):t},b:()=>{let t=oT(e,tT(n,"float32"));const a=ET(r.shape,s);a.length>0&&(t=QN(tC(t,a),r.shape));const i=uT(r);return TC(iT(t,tT(i,"float32")))}}}},zO={kernelName:mw,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?dT(1):o,u=ET(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=ST(s,a),d=oT(e,l),p=O_(sT(i,dT(r))),f=oT(oT(oT(p,p),p),dT(-.5));return{x:()=>1===a.rank?QN(oT(oT(e,lC(QN(p,[1,1,1,a.shape[0]]),c)),l),s.shape):QN(oT(oT(e,p),l),s.shape),mean:()=>{let e=oT(oT(p,dT(-1)),d);return 1===a.rank&&(e=tC(e,u)),QN(e,a.shape)},variance:()=>{let e=oT(oT(f,h),d);return 1===a.rank&&(e=tC(e,u)),QN(e,a.shape)},scale:()=>{const t=oT(h,p);let n=oT(e,t);return 1===a.rank&&(n=tC(n,u)),QN(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=tC(t,u)),QN(t,a.shape)}}}},BO={kernelName:gw,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=Ab(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,h=UO(0,l),d=UO(l+1,l+1+c),p=VO([i,[s],u]),f=QN(n,p),m=QN(t,[s]),g=VO([[l],h,d]),y=xA(f,g);let b=fA(y,m,e.shape[o]);const v=QE(g);return b=xA(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=J_(n.map(((t,n)=>l(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function UO(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function VO(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const WO={kernelName:vw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>cT(n),b:()=>cT(r)}}},jO={kernelName:ww,gradFunc:e=>({x:()=>tT(e,"float32")})},GO={kernelName:Sw,gradFunc:e=>({x:()=>cT(e)})},HO={kernelName:Iw,gradFunc:e=>({x:()=>cT(e)})},qO={kernelName:Tw,gradFunc:e=>({x:()=>cT(e)})},KO={kernelName:Nw,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=dC(r,0);return{x:()=>PE(a,e,oT(e,s))}}},XO={kernelName:Rw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,sT(n,1))}}},YO={kernelName:Aw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,tT(n,"float32"))}}},QO={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=aC(r);return ST(e,oT(tC(e,s,!0),t))}}}};const JO=zS({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},s={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return ES.runKernel(Lw,r,s)}}),ZO={kernelName:Fw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>JO(r,s,e,a,i,o,l)}}};function eD(e,t,n,r){return t.rank<n.rank&&(t=QN(t,KE(t.shape,r))),e.rank<n.rank&&(e=QN(e,KE(e.shape,r))),{x:()=>oT(e,tT(ME(n,t),e.dtype))}}const tD={kernelName:Mw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=eD(e,t[1],a,Ab(s,a.shape));return{x:()=>i.x()}}},nD={kernelName:Pw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>oT(e,tT(pC(n,r),"float32")),b:()=>oT(e,tT(vC(n,r),"float32"))}}};const rD=zS({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=LS(e,"dy","maxPool3dGrad"),l=LS(t,"input","maxPool3dGrad"),u=LS(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=QN(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=QN(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=QN(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),wb(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),wb(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),wb(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),YN("maxPool3dGrad",a,i);const f={dy:c,input:h,output:d},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=ES.runKernel(Vw,f,m);return p?QN(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),sD={kernelName:Uw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>rD(e,r,s,a,i,o,l)}}};const aD=zS({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=LS(e,"dy","maxPoolGrad"),l=LS(t,"input","maxPoolGrad"),u=LS(n,"output","maxPoolGrad");wb(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),wb(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),wb(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),YN("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return ES.runKernel(Bw,c,h)}}),iD={kernelName:zw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>aD(e,r,s,a,i,o)}}},oD={kernelName:jw,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Ab(s,r.shape),i=Sb(qE(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=QN(e,t);return iT(oT(n,VC(r.shape,"float32")),i)}}}},lD={kernelName:Gw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=eD(e,i,a,Ab(s,a.shape));return{x:()=>o.x()}}},uD={kernelName:Hw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>oT(e,tT(wC(n,r),"float32")),b:()=>oT(e,tT(dC(n,r),"float32"))}}},cD={kernelName:qw,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>rE(e,a,r.shape)}}},hD={kernelName:Kw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{const t=ET(n.shape,s);return t.length>0?QN(tC(e,t),n.shape):e},b:()=>{const t=oT(e,TC(cC(iT(n,r)))),a=ET(r.shape,s);return a.length>0?QN(tC(t,a),r.shape):t}}}},dD={kernelName:Yw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{const t=oT(e,tT(r,"float32")),a=ET(n.shape,s);return a.length>0?QN(tC(t,a),n.shape):t},b:()=>{const t=oT(e,tT(n,"float32")),a=ET(r.shape,s);return a.length>0?QN(tC(t,a),r.shape):t}}}},pD={kernelName:ax,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>rE(e,a,r.shape)}}},fD={kernelName:ix,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=CT(a.shape,i.shape);return{a:()=>{const t=tT(i,"float32");let n=oT(e,oT(t,kT(a,ST(t,dT(1)))));const r=ET(a.shape,o);return r.length>0&&(n=tC(n,r)),QN(n,a.shape)},b:()=>{const t=dC(a,0),n=PE(t,SC(a),cT(a));let r=oT(e,oT(s,n));const l=ET(i.shape,o);return l.length>0&&(r=tC(r,l)),QN(r,i.shape)}}}},mD={kernelName:ox,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=dC(n,0);return{x:()=>PE(s,e,oT(e,r)),alpha:()=>{let t=PE(s,cT(e),oT(e,n));const a=ET(r.shape,e.shape);return a.length>0&&(t=tC(t,a)),QN(t,r.shape)}}}};function gD(e,t,n){const r=e.shape.length,s=r-n.length,a=YE(n,r);let i=e;null!=a&&(i=xA(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=QN(t,r),a=AE(e,n,!0,!1),i=AE(e,n,!0,!0),o=oT(a,i);return oT(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=QE(a);u=xA(u,e)}return u}const yD={kernelName:lx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=void 0===s||null===s?r.shape.map(((e,t)=>t)):"number"===typeof s?[s]:s,{x:()=>gD(r,e,a)}}},bD={kernelName:tw,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{const t=iT(e,tT(r,"float32")),a=ET(n.shape,s);return a.length>0?QN(tC(t,a),n.shape):t},b:()=>{let t=oT(e,tT(n,"float32"));const a=ET(r.shape,s);a.length>0&&(t=QN(tC(t,a),r.shape));const i=uT(r);return TC(iT(t,tT(i,"float32")))}}}},vD={kernelName:fx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,TC(uT(n)))}}},wD={kernelName:xx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=oT(wC(n,6),Z_(n));return{x:()=>oT(e,tT(r,"float32"))}}},xD={kernelName:mx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,tT(Z_(n),"float32"))}}},kD={kernelName:gx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>QN(e,n.shape)}}},SD={kernelName:Ix,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>TC(iT(e,oT(kT(n,1.5),2)))}}},ID={kernelName:_x,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=dC(n,dT(0)),r=dT(u$),s=dT(c$),a=oT(e,s),i=oT(oT(e,r),aC(tT(n,"float32")));return PE(t,a,i)}}}},TD={kernelName:Rx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(CE(tT(n,"float32")),e)}}},ND={kernelName:$x,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(_E(tT(n,"float32")),e)}}},ED={kernelName:Ax,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=xN(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>e_(e,u)}}},CD={kernelName:Fx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,nE(n))}}},_D={kernelName:Px,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>iE(e,r,s)}}},AD={kernelName:zx,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>eE(e,r)}}},RD={kernelName:Lx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,oT(lT(tT(n,"float32")),2))}}},$D={kernelName:qx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,oT(tT(n,"float32"),2))}}},OD={kernelName:Hx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=dT(2);return{a:()=>oT(e,oT(s,ST(n,r))),b:()=>oT(e,oT(s,ST(r,n)))}}},DD={kernelName:Zx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=CT(n.shape,r.shape);return{a:()=>{let t=e;const r=ET(n.shape,s);return r.length>0&&(t=tC(t,r)),QN(t,n.shape)},b:()=>{let t=e;const n=ET(r.shape,s);return n.length>0&&(t=tC(t,n)),QN(TC(t),r.shape)}}}},FD={kernelName:Mx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Ab(a,r.shape).forEach((e=>{s[e]=1}));const i=QN(e,s),o=oT(i,VC(r.shape,"float32"));return{x:()=>o}}},LD={kernelName:ek,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iT(e,uT(CE(n)))}}},MD={kernelName:nk,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=cT(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=sT(t,rE(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=sT(t,rE(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=sT(t,rE(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=sT(t,rE(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},PD={kernelName:lk,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=_T(t,cT(t)),r=hC(e,n);let s=pC(t,dT(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=iC(s,o+1);s=AC(s,VC(r.shape,"bool"));const i=cT(r);return PE(s,r,i)}(e,n)}}};const zD=[Z$,eO,tO,nO,rO,sO,aO,iO,oO,lO,uO,cO,dO,fO,mO,gO,yO,bO,vO,wO,xO,kO,IO,SO,NO,EO,CO,_O,AO,RO,bD,$O,OO,DO,FO,LO,PO,MO,zO,BO,WO,jO,GO,HO,qO,KO,XO,YO,QO,ZO,tD,tD,nD,sD,iD,oD,lD,uD,cD,hD,dD,{kernelName:Qw,gradFunc:e=>({x:()=>TC(e)})},{kernelName:rx,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>UC(n.shape,"float32")}}},{kernelName:nx,gradFunc:e=>({x:()=>cT(e)})},{kernelName:sx,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return mA(e,r).map((e=>()=>e))}},pD,pD,fD,mD,yD,vD,wD,xD,kD,{kernelName:vx,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>ES.runKernel(wx,s,n)}}},{kernelName:yx,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>ES.runKernel(bx,s,n)}}},{kernelName:kx,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Ab(r,e.shape);return{x:()=>E_(e,s)}}},{kernelName:Sx,gradFunc:e=>({x:()=>cT(e)})},SD,{kernelName:Cx,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>tT(cT(n),"float32"),t:()=>oT(e,tT(n,e.dtype)),e:()=>oT(e,tT(RC(n),e.dtype))}}},ID,{kernelName:Dx,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(e,oT(n,ST(dT(1),n)))}}},{kernelName:Ox,gradFunc:e=>({x:()=>cT(e)})},TD,ND,ED,{kernelName:Bx,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=oT(e,r);return{logits:()=>ST(a,oT(tC(a,[s],true),r))}}},CD,_D,_D,AD,AD,RD,OD,$D,{kernelName:ck,gradFunc:e=>({x:()=>cT(e)})},DD,FD,LD,{kernelName:tk,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oT(ST(dT(1),uT(n)),e)}}},MD,{kernelName:ak,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=QE(s);return{x:()=>xA(e,a)}}},{kernelName:ok,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>J_(e,s)}}},PD,{kernelName:uk,gradFunc:e=>({x:()=>cT(e)})}];for(const n of zD)Ik(n);oS().prototype.abs=function(){return this.throwIfDisposed(),TT(this)},oS().prototype.acos=function(){return this.throwIfDisposed(),IN(this)},oS().prototype.acosh=function(){return this.throwIfDisposed(),TN(this)},oS().prototype.add=function(e){return this.throwIfDisposed(),sT(this,e)},oS().prototype.all=function(e,t){return this.throwIfDisposed(),EN(this,e,t)},oS().prototype.any=function(e,t){return this.throwIfDisposed(),CN(this,e,t)},oS().prototype.argMax=function(e){return this.throwIfDisposed(),_N(this,e)},oS().prototype.argMin=function(e){return this.throwIfDisposed(),AN(this,e)},oS().prototype.asScalar=function(){return this.throwIfDisposed(),wb(1===this.size,(()=>"The array must have only 1 element.")),QN(this,[])},oS().prototype.asType=function(e){return this.throwIfDisposed(),tT(this,e)},oS().prototype.as1D=function(){return this.throwIfDisposed(),QN(this,[this.size])},oS().prototype.as2D=function(e,t){return this.throwIfDisposed(),QN(this,[e,t])},oS().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),QN(this,[e,t,n])},oS().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),QN(this,[e,t,n,r])},oS().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),QN(this,[e,t,n,r,s])},oS().prototype.asin=function(){return this.throwIfDisposed(),RN(this)},oS().prototype.asinh=function(){return this.throwIfDisposed(),$N(this)},oS().prototype.atan=function(){return this.throwIfDisposed(),ON(this)},oS().prototype.atan2=function(e){return this.throwIfDisposed(),DN(this,e)},oS().prototype.atanh=function(){return this.throwIfDisposed(),FN(this)},oS().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),JN(this,e,t,n,r)},oS().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),iE(this,e,t)},oS().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),oE(this,e,t,n,r,s)},oS().prototype.broadcastTo=function(e){return this.throwIfDisposed(),fE(this,e)},oS().prototype.cast=function(e){return this.throwIfDisposed(),tT(this,e)},oS().prototype.ceil=function(){return this.throwIfDisposed(),mE(this)},oS().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),gE(this,e,t)},oS().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof iS&&(e=[e]),eE([this,...e],t)},oS().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),kE(this,e,t,n,r,s,a)},oS().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),IE(this,e,t,n,r,s)},oS().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),xE(this,e,t,n,r,s,a)},oS().prototype.cos=function(){return this.throwIfDisposed(),CE(this)},oS().prototype.cosh=function(){return this.throwIfDisposed(),_E(this)},oS().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),AE(this,e,t,n)},oS().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),RE(this,e,t,n)},oS().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),OE(this,e,t)},oS().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),DE(this,e,t,n,r,s,a)},oS().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),LE(this,e,t,n,r,s)},oS().prototype.divNoNan=function(e){return this.throwIfDisposed(),zE(this,e)},oS().prototype.div=function(e){return this.throwIfDisposed(),iT(this,e)},oS().prototype.dot=function(e){return this.throwIfDisposed(),BE(this,e)},oS().prototype.elu=function(){return this.throwIfDisposed(),VE(this)},oS().prototype.equal=function(e){return this.throwIfDisposed(),ME(this,e)},oS().prototype.erf=function(){return this.throwIfDisposed(),jE(this)},oS().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),sC(this,e,t)},oS().prototype.exp=function(){return this.throwIfDisposed(),aC(this)},oS().prototype.expandDims=function(e){return this.throwIfDisposed(),iC(this,e)},oS().prototype.expm1=function(){return this.throwIfDisposed(),oC(this)},oS().prototype.fft=function(){return this.throwIfDisposed(),G_(this)},oS().prototype.flatten=function(){return this.throwIfDisposed(),QN(this,[this.size])},oS().prototype.floor=function(){return this.throwIfDisposed(),cC(this)},oS().prototype.floorDiv=function(e){return this.throwIfDisposed(),aT(this,e)},oS().prototype.gather=function(e,t,n){return this.throwIfDisposed(),hC(this,e,t,n)},oS().prototype.greaterEqual=function(e){return this.throwIfDisposed(),pC(this,e)},oS().prototype.greater=function(e){return this.throwIfDisposed(),dC(this,e)},oS().prototype.ifft=function(){return this.throwIfDisposed(),H_(this)},oS().prototype.irfft=function(){return this.throwIfDisposed(),q_(this)},oS().prototype.isFinite=function(){return this.throwIfDisposed(),mC(this)},oS().prototype.isInf=function(){return this.throwIfDisposed(),gC(this)},oS().prototype.isNaN=function(){return this.throwIfDisposed(),yC(this)},oS().prototype.leakyRelu=function(e){return this.throwIfDisposed(),bC(this,e)},oS().prototype.lessEqual=function(e){return this.throwIfDisposed(),wC(this,e)},oS().prototype.less=function(e){return this.throwIfDisposed(),vC(this,e)},oS().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),kC(this,e,t,n,r)},oS().prototype.logSigmoid=function(){return this.throwIfDisposed(),EC(this)},oS().prototype.logSoftmax=function(e){return this.throwIfDisposed(),CC(this,e)},oS().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),_C(this,e,t)},oS().prototype.log=function(){return this.throwIfDisposed(),SC(this)},oS().prototype.log1p=function(){return this.throwIfDisposed(),IC(this)},oS().prototype.logicalAnd=function(e){return this.throwIfDisposed(),AC(this,e)},oS().prototype.logicalNot=function(){return this.throwIfDisposed(),RC(this)},oS().prototype.logicalOr=function(e){return this.throwIfDisposed(),$C(this,e)},oS().prototype.logicalXor=function(e){return this.throwIfDisposed(),OC(this,e)},oS().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),tE(this,e,t,n)},oS().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),MC(this,e,t,n,r)},oS().prototype.max=function(e,t){return this.throwIfDisposed(),ZE(this,e,t)},oS().prototype.maximum=function(e){return this.throwIfDisposed(),_T(this,e)},oS().prototype.mean=function(e,t){return this.throwIfDisposed(),BC(this,e,t)},oS().prototype.min=function(e,t){return this.throwIfDisposed(),eC(this,e,t)},oS().prototype.minimum=function(e){return this.throwIfDisposed(),jC(this,e)},oS().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),GC(this,e,t)},oS().prototype.mod=function(e){return this.throwIfDisposed(),HC(this,e)},oS().prototype.mul=function(e){return this.throwIfDisposed(),oT(this,e)},oS().prototype.neg=function(){return this.throwIfDisposed(),TC(this)},oS().prototype.norm=function(e,t,n){return this.throwIfDisposed(),rC(this,e,t,n)},oS().prototype.notEqual=function(e){return this.throwIfDisposed(),YC(this,e)},oS().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),QC(this,e,t,n)},oS().prototype.onesLike=function(){return this.throwIfDisposed(),JC(this)},oS().prototype.pad=function(e,t){return this.throwIfDisposed(),e_(this,e,t)},oS().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),i_(this,e,t,n,r,s,a)},oS().prototype.pow=function(e){return this.throwIfDisposed(),kT(this,e)},oS().prototype.prelu=function(e){return this.throwIfDisposed(),o_(this,e)},oS().prototype.prod=function(e,t){return this.throwIfDisposed(),l_(this,e,t)},oS().prototype.reciprocal=function(){return this.throwIfDisposed(),I_(this)},oS().prototype.relu=function(){return this.throwIfDisposed(),T_(this)},oS().prototype.relu6=function(){return this.throwIfDisposed(),N_(this)},oS().prototype.reshapeAs=function(e){return this.throwIfDisposed(),QN(this,e.shape)},oS().prototype.reshape=function(e){return this.throwIfDisposed(),QN(this,e)},oS().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),hR(this,e,t,n)},oS().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),dR(this,e,t,n)},oS().prototype.reverse=function(e){return this.throwIfDisposed(),E_(this,e)},oS().prototype.rfft=function(){return this.throwIfDisposed(),X_(this)},oS().prototype.round=function(){return this.throwIfDisposed(),$_(this)},oS().prototype.rsqrt=function(){return this.throwIfDisposed(),O_(this)},oS().prototype.selu=function(){return this.throwIfDisposed(),D_(this)},oS().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),F_(this,e,t,n,r,s,a)},oS().prototype.sigmoid=function(){return this.throwIfDisposed(),nE(this)},oS().prototype.sign=function(){return this.throwIfDisposed(),M_(this)},oS().prototype.sin=function(){return this.throwIfDisposed(),P_(this)},oS().prototype.sinh=function(){return this.throwIfDisposed(),z_(this)},oS().prototype.slice=function(e,t){return this.throwIfDisposed(),rE(this,e,t)},oS().prototype.softmax=function(e){return this.throwIfDisposed(),j_(this,e)},oS().prototype.softplus=function(){return this.throwIfDisposed(),NC(this)},oS().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),a_(this,e,t)},oS().prototype.split=function(e,t){return this.throwIfDisposed(),K_(this,e,t)},oS().prototype.sqrt=function(){return this.throwIfDisposed(),lT(this)},oS().prototype.square=function(){return this.throwIfDisposed(),uT(this)},oS().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Y_(this,e)},oS().prototype.squeeze=function(e){return this.throwIfDisposed(),Q_(this,e)},oS().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof iS?[this,e]:[this,...e];return J_(n,t)},oS().prototype.step=function(e){return this.throwIfDisposed(),Z_(this,e)},oS().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),eA(this,e,t,n,r,s,a,i,o)},oS().prototype.sub=function(e){return this.throwIfDisposed(),ST(this,e)},oS().prototype.sum=function(e,t){return this.throwIfDisposed(),tC(this,e,t)},oS().prototype.tan=function(){return this.throwIfDisposed(),tA(this)},oS().prototype.tanh=function(){return this.throwIfDisposed(),sE(this)},oS().prototype.tile=function(e){return this.throwIfDisposed(),lC(this,e)},oS().prototype.toBool=function(){return this.throwIfDisposed(),tT(this,"bool")},oS().prototype.toFloat=function(){return this.throwIfDisposed(),tT(this,"float32")},oS().prototype.toInt=function(){return this.throwIfDisposed(),tT(this,"int32")},oS().prototype.topk=function(e,t){return this.throwIfDisposed(),hA(this,e,t)},oS().prototype.transpose=function(e){return this.throwIfDisposed(),xA(this,e)},oS().prototype.unique=function(e){return this.throwIfDisposed(),pA(this,e)},oS().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),fA(this,e,t)},oS().prototype.unstack=function(e){return this.throwIfDisposed(),mA(this,e)},oS().prototype.where=function(e,t){return this.throwIfDisposed(),PE(e,this,t)},oS().prototype.zerosLike=function(){return this.throwIfDisposed(),cT(this)};class BD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,BD.prototype)}}class UD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,UD.prototype)}}class VD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,VD.prototype)}}class WD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,WD.prototype)}}class jD extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jD.prototype)}}Error;class GD{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function HD(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function qD(e,t){if(!e)throw new jD(t)}function KD(e,t){let n=0;for(const r of e)r===t&&n++;return n}function XD(e){return 1===e.length?e[0]:e}function YD(e){return Array.isArray(e)?e:[e]}function QD(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function JD(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let ZD={};function eF(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function tF(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>tF(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?tF(t):e[n]=t.value)}}}function nF(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in ZD)a=ZD[s];else if(a=t[s],null==a)throw new VD(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new VD(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in ZD?[o,l]=ZD.className:i in t&&([o,l]=t[i]),null==o)throw new VD(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(ZD))e[n]=ZD[n];for(const s of Object.keys(n))e[s]=n[s];a.config.customObjects=e;const t=Object.assign({},ZD);for(const s of Object.keys(n))ZD[s]=n[s];tF(a.config);const r=l(o,a.config,n,s);return ZD=Object.assign({},t),r}{const e=Object.assign({},ZD);for(const r of Object.keys(n))ZD[r]=n[r];const t=new o(a.config);return ZD=Object.assign({},e),t}}}function rF(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function sF(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function aF(e){if(null==e)throw new VD(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function iF(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new VD(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function oF(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return qD(n>=0),qD(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function lF(e,t){Array.isArray(e)?(wb(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>lF(e,`element ${n+1} of ${t}`)))):wb(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${uF(e)}.`))}function uF(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>uF(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function cF(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let hF=0;function dF(){return hF++}const pF={};function fF(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in pF||(pF[e]=0),pF[e]+=1,e+pF[e].toString()}const mF=["channelsFirst","channelsLast"],gF=["nearest","bilinear"],yF=["valid","same","causal"],bF=["max","avg"],vF=["sum","mul","concat","ave"],wF=new Map;function xF(e){iF(mF,"DataFormat",e)}function kF(e){iF(yF,"PaddingMode",e)}function SF(e){iF(bF,"PoolMode",e)}const IF=[];function TF(e,t){IF.push(e);try{const e=t();return IF.pop(),e}catch(t5){throw IF.pop(),t5}}function NF(e){if(!_F(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===IF.length?"":IF.join("/")+"/")+e}function EF(e){if(!_F(e))throw new Error("Not a valid tensor name: '"+e+"'");wF.has(e)||wF.set(e,0);const t=wF.get(e);if(wF.set(e,wF.get(e)+1),t>0){const n=`${e}_${t}`;return wF.set(n,1),n}return e}const CF=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function _F(e){return!!e.match(CF)}function AF(e){return e===parseInt(e.toString(),10)}function RF(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function $F(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function OF(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function DF(e,t){if(t<e)throw new VD(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let FF;function LF(){return null==FF&&(FF=QS().epsilon()),FF}function MF(e,t){return tT(e,t)}function PF(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),QN(e,n)}function zF(e,t,n){return qS((()=>{switch(e.rank){case 1:return B_(e,t,n);case 2:return U_(e,[t,0],[n,e.shape[1]]);case 3:return V_(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return W_(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return rE(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return rE(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new VD(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function BF(e,t,n){return qS((()=>{switch(e.rank){case 1:return B_(e,t,n);case 2:return U_(e,[0,t],[e.shape[0],n]);case 3:return V_(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return W_(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new VD(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function UF(e,t,n,r){return qS((()=>{switch(e.rank){case 1:return B_(e,t,n);case 2:switch(r){case 1:return zF(e,t,n);case 2:return BF(e,t,n);default:throw new VD(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return zF(e,t,n);case 2:return V_(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return BF(e,t,n);default:throw new VD(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return zF(e,t,n);case 2:return W_(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return W_(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return BF(e,t,n);default:throw new VD(`The axis is not within the rank of the tensor ${r}`)}default:throw new VD(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function VF(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),eE(e,n)}function WF(e,t){switch(e.rank){case 1:return yE([e,t]);case 2:return bE([e,t],0);case 3:return vE([e,t],0);case 4:return wE([e,t],0);default:throw new VD(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function jF(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new VD(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return lC(e,t)}function GF(e){return b_(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function HF(e,t,n,r){if(e.rank<2||t.rank<2)throw new WD(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new WD(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return zA({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?XF(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=QN(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=QN(xA(t,c),[l,-1]);const h=[...s,...u];return QN(zA({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?XF(e.rank,r,"channelsLast"):null,activation:n}),h)}}function qF(e,t,n){return qS((()=>(t=Array.isArray(t)?nA(t,"int32"):tT(t,"int32"),hC(e,t,n))))}function KF(e){return oT(e,e)}function XF(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new VD(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?QN(t,[1,r[0],1,1,1]):QN(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?QN(t,[1,1,1,1,r[0]]):QN(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?QN(t,[1,r[0],1,1]):QN(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?QN(t,[1,1,1,r[0]]):QN(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?QN(t,[1,r[0],1]):QN(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?QN(t,[1,1,r[0]]):QN(t,[1].concat(r))}else if(e<3)return t;throw new VD(`Unsupported input rank by biasAdd: ${t.rank}`)}function YF(e,t,n){return qS((()=>(null==n&&(n="channelsLast"),xF(n),sT(e,XF(e.rank,t,n)))))}function QF(e,t,n,r){return qS((()=>NA(e,t,n,r)))}function JF(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const ZF=["fanIn","fanOut","fanAvg"],eL=["normal","uniform","truncatedNormal"];class tL extends mT{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class nL extends tL{apply(e,t){return UC(e,t)}}nL.className="Zeros",yT(nL);class rL extends tL{apply(e,t){return VC(e,t)}}rL.className="Ones",yT(rL);class sL extends tL{constructor(e){if(super(),"object"!==typeof e)throw new VD(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new VD(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return qS((()=>oT(dT(this.value),VC(e,t))))}getConfig(){return{value:this.value}}}sL.className="Constant",yT(sL);class aL extends tL{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return w_(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}aL.className="RandomUniform",yT(aL);class iL extends tL{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new WD(`randomNormal does not support dType ${t}.`);return GF(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}iL.className="RandomNormal",yT(iL);class oL extends tL{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new WD(`truncatedNormal does not support dType ${t}.`);return dA(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}oL.className="TruncatedNormal",yT(oL);class lL extends tL{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return qS((()=>{if(2!==e.length||e[0]!==e[1])throw new VD("Identity matrix initializer can only be used for 2D square matrices.");return oT(this.gain,uC(e[0]))}))}getConfig(){return{gain:this.gain}}}lL.className="Identity",yT(lL);class uL extends tL{constructor(e){if(super(),e.scale<0)throw new VD(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,iF(ZF,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){iF(eL,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(xF(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=RF(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=RF(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=RF(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new WD(`${this.getClassName()} does not support dType ${t}.`);return dA(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return w_(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}uL.className="VarianceScaling",yT(uL);class cL extends uL{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return uL.className}}cL.className="GlorotUniform",yT(cL);class hL extends uL{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return uL.className}}hL.className="GlorotNormal",yT(hL);class dL extends uL{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return uL.className}}dL.className="HeNormal",yT(dL);class pL extends uL{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return uL.className}}pL.className="HeUniform",yT(pL);class fL extends uL{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return uL.className}}fL.className="LeCunNormal",yT(fL);class mL extends uL{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return uL.className}}mL.className="LeCunUniform",yT(mL);class gL extends tL{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return qS((()=>{if(e.length<2)throw new WD("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Sb(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=GF([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=BR.qr(a,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=oT(o,l.sign()),n<r&&(o=o.transpose()),oT(dT(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}gL.className="Orthogonal",yT(gL);const yL={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function bL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return nF(e,gT.getMap().classNameMap,t,"initializer")}function vL(e){return eF(e)}function wL(e){if("string"===typeof e){const t=e in yL?yL[e]:e;if("GlorotNormal"===t)return new hL;if("GlorotUniform"===t)return new cL;if("HeNormal"===t)return new dL;if("HeUniform"===t)return new pL;if("LeCunNormal"===t)return new fL;if("LeCunUniform"===t)return new mL;{const e={};return e.className=t,e.config={},bL(e)}}return e instanceof tL?e:bL(e)}function xL(e){return Array.isArray(e)&&Array.isArray(e[0])}function kL(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function SL(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new VD(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function IL(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new VD(`Expected exactly 1 Shape; got ${e.length}`)}return e}function TL(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const NL="Variable";class EL{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:NL,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=dF(),n=null==n?NL:n,this.originalName=NF(n),this.name=EF(this.originalName),this.trainable_=r,this.constraint=s,this.val=yA(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function CL(e){return e.map((e=>e.read()))}function _L(e){e.forEach((e=>{e[0].write(e[1])}))}class AL{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class RL{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=dF(),null!=a&&(this.originalName=NF(a),this.name=EF(this.originalName)),this.rank=t.length}}let $L=0;class OL{constructor(e,t){this.callArgs=t,this.id=$L++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let DL=0;class FL extends mT{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=DL++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=QD(e)+"_"+fF(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new UD(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new VD(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return XD(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return XD(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new BD(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new BD(`Layer ${this.name} is not connected, no input to return.`);return XD(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new BD(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new BD(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return XD(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=YD(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=YD(this.inputSpec);if(t.length!==n.length)throw new VD(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],s=n[r];if(null==s)continue;const a=e.rank;if(null!=s.ndim&&a!==s.ndim)throw new VD(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new VD(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new VD(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&e.dtype!==s.dtype)throw new VD(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${e.dtype}.`);if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),a=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=a&&-1===[a,null].indexOf(i))throw new VD(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=e.shape[t];if(null!=n&&null!=a&&n!==a)throw new VD(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=YD(e),r=function(e){let t=!0;for(const n of YD(e))if(!(n instanceof RL)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of YD(e))if(n instanceof RL){t=!1;break}return t}(e);if(r===s)throw new VD("Arguments to apply() must be all SymbolicTensors or all Tensors");return TF(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of YD(e))t.push(n.shape);this.build(XD(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=YD(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=XD(a),null!=this.activityRegularizer)throw new WD("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=YD(e);const t=[];for(const n of e)t.push(n.shape);return XD(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new RL(a,n,this,YD(e),t,this.name,r))):new RL(a,r,this,YD(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new WD("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new BD(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new BD(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new UD(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return TL(this.weights)}build(e){this.built=!0}getWeights(){return CL(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){qS((()=>{const t=this.weights;if(t.length!==e.length)throw new VD(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=CL(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!Ib(a.shape,o.shape))throw new VD(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}_L(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new VD(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():wL("zeros"));const l=r.apply(t,n),u=new EL(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=YD(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=YD(t),a=YD(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=YD(e);t=YD(t),n=YD(n),r=YD(r),s=kL(s),a=kL(a);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new OL({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function LL(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=LL(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class ML extends FL{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:fF("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new VD("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new VD("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new VD("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new RL(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new OL({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new VD(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}ML.className="InputLayer",yT(ML);class PL{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof PL)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new VD(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return tT(t,e.dtype)}catch(n5){throw new VD(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof RL){if(null==this.id2Value[e.id])throw new VD(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new VD(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof RL){if(null==this.id2Value[e.id])throw new VD(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new VD(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&KS(this.id2Mask)}}const zL=new GD,BL=new GD;function UL(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let h,d=zL.get(c);if(null==d){const e=function(e,t){wb(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=WL(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=WL(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:VL(r)}}(i,t);d=e.sorted,h=e.recipientCounts,zL.put(c,d),BL.put(c,h)}h={},s||Object.assign(h,BL.get(c));const p=new PL(t);for(let f=0;f<d.length;++f){if(null!=r){const e=HS().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=d[f],a=e.sourceLayer;if(a instanceof ML)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),s||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=YD(a.apply(i,n));let y=null;a.supportsMasking&&(y=a.computeMask(i,u));const b=jL(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}s||KS(c)}return p.disposeMasks(),a?l:l[0]}function VL(e){const t={};for(const n in e)t[n]=e[n].size;return t}function WL(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function jL(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function GL(e,t){return qS((()=>lT(tC(oT(e,e),t,!0))))}ev().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=zL&&zL.setMaxEntries(e),null!=BL&&BL.setMaxEntries(e)}));class HL extends mT{getConfig(){return{}}}class qL extends HL{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return qS((()=>{const t=GL(e,this.axis),n=gE(t,0,this.maxValue);return oT(e,iT(n,sT(LF(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}qL.className="MaxNorm",yT(qL);class KL extends HL{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return qS((()=>iT(e,sT(LF(),GL(e,this.axis)))))}getConfig(){return{axis:this.axis}}}KL.className="UnitNorm",yT(KL);class XL extends HL{apply(e){return T_(e)}}XL.className="NonNeg",yT(XL);class YL extends HL{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return qS((()=>{const t=GL(e,this.axis),n=sT(oT(this.rate,gE(t,this.minValue,this.maxValue)),oT(1-this.rate,t));return oT(e,iT(n,sT(LF(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}YL.className="MinMaxNorm",yT(YL);const QL={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function JL(e){return eF(e)}function ZL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return nF(e,gT.getMap().classNameMap,t,"constraint")}function eM(e){if(null==e)return null;if("string"===typeof e){return ZL({className:e in QL?QL[e]:e,config:{}})}return e instanceof HL?e:ZL(e)}async function tM(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!==typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];KS(r)}}function nM(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var rM;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(rM||(rM={}));class sM{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class aM{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class iM extends sM{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const s=qS((()=>sT(this.totals[r],oT(e,n))));this.totals[r]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:qS((()=>{const e=oT(iT(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),XS(t[n])})))}}class oM extends sM{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const r=this.history[s];for(let a=0;a<r.length;++a)if("number"!==typeof r[a]){const i=r[a];e.push(i.data()),t.push(s),n.push(a)}}const r=await Promise.all(e);for(let s=0;s<r.length;++s){this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}}}class lM extends sM{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||HR,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Mb(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():Wk();return function(){const a=null!=n?n():Wk();return a-s<t||(s=a,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await tM(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await tM(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await tM(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await tM(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await tM(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Mb(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await tM(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await tM(e),await this.trainEnd(e))}}function uM(e,t){if(null==e&&(e={}),e instanceof sM)return[e];if(Array.isArray(e)&&e[0]instanceof sM)return e;return YD(e).map((e=>new lM(e,t)))}class cM{constructor(){}static registerCallbackConstructor(e,t){wb(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),cM.checkForDuplicate(t),null==cM.constructors[e]&&(cM.constructors[e]=[]),cM.constructors[e].push(t)}static checkForDuplicate(e){for(const t in cM.constructors){cM.constructors[+t].forEach((t=>{if(t===e)throw new VD("Duplicate callback constructor.")}))}}static clear(){cM.constructors={}}static createCallbacks(e){const t=[];for(const n in cM.constructors){const r=+n;e>=r&&t.push(...cM.constructors[r])}return t.map((e=>new e))}}function hM(e,t,n,r,s,a,i,o,l){const u=new oM,c=[new iM,...cM.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const h=new aM(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function dM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return nF(e,gT.getMap().classNameMap,t,"layer",n)}function pM(e,t){return qS((()=>{"float32"!==e.dtype&&(e=tT(e,"float32"));const n=tC(KF(e),t,!0),r=wT(n.shape,LF()),s=lT(_T(n,r));return iT(e,s)}))}function fM(e,t){return qS((()=>BC(KF(ST(t,e)),-1)))}function mM(e,t){return qS((()=>BC(TT(ST(t,e)),-1)))}function gM(e,t){return qS((()=>{const n=ST(e,t),r=gE(TT(e),LF(),Number.MAX_VALUE),s=TT(iT(n,r));return oT(100,BC(s,-1))}))}function yM(e,t){return qS((()=>{const n=gE(t,LF(),Number.MAX_VALUE),r=SC(sT(1,n)),s=gE(e,LF(),Number.MAX_VALUE),a=SC(sT(1,s));return BC(KF(ST(r,a)),-1)}))}function bM(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return qS((()=>{if(n)t=j_(t);else{const e=tC(t,t.shape.length-1,!0);t=iT(t,e)}return t=gE(t,LF(),1-LF()),TC(tC(oT(tT(e,"float32"),SC(t)),t.shape.length-1))}))}function vM(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return qS((()=>{const r=tT(cC(function(e){const t=[RF(e.shape)];return QN(e,t)}(e)),"int32"),s=(t=gE(t,LF(),1-LF())).shape;return bM(QN(QC(r,s[s.length-1]),s),t,n)}))}function wM(e,t){return qS((()=>{let n;return n=gE(t,LF(),1-LF()),n=SC(iT(n,ST(1,n))),BC(function(e,t){if(!Ib(e.shape,t.shape))throw new VD(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return qS((()=>{const n=T_(t),r=TC(TT(t));return sT(ST(n,oT(t,e)),IC(aC(r)))}))}(e,n),-1)}))}function xM(e,t){return qS((()=>{const n=gE(e,LF(),1),r=gE(t,LF(),1);return tC(oT(e,SC(iT(n,r))),-1)}))}function kM(e,t){return qS((()=>{const n=pM(e,-1),r=pM(t,-1),s=oT(n,r);return TC(tC(s,-1))}))}cM.constructors={};const SM={meanSquaredError:fM,meanAbsoluteError:mM,meanAbsolutePercentageError:gM,meanSquaredLogarithmicError:yM,squaredHinge:function(e,t){return qS((()=>{const n=_T(0,ST(1,oT(e,t)));return BC(KF(n),-1)}))},hinge:function(e,t){return qS((()=>{const n=_T(0,ST(1,oT(e,t)));return BC(n,-1)}))},categoricalHinge:function(e,t){return qS((()=>{const n=tC(oT(e,t),-1),r=ZE(oT(ST(1,e),t),-1);return _T(0,sT(1,ST(r,n)))}))},logcosh:function(e,t){return qS((()=>{const n=Math.log(2),r=ST(t,e),s=ST(sT(r,NC(oT(-2,r))),n);return BC(s,-1)}))},categoricalCrossentropy:bM,sparseCategoricalCrossentropy:vM,binaryCrossentropy:wM,kullbackLeiblerDivergence:xM,poisson:function(e,t){return qS((()=>{const n=SC(sT(LF(),t));return BC(ST(t,oT(e,n)),-1)}))},cosineProximity:kM};function IM(e){if("string"===typeof e){if(e in SM)return SM[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new VD(t)}return e}function TM(e,t){return qS((()=>{const n=oT(.5,JC(t)),r=MF(dC(t,n),e.dtype);return BC(ME(e,r),-1)}))}function NM(e,t){return qS((()=>MF(ME(_N(e,-1),_N(t,-1)),"float32")))}function EM(e,t){return qS((()=>tT(tC(AC(ME(e,1),ME(t,1))),"float32")))}function CM(e,t){return wM(e,t)}function _M(e,t){return e.rank===t.rank&&(e=Q_(e,[e.rank-1])),(t=_N(t,-1)).dtype!==e.dtype&&(t=tT(t,e.dtype)),tT(ME(e,t),"float32")}const AM=bM,RM=vM,$M={binaryAccuracy:TM,categoricalAccuracy:NM,precision:function(e,t){return qS((()=>{const n=EM(e,t),r=function(e,t){return qS((()=>tT(tC(AC(ME(e,0),ME(t,1))),"float32")))}(e,t),s=sT(n,r);return tT(PE(dC(s,0),iT(n,s),0),"float32")}))},categoricalCrossentropy:AM,sparseCategoricalCrossentropy:RM,mse:fM,MSE:fM,mae:mM,MAE:mM,mape:gM,MAPE:gM,cosine:kM};function OM(e){if("string"===typeof e&&e in $M)return $M[e];if("string"!==typeof e&&null!=e)return e;throw new VD(`Unknown metric ${e}`)}function DM(e){if(qD(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(SM))if(SM[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys($M))if($M[n]===e){t=n;break}return void 0!==t?t:e.name}}const FM=1048576;function LM(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!MM(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>FM&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function MM(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!MM(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!MM(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function PM(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const s=function(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),zM(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?BM(o[c],n,r):UM(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?TL(e.collectedTrainableWeights):TL(e.trainableWeights);return t}(e),u=TL(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function zM(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function BM(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(n5){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(n5){r="multiple"}zM([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function UM(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(n5){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(n5){s="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];zM([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)zM(["","","","",i[c]],t,r)}function VM(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function WM(e,t){if(null===e)return null;if("string"===typeof e)return JD(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];VM(t,s,r)?n.push(r):n.push(WM(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=JD(n);t[e]=WM(r,e)}}return t}}function jM(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return QD(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];VM(t,s,r)?n.push(r):n.push(jM(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=QD(n);t[s]="name"!==n&&"className"!==n||"string"!==typeof r?jM(r,n):r}return t}}const GM="4.22.0";class HM extends FL{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=fF(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],sF(this.inputs).length!==this.inputs.length)throw new VD(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);sF(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;qD(0===t,"input layer has >1 nodes"),qD(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof ML))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new UD(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(HM.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let a=0;a<c;a++){const e=u.inputTensors[a],r=u.inboundLayers[a],s=u.nodeIndices[a],i=u.tensorIndices[a];o(e,t,n,r,s,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const a=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,a),r[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r],a=y.nodeIndices[r],i=s.inboundNodes[a],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in r){const e=r[y];e in d||(d[e]=[]),d[e].push(s[y])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(rF);this.layers=[];for(const y of p){const e=d[y];e.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof HM&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(rF);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new UD(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new UD(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new OL({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new VD("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const a=s?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[a])throw new VD(`Duplicate weight name: ${a}`);n[a]=t,r++}const a=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[i]]);else if(t)throw new VD(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new VD(`${e.length} of ${r} weights are not set: ${e}`)}_L(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${GM}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=jM(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return qS((()=>{e=YD(e);const n=new PL;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return UL(this.outputs,n,t)}))}computeMask(e,t){return qS((()=>{let n;return e=YD(e),n=null==t?HD(null,e.length):YD(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=kL(e);if(t.length!==this.inputLayers.length)throw new VD(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(rF);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],s=t.nodeIndices[i],a=t.tensorIndices[i],o=n[`${e.name}_${s}_${a}`];r.push(o)}const s=kL(e.computeOutputShape(XD(r))),a=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){n[`${e.name}_${a}_${t}`]=s[t]}}}const s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;a.push(r)}for(let i=0;i<a.length;i++){const e=a[i];qD(e in n),s.push(n[e])}return XD(s)}runInternalGraph(e,t){null==t&&(t=HD(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],s=e[o],a=t[o];n[r.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(rF);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,a=new Array;for(const t of r)t.id in n&&a.push(n[t.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===a.length){const[t,n]=a[0];null==u.mask&&(u.mask=n),o=YD(e.call(t,u)),l=YD(e.computeMask(t,n)),r=[t],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==u.mask&&(u.mask=i),o=YD(e.call(r,u)),l=YD(e.computeMask(r,i));if(e.activityRegularizer)throw new WD("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const o of this.outputs){qD(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),s.push(e),a.push(t)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof HM?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=HM.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new VD("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new VD(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new VD(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return qS((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=HM.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),r=a.getConfig(),s=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],r=HM.nodeKey(a,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(n5){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],a=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[HM.nodeKey(s,a)];null==l&&(l=0),n.push([s.name,l,o,i])}s.push(n)}}}const i={};i.name=a.name,i.className=e,i.config=r,i.inboundNodes=s,n.push(i)}e.layers=n;const r=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=this.inputLayersNodeIndices[a],s=HM.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[a];r.push([e.name,i,o])}e.inputLayers=r;const s=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=this.outputLayersNodeIndices[a],r=HM.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[a];s.push([e.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},s={};function a(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let s;for(const i of t){const o=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(o in r))return void a(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void a(e,t);const h=c.inboundNodes[l];n.push(h.outputTensors[u])}n.length>0&&e.apply(XD(n),s)}function o(e){const s=e.name,i=dM(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[s]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new VD(`Corrupted configuration, expected array for nodeData: ${e}`);a(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!aF(s);)for(const e of u){const t=r[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const c=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];qD(e in r);const s=r[e].inboundNodes[t].outputTensors;c.push(s[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];qD(e in r);const s=r[e].inboundNodes[t].outputTensors;h.push(s[n])}return new e({inputs:c,outputs:h,name:l})}get stateful(){if(this._stateful)throw new VD("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){qS((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function qM(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function KM(e,t){return qM(e,t,"classWeight")}async function XM(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=qS((()=>{if(1===e.shape.length)return nT(e);if(2===e.shape.length){if(e.shape[1]>1){return _N(e,1)}if(1===e.shape[1])return QN(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());KS(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),nA(s,"float32")}return null}function YM(e,t){return oT(e,t)}function QM(e,t){let n,r;const s=t;n=s.xs,r=s.ys,wb(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=JM("input",e.inputNames,n),i=JM("output",e.outputNames,r),o=a[0].shape[0];wb(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),wb(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<a.length;l++)wb(a[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)wb(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function JM(e,t,n){if(n instanceof iS)return[n];if(Array.isArray(n))return wb(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new VD(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}async function ZM(e,t,n){const r=null!=n.batchesPerEpoch;if(wb(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),wb(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),wb(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),wb(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),wb(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(eP(n.validationData))wb(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new WD("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=uM(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=hM(c,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,u);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await d.onEpochBegin(f);let c=0,h=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=QM(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],await d.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=KM(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await XM(s[e],null,t[e]))}const u=r.concat(s).concat(i),p=o(u);KS(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];a[t]=n,XS(n)}await d.onBatchEnd(h,a),nM(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=eP(n.validationData)?YD(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):YD(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,u),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function eP(e){return"function"===typeof e.iterator}function tP(e){wb(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function nP(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>zF(e,t,n-t))):zF(e,t,n-t)}function rP(e,t){return qS((()=>null==e?null:Array.isArray(e)?e.map((e=>rP(e,t))):qF(e,"int32"===t.dtype?t:tT(t,"int32"))))}function sP(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function aP(e){const t=[];e instanceof iS&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(PF(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function iP(e,t){if(null==e)return;const n=[];if(t instanceof iS)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const r=[];if(e instanceof iS)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function oP(e){return Array.isArray(e)}function lP(e){return!function(e){return e instanceof iS}(e)&&!oP(e)}function uP(e,t,n){let r,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(oP(e)&&e.length>0)t=!0;else if(lP(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new VD(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(lP(e)){r=[];for(const n of t){if(null==e[n])throw new VD(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(oP(e)){if(e.length!==t.length)throw new VD(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new VD(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=aP(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new VD(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!s)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new VD(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function cP(e,t,n){let r,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new VD(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new VD(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new VD(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!s)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new VD(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class hP extends HM{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new VD("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");PM(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>jR.adagrad(.01),Adadelta:()=>jR.adadelta(1,.95,LF()),Adam:()=>jR.adam(.001,.9,.999,LF()),Adamax:()=>jR.adamax(.002,.9,.999,LF(),0),RMSProp:()=>jR.rmsprop(.001,.9,0,LF()),SGD:()=>jR.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new VD(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof bT))throw new VD("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new VD(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>IM(e)))}else{const n=IM(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new VD(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(IM(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a],t=this.outputNames[a];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],TF("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};TF("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,a;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===wM?-1!==["accuracy","acc"].indexOf(i)?r=TM:-1!==["crossentropy","ce"].indexOf(i)&&(r=CM):this.lossFunctions[e]===vM?-1!==["accuracy","acc"].indexOf(i)?r=_M:-1!==["crossentropy","ce"].indexOf(i)&&(r=RM):-1!==["accuracy","acc"].indexOf(i)?r=NM:-1!==["crossentropy","ce"].indexOf(i)&&(r=AM),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=OM(i);a=e,n=""+DM(i)}let t;TF(n,(()=>{t=a})),s(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;tP(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return XD(this.testLoop(t,e,r,n.verbose,n.steps))}finally{iP(s[0],e),iP(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new WD("Verbose mode is not implemented yet.");wb(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=qS((()=>{if(t.value){const{xs:n,ys:r}=QM(e,t.value),i=n.concat(r),u=qS((()=>s(i)));if(KS(i),0===l)for(let e=0;e<u.length;++e)a.push(dT(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=qS((()=>sT(a[e],oT(c,t)))),l>0&&KS(n)}KS(u),o+=c,++l}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const e=a[u];a[u]=iT(a[u],o),KS(e)}return XD(a)}(this,e,t)}checkNumSamples(e,t,n){let r,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new VD(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new VD(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new VD("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new PL;if(e instanceof iS&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new VD(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new VD(`No value is provided for the model's input ${o.name}`);a.add(o,t)}const i=UL(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=HD(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new VD(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return qS((()=>{const r=this.checkNumSamples(e);if(n)throw new WD("Verbose predictLoop() is not implemented yet.");const s=sP(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){qS((()=>{const n=s[t][0],r=s[t][1],a=nP(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new PL(i);return UL(this.outputs,o)})).forEach(((e,t)=>a[t].push(e)))}return XD(a.map((e=>eE(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=aP(e);cP(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return tP(e),this.predictLoop(n,e)}finally{iP(n,e)}}predictOnBatch(e){cP(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new UD("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let s=0;s<this.feedOutputShapes.length;++s){const e=this.feedOutputShapes[s];this.feedLossFns[s]===vM?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=sF(e.map((e=>e.shape[0])));n.sort();const r=sF(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new VD(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new VD(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!Ib(n,r))throw new VD(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=uP(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=uP(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[fM,wM,bM];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===bM&&1===a.shape[a.shape.length-1])throw new VD(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new VD(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new VD(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=KM(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await XM(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4?arguments[4]:void 0;return qS((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new WD("Verbose mode is not implemented yet.");if(null!=s)throw new WD("steps mode in testLoop() is not implemented yet");{const r=sP(a,n),s=nA(DF(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=zF(s,a,o-a),u=rP(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(dT(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=sT(i[e],oT(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=iT(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(KD(e,r)>1){s+=`_${KD(e.slice(0,n),r)}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new PL(e),o=UL(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=s[n]&&(e=YM(e,s[n]));const a=BC(e);t.push(a),l=0===n?e:sT(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=BC(t(r[s],o[s]))}XS(e),a.push(e)}return l=BC(l),this.calculateLosses().forEach((e=>{l=sT(l,e)})),l}),!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>qS((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new PL(a),o=UL(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=BC(r(s[e],o[e]));n=0===e?a:sT(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=BC(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t){let n,r,s,a,i,o,l,u,c,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;tP(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=h.validationData&&h.validationData.length>0){if(g=!0,2!==h.validationData.length)throw 3===h.validationData.length?new WD("validationData including sample weights is not supported yet."):new VD(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${h.validationData} is invalid.`);i=h.validationData[0],o=h.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,d);l=t[0],u=t[1],m=l.concat(u)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];l=nP(n,e,t),s=n,n=nP(n,0,e),u=nP(r,e,t),a=r,r=nP(r,0,e),m=l.concat(u)}else null!=h.validationSteps&&(g=!0);const y=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,x;g?(this.makeTestFunction(),w=this.testFunction,x=v.slice().concat(v.map((e=>"val_"+e)))):(w=null,m=[],x=v.slice());const k=uM(h.callbacks,h.yieldEvery);return await this.fitLoop(b,y,v,d,h.epochs,h.verbose,k,w,m,h.shuffle,x,h.initialEpoch,null,null)}finally{this.isTraining=!1,iP(n,e),iP(r,t),iP(s,e),iP(a,t),iP(l,i),iP(u,o),null!=c&&KS(c)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,h,d,p){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new VD("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,d,"steps_per_epoch");let g;null!=m&&(g=DF(0,m)),null==a&&(a=1);const{callbackList:y,history:b}=hM(i,a,s,h,m,d,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<s;++v){await y.onEpochBegin(v);const s={};if(null!=d)throw new WD("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new WD("batch shuffling is not implemneted yet");u&&gb(g);const a=nA(g),i=sP(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),qS((()=>{const h=i[u][0],d=i[u][1],p=zF(a,h,d-h);c.batch=u,c.size=d-h;const m=rP(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,XS(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];XS(a),s["val_"+r]=a}}})),await y.onBatchEnd(u,c),nM(c),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(v,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return ZM(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const o of a){const e=await o.data();i.push(e[0])}return KS(a),iP(n[0],e),iP(n[1],t),XD(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=HS().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-HS().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=QD(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>QD(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=QD(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[QD(DM(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>QD(DM(e))));{const e={};for(const t in this.metrics)e[t]=QD(DM(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=dM(WM(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=JD(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>JD(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=JD(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>JD(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=JD(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=vI(e);if(0===t.length)throw new VD(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new VD(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new VD("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await ZS(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${GM}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await ZS(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=uI([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;LM(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){LM(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}hP.className="Model",yT(hP);class dP extends hP{}dP.className="Functional",yT(dP);class pP extends hP{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:fF("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new VD(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof pP||e instanceof hP;let n;if(t){if(n=e,1!==n.outputs.length)throw new VD("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new VD("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new VD("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new VD("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new ML({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new VD(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new VD("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=LL(this.outputs[0])}this.inboundNodes=[],new OL({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:HD(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(IL(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new hP({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new UD("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new UD("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new UD("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new UD("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new VD("Legacy serialization format not supported yet.");n=t}else wb(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,s=t;const a=new e(s);if(!(a instanceof pP))throw new WD(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const i of n){const e=dM(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),a.add(e)}return a}set stopTraining(e){if(null==this.model)throw new VD("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new VD("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}pP.className="Sequential",yT(pP);class fP extends mT{getConfig(){return{}}}class mP extends fP{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new WD(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return VE(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}mP.className="elu",yT(mP);class gP extends fP{apply(e){return D_(e)}}gP.className="selu",yT(gP);class yP extends fP{apply(e){return T_(e)}}yP.className="relu",yT(yP);class bP extends fP{apply(e){return qS((()=>jC(6,T_(e))))}}bP.className="relu6",yT(bP);class vP extends fP{apply(e){return e}}vP.className="linear",yT(vP);class wP extends fP{apply(e){return nE(e)}}wP.className="sigmoid",yT(wP);class xP extends fP{apply(e){return function(e){return qS((()=>{const t=sT(.5,oT(.2,e));return gE(t,0,1)}))}(e)}}xP.className="hardSigmoid",yT(xP);class kP extends fP{apply(e){return NC(e)}}kP.className="softplus",yT(kP);class SP extends fP{apply(e){return function(e){return qS((()=>iT(e,sT(TT(e),1))))}(e)}}SP.className="softsign",yT(SP);class IP extends fP{apply(e){return sE(e)}}IP.className="tanh",yT(IP);class TP extends fP{apply(e){return j_(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}TP.className="softmax",yT(TP);class NP extends fP{apply(e){return CC(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}NP.className="logSoftmax",yT(NP);class EP extends fP{apply(e){return qS((()=>qS((()=>{const t=Math.sqrt(2),n=oT(.5,sT(1,jE(iT(e,t))));return oT(e,n)}))))}}EP.className="gelu",yT(EP);class CP extends fP{apply(e){return qS((()=>oT(.5,oT(e,sT(1,sE(oT(lT(iT(2,Math.PI)),sT(e,oT(.044715,kT(e,3))))))))))}}CP.className="gelu_new",yT(CP);class _P extends fP{apply(e){return qS((()=>oT(e,sE(NC(e)))))}}_P.className="mish",yT(_P);class AP extends fP{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return qS((()=>oT(nE(oT(e,t)),e)))}}function RP(e){return e.getClassName()}function $P(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return nF(e,gT.getMap().classNameMap,t,"activation")}function OP(e){if(null==e){const e={className:"linear",config:{}};return $P(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},$P(t)}return e instanceof fP?e:$P(e)}function DP(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}AP.className="swish",yT(AP);class FP extends mT{}class LP extends FP{constructor(e){super(),DP(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return qS((()=>{let t=UC([1]);return this.hasL1&&(t=sT(t,tC(oT(this.l1,TT(e))))),this.hasL2&&(t=sT(t,tC(oT(this.l2,KF(e))))),QN(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}LP.className="L1L2",yT(LP);const MP={l1l2:"L1L2"};function PP(e){return eF(e)}function zP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return nF(e,gT.getMap().classNameMap,t,"regularizer")}function BP(e){if(null==e)return null;if("string"===typeof e){return zP({className:e in MP?MP[e]:e,config:{}})}return e instanceof FP?e:zP(e)}class UP extends FL{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=SL(e);let n=T_(e);return null!=this.maxValue&&(n=gE(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}UP.className="ReLU",yT(UP);class VP extends FL{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=SL(e);return bC(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}VP.className="LeakyReLU",yT(VP);class WP extends FL{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=wL(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=BP(e.alphaRegularizer),this.alphaConstraint=eM(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new VD(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=IL(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new AL({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=SL(e),o_(e,this.alpha.read())}getConfig(){const e={alphaInitializer:vL(this.alphaInitializer),alphaRegularizer:PP(this.alphaRegularizer),alphaConstraint:JL(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}WP.className="PReLU",yT(WP);class jP extends FL{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new WD(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=SL(e);return VE(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}jP.className="ELU",yT(jP);class GP extends FL{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=SL(e);return oT(n,tT(dC(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}GP.className="ThresholdedReLU",yT(GP);class HP extends FL{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new TP).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return qS((()=>{let n=SL(e);const r=t.mask;if(null!=r){const e=oT(ST(VC(n.shape),tT(r,n.dtype)),dT(-1e9));n=sT(n,e)}return this.axis instanceof Array?this.axis.length>1?aC(ST(n,_C(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function qP(e,t,n){if("number"===typeof e)return HD(e,t);if(e.length!==t)throw new VD(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!AF(s))throw new VD(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function KP(e,t,n,r){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((s+r-1)/r)}function XP(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+OF([n-t,0]);else{if("same"!==r)throw new VD(`Unsupport padding mode: ${r}.`);e*=t}return e}function YP(e,t){return qS((()=>(xF(t),"channelsFirst"===t?xA(e,[0,2,3,1]):e)))}function QP(e,t){return qS((()=>(xF(t),"channelsFirst"===t?xA(e,[0,2,3,4,1]):e)))}function JP(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return qS((()=>{if(null==a&&(a="channelsLast"),xF(a),3!==e.shape.length)throw new VD(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new VD(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new VD(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=xA(e,[0,2,1])),"causal"===s)throw new WD("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=kE(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=YF(o,n)),o}))}function ZP(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return qS((()=>{if(null==a&&(a="channelsLast"),xF(a),3!==e.rank&&4!==e.rank)throw new VD(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new VD(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=YP(e,a);if("causal"===s)throw new WD("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=FA({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=xA(l,[0,3,1,2])),l}))}function ez(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return qS((()=>{if(null==a&&(a="channelsLast"),xF(a),4!==e.rank&&5!==e.rank)throw new VD(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new VD(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=QP(e,a);if("causal"===s)throw new WD("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=TE(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=YF(o,n)),"channelsFirst"===a&&(o=xA(o,[0,4,1,2,3])),o}))}HP.className="Softmax",yT(HP);class tz extends FL{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",tz.verifyArgs(t),this.rank=e,lF(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new WD(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qP(t.kernelSize,e,"kernelSize"),this.strides=qP(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,kF(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,xF(this.dataFormat),this.activation=OP(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=wL(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=eM(t.biasConstraint),this.biasRegularizer=BP(t.biasRegularizer),this.activityRegularizer=BP(t.activityRegularizer),this.dilationRate=qP(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new VD(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new VD(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new VD(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(qD("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!oF(e.kernelSize,"number",1,3))throw new VD(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:RP(this.activation),useBias:this.useBias,biasInitializer:vL(this.biasInitializer),biasRegularizer:PP(this.biasRegularizer),activityRegularizer:PP(this.activityRegularizer),biasConstraint:JL(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class nz extends tz{constructor(e,t){super(e,t),this.kernel=null,nz.verifyArgs(t),this.filters=t.filters,lF(this.filters,"filters"),this.kernelInitializer=wL(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=eM(t.kernelConstraint),this.kernelRegularizer=BP(t.kernelRegularizer)}build(e){e=IL(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new VD(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return qS((()=>{let t;e=SL(e);const n=null==this.bias?null:this.bias.read(),r=cF(this.activation.getClassName());if(null!=r&&2===this.rank)t=ZP(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=JP(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=ZP(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new WD("convolutions greater than 3D are not implemented yet.");t=ez(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=IL(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=KP(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:vL(this.kernelInitializer),kernelRegularizer:PP(this.kernelRegularizer),kernelConstraint:JL(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new VD(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class rz extends nz{constructor(e){super(2,e),rz.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!oF(e.kernelSize,"number",1,2))throw new VD(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}rz.className="Conv2D",yT(rz);class sz extends nz{constructor(e){super(3,e),sz.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new VD(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}sz.className="Conv3D",yT(sz);class az extends rz{constructor(e){if(super(e),this.inputSpec=[new AL({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new VD(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=IL(e)).length)throw new VD("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new VD("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new AL({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return qS((()=>{let t=SL(e);if(4!==t.shape.length)throw new VD(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[r,XP(i,c,l,this.padding),XP(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=xA(t,[0,2,3,1]));let p=IE(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=xA(p,[0,3,1,2])),null!=this.bias&&(p=YF(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=IL(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=XP(t[r],o,a,this.padding),t[s]=XP(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}az.className="Conv2DTranspose",yT(az);class iz extends sz{constructor(e){if(super(e),this.inputSpec=[new AL({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new VD(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=IL(e)).length)throw new VD("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new VD("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new AL({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return qS((()=>{let t=SL(e);if(5!==t.shape.length)throw new VD(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,XP(o,p,c,this.padding),XP(l,f,h,this.padding),XP(u,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=xA(t,[0,2,3,4,1]));let y=EE(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=xA(y,[0,4,1,2,3])),null!==this.bias&&(y=YF(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=IL(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=XP(t[r],u,i,this.padding),t[s]=XP(t[s],c,o,this.padding),t[a]=XP(t[a],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}iz.className="Conv3DTranspose",yT(iz);class oz extends nz{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new VD("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new VD("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new VD(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=wL(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=BP(t.depthwiseRegularizer),this.depthwiseConstraint=eM(t.depthwiseConstraint),this.pointwiseInitializer=wL(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=BP(t.pointwiseRegularizer),this.pointwiseConstraint=eM(t.pointwiseConstraint)}build(e){if((e=IL(e)).length<this.rank+2)throw new VD(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new VD(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new AL({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return qS((()=>{let t;if(e=SL(e),1===this.rank)throw new WD("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=xA(e,[0,2,3,1])),t=F_(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=YF(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=xA(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=vL(this.depthwiseInitializer),e.pointwiseInitializer=vL(this.pointwiseInitializer),e.depthwiseRegularizer=PP(this.depthwiseRegularizer),e.pointwiseRegularizer=PP(this.pointwiseRegularizer),e.depthwiseConstraint=JL(this.depthwiseConstraint),e.pointwiseConstraint=JL(this.pointwiseConstraint),e}}oz.className="SeparableConv";class lz extends oz{constructor(e){super(2,e)}}lz.className="SeparableConv2D",yT(lz);class uz extends nz{constructor(e){super(1,e),uz.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!oF(e.kernelSize,"number",1,1))throw new VD(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}uz.className="Conv1D",yT(uz);class cz extends FL{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return qS((()=>{if(e=SL(e),"channelsLast"===this.dataFormat){const t=UF(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return UF(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=UF(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return UF(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}cz.className="Cropping2D",yT(cz);class hz extends FL{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,xF(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,iF(gF,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return qS((()=>{let t=SL(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=xA(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?zR.resizeNearestNeighbor(t,[e,r]):zR.resizeBilinear(t,[e,r]);return xA(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?zR.resizeNearestNeighbor(t,[e,r]):zR.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}hz.className="UpSampling2D",yT(hz);class dz extends tz{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=wL(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=eM(e.depthwiseConstraint),this.depthwiseRegularizer=BP(e.depthwiseRegularizer)}build(e){if((e=IL(e)).length<4)throw new VD(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new VD(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return qS((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0;return qS((()=>{null==s&&(s="channelsLast"),xF(s);let i=YP(e,s);if(4!==e.rank)throw new VD(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new VD(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=DE(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=xA(i,[0,3,1,2])),i}))}(e=SL(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=YF(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=IL(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=KP(t,this.kernelSize[0],this.padding,this.strides[0]),a=KP(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=vL(this.depthwiseInitializer),e.depthwiseRegularizer=PP(this.depthwiseRegularizer),e.depthwiseConstraint=JL(this.depthwiseRegularizer),e}}function pz(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new VD("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function fz(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return qS((()=>{const l=t.shape.length;if(l<3)throw new VD(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(DF(2,l));if(t=xA(t,u),null!=a)throw new WD("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&(s=tT(tT(s,"bool"),"float32"),s.rank===l-1&&(s=iC(s,-1)),s=xA(s,u)),r&&(t=E_(t,0),null!=s&&(s=E_(s,0)));const c=[];let h,d=n;const p=t.shape[0],f=mA(t);let m,g;null!=s&&(m=mA(s));for(let t=0;t<p;++t){const n=f[t],r=qS((()=>e(n,d)));if(null==s)h=r[0],d=r[1];else{const e=qS((()=>{const e=m[t],n=ST(JC(e),e);return{output:sT(oT(r[0],e),oT(d[0],n)),newStates:d.map(((t,s)=>sT(oT(r[1][s],e),oT(t,n))))}}));h=e.output,d=e.newStates}o&&c.push(h)}if(o){g=J_(c,1)}return[h,g,d]}))}dz.className="DepthwiseConv2D",yT(dz);class mz extends FL{constructor(e){let t;if(super(e),null==e.cell)throw new VD("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Sz({cells:e.cell}):e.cell,null==t.stateSize)throw new VD("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new AL({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return DF(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){xL(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return qS((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new WD("Constants support is not implemented in RNN yet.");xL(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new AL({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Ib(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new VD(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new AL({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];qS((()=>{if(!this.stateful)throw new BD("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new VD("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>UC([n,e]))):this.states_=[UC([n,this.cell.stateSize])];else if(null==e)KS(this.states_),null!=this.keptStates&&(KS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>UC([n,e]))):this.states_[0]=UC([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new VD(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):KS(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!Ib(r.shape,a))throw new VD(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>XS(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=pz(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new AL({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length);if(a[0]instanceof RL){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return qS((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=SL(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new VD(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=fz(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h}))}getInitialState(e){return qS((()=>{let t=UC(e.shape);return t=tC(t,[1,2]),t=PF(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?jF(t,[1,e]):t)):this.cell.stateSize>1?[jF(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===mz.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=dM(t.cell,n);return new e(Object.assign(t,{cell:r}))}}mz.className="RNN",yT(mz);class gz extends FL{}class yz extends gz{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,lF(this.units,"units"),this.activation=OP(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=wL(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=wL(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=wL(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=BP(e.kernelRegularizer),this.recurrentRegularizer=BP(e.recurrentRegularizer),this.biasRegularizer=BP(e.biasRegularizer),this.kernelConstraint=eM(e.kernelConstraint),this.recurrentConstraint=eM(e.recurrentConstraint),this.biasConstraint=eM(e.biasConstraint),this.dropout=$F([1,OF([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$F([1,OF([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=IL(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return qS((()=>{if(2!==e.length)throw new VD(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Iz({ones:()=>JC(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Iz({ones:()=>JC(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=HF(null!=a?oT(e,a):e,this.kernel.read()),null!=this.bias&&(s=YF(s,this.bias.read())),null!=i&&(n=oT(n,i));let o=sT(s,HF(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:RP(this.activation),useBias:this.useBias,kernelInitializer:vL(this.kernelInitializer),recurrentInitializer:vL(this.recurrentInitializer),biasInitializer:vL(this.biasInitializer),kernelRegularizer:PP(this.kernelRegularizer),recurrentRegularizer:PP(this.recurrentRegularizer),biasRegularizer:PP(this.biasRegularizer),activityRegularizer:PP(this.activityRegularizer),kernelConstraint:JL(this.kernelConstraint),recurrentConstraint:JL(this.recurrentConstraint),biasConstraint:JL(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}yz.className="SimpleRNNCell",yT(yz);class bz extends mz{constructor(e){e.cell=new yz(e),super(e)}call(e,t){return qS((()=>{null!=this.cell.dropoutMask&&(KS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(KS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}bz.className="SimpleRNN",yT(bz);class vz extends gz{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new VD("GRUCell does not support reset_after parameter set to true.");this.units=e.units,lF(this.units,"units"),this.activation=OP(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=OP(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=wL(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=wL(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=wL(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=BP(e.kernelRegularizer),this.recurrentRegularizer=BP(e.recurrentRegularizer),this.biasRegularizer=BP(e.biasRegularizer),this.kernelConstraint=eM(e.kernelConstraint),this.recurrentConstraint=eM(e.recurrentConstraint),this.biasConstraint=eM(e.biasConstraint),this.dropout=$F([1,OF([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$F([1,OF([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=IL(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return qS((()=>{if(2!==e.length)throw new VD(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Iz({ones:()=>JC(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Iz({ones:()=>JC(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=oT(e,s[0]));let u=HF(e,this.kernel.read());this.useBias&&(u=YF(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oT(r,a[0]));const c=this.recurrentKernel.read(),[h,d]=K_(c,[2*this.units,this.units],c.rank-1),p=HF(r,h),[f,m,g]=K_(u,3,u.rank-1),[y,b]=K_(p,2,p.rank-1);i=this.recurrentActivation.apply(sT(f,y)),o=this.recurrentActivation.apply(sT(m,b));const v=HF(oT(o,r),d);l=this.activation.apply(sT(g,v));const w=sT(oT(i,r),oT(sT(1,TC(i)),l));return[w,w]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:RP(this.activation),recurrentActivation:RP(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vL(this.kernelInitializer),recurrentInitializer:vL(this.recurrentInitializer),biasInitializer:vL(this.biasInitializer),kernelRegularizer:PP(this.kernelRegularizer),recurrentRegularizer:PP(this.recurrentRegularizer),biasRegularizer:PP(this.biasRegularizer),activityRegularizer:PP(this.activityRegularizer),kernelConstraint:JL(this.kernelConstraint),recurrentConstraint:JL(this.recurrentConstraint),biasConstraint:JL(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}vz.className="GRUCell",yT(vz);class wz extends mz{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new vz(e),super(e)}call(e,t){return qS((()=>{null!=this.cell.dropoutMask&&(KS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(KS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}wz.className="GRU",yT(wz);class xz extends gz{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,lF(this.units,"units"),this.activation=OP(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=OP(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=wL(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=wL(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=wL(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=BP(e.kernelRegularizer),this.recurrentRegularizer=BP(e.recurrentRegularizer),this.biasRegularizer=BP(e.biasRegularizer),this.kernelConstraint=eM(e.kernelConstraint),this.recurrentConstraint=eM(e.recurrentConstraint),this.biasConstraint=eM(e.biasConstraint),this.dropout=$F([1,OF([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=$F([1,OF([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=IL(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends tL{apply(t,r){const s=e.apply([n]),a=(new rL).apply([n]),i=e.apply([2*n]);return WF(WF(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return qS((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new VD(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Iz({ones:()=>JC(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Iz({ones:()=>JC(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=oT(e,a[0]));let h=HF(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oT(r,i[0])),h=sT(h,HF(r,this.recurrentKernel.read())),this.useBias&&(h=YF(h,this.bias.read()));const[d,p,f,m]=K_(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),u=sT(oT(l,s),oT(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=oT(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:RP(this.activation),recurrentActivation:RP(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vL(this.kernelInitializer),recurrentInitializer:vL(this.recurrentInitializer),biasInitializer:vL(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:PP(this.kernelRegularizer),recurrentRegularizer:PP(this.recurrentRegularizer),biasRegularizer:PP(this.biasRegularizer),activityRegularizer:PP(this.activityRegularizer),kernelConstraint:JL(this.kernelConstraint),recurrentConstraint:JL(this.recurrentConstraint),biasConstraint:JL(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}xz.className="LSTMCell",yT(xz);class kz extends mz{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new xz(e),super(e)}call(e,t){return qS((()=>{null!=this.cell.dropoutMask&&(KS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(KS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}kz.className="LSTM",yT(kz);class Sz extends gz{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return qS((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;xL(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{TF(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const s of t.cells)r.push(dM(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return CL(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}_L(t)}}function Iz(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):QF(t(),n),o=()=>JF(i,t,r);if(!s||s<=1)return XS(o().clone());return Array(s).fill(void 0).map(o).map((e=>XS(e.clone())))}Sz.className="StackedRNNCells",yT(Sz);var Tz=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class Nz extends mz{constructor(e){if(e.unroll)throw new WD("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new WD("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new AL({ndim:5})]}call(e,t){return qS((()=>{if(null!=this.cell.dropoutMask&&(KS(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(KS(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new VD("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return qS((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=UC([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];qS((()=>{if(!this.stateful)throw new BD("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new VD("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>UC(s))):this.states_=[UC(s)];else if(null==e)KS(this.states_),null!=this.keptStates&&(KS(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>UC(s))):this.states_[0]=UC(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new VD(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):KS(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!Ib(n.shape,r))throw new VD(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>XS(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=KP(l,r[0],s,a[0],i[0]),h=KP(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}}Nz.className="ConvRNN2D";class Ez extends xz{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,lF(this.filters,"filters"),this.kernelSize=qP(n,2,"kernelSize"),this.kernelSize.forEach((e=>lF(e,"kernelSize"))),this.strides=qP(r||1,2,"strides"),this.strides.forEach((e=>lF(e,"strides"))),this.padding=s||"valid",kF(this.padding),this.dataFormat=a||"channelsLast",xF(this.dataFormat),this.dilationRate=qP(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>lF(e,"dilationRate")))}build(e){var t;e=IL(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new VD(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends tL{apply(e,t){return VF([n.apply([r]),VC([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return qS((()=>{if(3!==e.length)throw new VD(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Iz({ones:()=>JC(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?oT(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Iz({ones:()=>JC(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[y,b,v,w]=K_(this.kernel.read(),4,3),[x,k,S,I]=this.useBias?K_(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,x,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),h=this.inputConv(h,w,I,this.padding);const[T,N,E,C]=K_(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,T),f=this.recurrentConv(f,N),m=this.recurrentConv(m,E),g=this.recurrentConv(g,C);const _=this.recurrentActivation.apply(sT(l,p)),A=this.recurrentActivation.apply(sT(u,f)),R=sT(oT(A,a),oT(_,this.activation.apply(sT(c,m)))),$=oT(this.recurrentActivation.apply(sT(h,g)),this.activation.apply(R));return[$,$,R]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=Tz(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=xE(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?YF(s,n,this.dataFormat):s}recurrentConv(e,t){return xE(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Ez.className="ConvLSTM2DCell",yT(Ez);class Cz extends Nz{constructor(e){const t=new Ez(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Cz.className="ConvLSTM2D",yT(Cz);class _z extends FL{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return JF((()=>QF(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}_z.className="Dropout",yT(_z);class Az extends _z{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Az.className="SpatialDropout1D",yT(Az);class Rz extends FL{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,lF(this.units,"units"),this.activation=OP(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=wL(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=wL(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=eM(e.kernelConstraint),this.biasConstraint=eM(e.biasConstraint),this.kernelRegularizer=BP(e.kernelRegularizer),this.biasRegularizer=BP(e.biasRegularizer),this.activityRegularizer=BP(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=IL(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=IL(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e),r=cF(this.activation.getClassName());let s;return null!=r?s=HF(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=HF(n,this.kernel.read()),null!=this.bias&&(s=YF(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:RP(this.activation),useBias:this.useBias,kernelInitializer:vL(this.kernelInitializer),biasInitializer:vL(this.biasInitializer),kernelRegularizer:PP(this.kernelRegularizer),biasRegularizer:PP(this.biasRegularizer),activityRegularizer:PP(this.activityRegularizer),kernelConstraint:JL(this.kernelConstraint),biasConstraint:JL(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Rz.className="Dense",yT(Rz);class $z extends FL{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=IL(e);for(const t of e.slice(1))if(null==t)throw new VD(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],RF(e,1)]}call(e,t){return qS((()=>{this.invokeCallHook(e,t);let n=SL(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=xA(n,e)}return function(e){if(e.rank<=1)throw new VD(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],RF(e.shape,1)];return QN(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}$z.className="Flatten",yT($z);class Oz extends FL{constructor(e){super(e),this.supportsMasking=!0,this.activation=OP(e.activation)}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e);return this.activation.apply(n)}))}getConfig(){const e={activation:RP(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Oz.className="Activation",yT(Oz);class Dz extends FL{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return qS((()=>function(e,t){return qS((()=>{if(2!==e.shape.length)throw new VD(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return jF(PF(e,1),[1,t,1])}))}(e=SL(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Dz.className="RepeatVector",yT(Dz);class Fz extends FL{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==a)throw new VD("Can only specifiy one unknown dimension.");a=o}else s*=e}const i=RF(e);if(null!==a){if(0===s||i%s!==0)throw new VD(n);r[a]=i/s}else if(i!==s)throw new VD(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return QN(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Fz.className="Reshape",yT(Fz);class Lz extends FL{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=DF(1,e.dims.length+1);if(!Ib(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new AL({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=IL(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return xA(SL(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}Lz.className="Permute",yT(Lz);class Mz extends FL{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=SL(e);return CN(YC(n,this.maskValue),-1)}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e),r=CN(YC(n,this.maskValue),-1,!0);return oT(n,tT(r,n.dtype))}))}}Mz.className="Masking",yT(Mz);class Pz extends FL{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(YD(e.inputLength))}this.inputDim=e.inputDim,lF(this.inputDim,"inputDim"),this.outputDim=e.outputDim,lF(this.outputDim,"outputDim"),this.embeddingsInitializer=wL(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=BP(e.embeddingsRegularizer),this.activityRegularizer=BP(e.activityRegularizer),this.embeddingsConstraint=eM(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return qS((()=>this.maskZero?(e=SL(e),YC(e,cT(e))):null))}computeOutputShape(e){if(e=IL(e),null==this.inputLength)return[...e,this.outputDim];const t=YD(this.inputLength);if(t.length!==e.length-1)throw new VD(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new VD(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return qS((()=>{this.invokeCallHook(e,t);let n=SL(e);"int32"!==n.dtype&&(n=MF(n,"int32"));const r=qF(this.embeddings.read(),QN(n,[n.size]));return QN(r,IL(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:vL(this.embeddingsInitializer),embeddingsRegularizer:PP(this.embeddingsRegularizer),activityRegularizer:PP(this.activityRegularizer),embeddingsConstraint:JL(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Pz.className="Embedding",yT(Pz);class zz extends FL{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new WD}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new VD("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[IL(e)]),e.length<2)throw new VD(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=sF(t),t.length>1)throw new VD(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===sF(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return qS((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=OF(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=PF(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let i=QN(a,[r].concat(RF(e.slice(1))));i=xA(i,[1,0]),i=QN(i,s),t.push(i),n=!0}else if(e>1){const r=DF(1,e).concat([0]);t.push(xA(a,r)),n=!0}else t.push(a)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=QN(xA(QN(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(DF(0,s-1));r=xA(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=sF(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return qS((()=>{if(null==t)return null;if(!Array.isArray(t))throw new VD("`mask` should be an Array");if(!Array.isArray(e))throw new VD("`inputs` should be an Array");if(t.length!==e.length)throw new VD(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:iC(e,0))))[0];for(let e=1;e<t.length-1;++e)n=AC(n,t[e]);return n}))}}class Bz extends zz{constructor(e){super(e)}mergeFunction(e){return qS((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sT(t,e[n]);return t}))}}Bz.className="Add",yT(Bz);class Uz extends zz{constructor(e){super(e)}mergeFunction(e){return qS((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=oT(t,e[n]);return t}))}}Uz.className="Multiply",yT(Uz);class Vz extends zz{constructor(e){super(e)}mergeFunction(e){return qS((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sT(t,e[n]);return oT(1/e.length,t)}))}}Vz.className="Average",yT(Vz);class Wz extends zz{constructor(e){super(e)}mergeFunction(e){return qS((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=_T(t,e[n]);return t}))}}Wz.className="Maximum",yT(Wz);class jz extends zz{constructor(e){super(e)}mergeFunction(e){return qS((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=jC(t,e[n]);return t}))}}jz.className="Minimum",yT(jz);class Gz extends zz{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new VD("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(Ib(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new VD("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return qS((()=>VF(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new VD("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new VD("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new VD("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new VD(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return qS((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let a=0;a<e.length;++a)null==t[a]?r.push(tT(JC(e[a]),"bool")):t[a].rank<e[a].rank?r.push(iC(t[a],-1)):r.push(t[a]);const s=eE(r,this.axis);return EN(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Hz(e,t){for(;e<0;)e+=t;return e}Gz.className="Concatenate",yT(Gz);class qz extends zz{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){wb(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new WD("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new VD(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new VD(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>Hz(t,e[n].shape.length))):[Hz(this.axes,n.shape.length),Hz(this.axes,r.shape.length)],this.normalize&&(n=pM(n,t[0]),r=pM(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new WD("batchDot is not implemented for tensors of 4D or higher rank yet");if(wb(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),wb(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new WD("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return qS((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=QN(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=QN(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?tC(oT(e,t),a[0]):tC(oT(xA(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=tE(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=Q_(i,t)}return 1===i.shape.length&&(i=iC(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[Hz(this.axes,e.length),Hz(this.axes,t.length)],n}computeOutputShape(e){wb(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new WD("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}qz.className="Dot",yT(qz);class Kz extends FL{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e);return JF((()=>sT(GF(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}Kz.className="GaussianNoise",yT(Kz);class Xz extends FL{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return qS((()=>{this.invokeCallHook(e,t);const n=SL(e);if(this.rate>0&&this.rate<1){return JF((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return oT(n,GF(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}Xz.className="GaussianDropout",yT(Xz);class Yz extends FL{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||SL(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return qS((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=SL(e),r=-1.7580993408473766;let s=pC(w_(n),this.rate);s=MF(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=sT(oT(t,s),oT(sT(s,-1),r));return sT(oT(o,a),i)};return JF(r,(()=>SL(e)),t.training||!1)}return e}))}}function Qz(e,t,n,r,s){let a,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)a=lE(e,t,n,r,s,i);else if(3===e.rank)a=uE(e,t,n,r,s,i);else{if(4!==e.rank)throw new WD(`batchNormalization is not implemented for array of rank ${e.rank} yet`);a=cE(e,t,n,r,s,i)}return a}function Jz(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Ib(r.slice().sort(),DF(0,e.rank-1))?function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return qS((()=>{const a=qC(e,r),i=a.mean,o=a.variance;return[Qz(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return qS((()=>{const a=qC(e,r),i=a.mean,o=a.variance,l=[];for(const t of DF(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=QN(i,l),c=QN(o,l),h=null==t?null:QN(t,l),d=null==n?null:QN(n,l);return[Qz(e,u,c,d,h,s),i,o]}))}(e,t,n,r,s)}Yz.className="AlphaDropout",yT(Yz);class Zz extends FL{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=wL(e.betaInitializer||"zeros"),this.gammaInitializer=wL(e.gammaInitializer||"ones"),this.movingMeanInitializer=wL(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=wL(e.movingVarianceInitializer||"ones"),this.betaConstraint=eM(e.betaConstraint),this.gammaConstraint=eM(e.gammaConstraint),this.betaRegularizer=BP(e.betaRegularizer),this.gammaRegularizer=BP(e.gammaRegularizer)}build(e){e=IL(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new VD(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new AL({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return qS((()=>{const n=null!=t.training&&t.training,r=SL(e),s=r.shape,a=s.length,i=DF(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=HD(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!Ib(u,DF(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=QN(this.movingMean.read(),l),t=QN(this.movingVariance.read(),l),n=this.center?QN(this.beta.read(),l):null,s=this.scale?QN(this.gamma.read(),l):null;return Qz(r,e,t,n,s,this.epsilon)}return Qz(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=Jz(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{qS((()=>{const r=1-n,s=e.read(),a=oT(ST(s,t),r);e.write(ST(s,a))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vL(this.betaInitializer),gammaInitializer:vL(this.gammaInitializer),movingMeanInitializer:vL(this.movingMeanInitializer),movingVarianceInitializer:vL(this.movingVarianceInitializer),betaRegularizer:PP(this.betaRegularizer),gammaRegularizer:PP(this.gammaRegularizer),betaConstraint:JL(this.betaConstraint),gammaConstraint:JL(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Zz.className="BatchNormalization",yT(Zz);class eB extends FL{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=wL(e.betaInitializer||"zeros"),this.gammaInitializer=wL(e.gammaInitializer||"ones"),this.betaRegularizer=BP(e.betaRegularizer),this.gammaRegularizer=BP(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=IL(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==sF(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=SL(e),r=n.shape,s=r.length;return qS((()=>{let{mean:e,variance:t}=qC(n,this.axis,!0);const a=HD(1,s);for(const n of this.axis)a[n]=r[n];const i=e=>null!=e&&e.shape.length!==s?QN(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=lC(e,u),t=lC(t,u),null!=o&&(o=lC(o,c)),null!=l&&(l=lC(l,c)),Qz(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vL(this.betaInitializer),gammaInitializer:vL(this.gammaInitializer),betaRegularizer:PP(this.betaRegularizer),gammaRegularizer:PP(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}eB.className="LayerNormalization",yT(eB);class tB extends FL{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new VD(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new VD(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new VD(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new AL({ndim:4})]}computeOutputShape(e){let t,n;return e=IL(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return qS((()=>function(e,t,n){return qS((()=>{if(4!==e.rank)throw new VD(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new VD("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new VD(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],e_(e,r)}))}(SL(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function nB(e,t,n,r,s,a){return qS((()=>{let i;xF(s),SF(a),kF(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=YP(e,s);const o="same"===r?"same":"valid";return i="max"===a?MC(e,t,n,o):JN(e,t,n,o),"channelsFirst"===s&&(i=xA(i,[0,3,1,2])),i}))}function rB(e,t,n,r,s,a){return qS((()=>{let i;xF(s),SF(a),kF(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=QP(e,s);const o="same"===r?"same":"valid";return i="max"===a?PC(e,t,n,o):ZN(e,t,n,o),"channelsFirst"===s&&(i=xA(i,[0,4,1,2,3])),i}))}tB.className="ZeroPadding2D",yT(tB);class sB extends FL{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new VD(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(lF(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new VD(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}lF(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,kF(this.padding),this.inputSpec=[new AL({ndim:3})]}computeOutputShape(e){const t=KP((e=IL(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return qS((()=>{this.invokeCallHook(e,t),e=PF(SL(e),2);const n=this.poolingFunction(SL(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Q_(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class aB extends sB{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xF(s),kF(r),nB(e,t,n,r,s,"max")}}aB.className="MaxPooling1D",yT(aB);class iB extends sB{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xF(s),kF(r),nB(e,t,n,r,s,"avg")}}iB.className="AveragePooling1D",yT(iB);class oB extends FL{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new VD(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];lF(this.poolSize,"poolSize"),lF(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,xF(this.dataFormat),kF(this.padding),this.inputSpec=[new AL({ndim:4})]}computeOutputShape(e){e=IL(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=KP(t,this.poolSize[0],this.padding,this.strides[0]),n=KP(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return qS((()=>(this.invokeCallHook(e,t),this.poolingFunction(SL(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class lB extends oB{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xF(s),kF(r),nB(e,t,n,r,s,"max")}}lB.className="MaxPooling2D",yT(lB);class uB extends oB{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xF(s),kF(r),nB(e,t,n,r,s,"avg")}}uB.className="AveragePooling2D",yT(uB);class cB extends FL{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new VD(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];lF(this.poolSize,"poolSize"),lF(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,xF(this.dataFormat),kF(this.padding),this.inputSpec=[new AL({ndim:5})]}computeOutputShape(e){e=IL(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=KP(t,this.poolSize[0],this.padding,this.strides[0]),n=KP(n,this.poolSize[1],this.padding,this.strides[1]),r=KP(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return qS((()=>(this.invokeCallHook(e,t),this.poolingFunction(SL(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class hB extends cB{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xF(s),kF(r),rB(e,t,n,r,s,"max")}}hB.className="MaxPooling3D",yT(hB);class dB extends cB{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return xF(s),kF(r),rB(e,t,n,r,s,"avg")}}dB.className="AveragePooling3D",yT(dB);class pB extends FL{constructor(e){super(e),this.inputSpec=[new AL({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new WD}}class fB extends pB{constructor(e){super(e||{})}call(e,t){return qS((()=>{const t=SL(e);return BC(t,1)}))}}fB.className="GlobalAveragePooling1D",yT(fB);class mB extends pB{constructor(e){super(e||{})}call(e,t){return qS((()=>{const t=SL(e);return ZE(t,1)}))}}mB.className="GlobalMaxPooling1D",yT(mB);class gB extends FL{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,xF(this.dataFormat),this.inputSpec=[new AL({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new WD}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class yB extends gB{call(e,t){return qS((()=>{const t=SL(e);return"channelsLast"===this.dataFormat?BC(t,[1,2]):BC(t,[2,3])}))}}yB.className="GlobalAveragePooling2D",yT(yB);class bB extends gB{call(e,t){return qS((()=>{const t=SL(e);return"channelsLast"===this.dataFormat?ZE(t,[1,2]):ZE(t,[2,3])}))}}bB.className="GlobalMaxPooling2D",yT(bB);class vB extends FL{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=dM(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class wB extends vB{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=IL(e)).length<3)throw new VD(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=IL(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return qS((()=>fz(((e,n)=>[SL(this.layer.call(e,t)),[]]),e=SL(e),[],!1,null,null,!1,!0)[1]))}}wB.className="TimeDistributed",yT(wB);class xB extends vB{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=dM(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=dM(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,iF(vF,"BidirectionalMergeMode",s),e.weights)throw new WD("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):XD(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=pz(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new VD("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new AL({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new WD("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof RL;for(const l of a)if(l instanceof RL!==o)throw new VD("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return qS((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=E_(s,1)),"concat"===this.mergeMode?i=VF([r,s]):"sum"===this.mergeMode?i=sT(r,s):"ave"===this.mergeMode?i=oT(.5,sT(r,s)):"mul"===this.mergeMode?i=oT(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){TF(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),TF(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=dM(t.layer);if(delete t.layer,null!=t.numConstants)throw new WD("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}xB.className="Bidirectional",yT(xB);class kB extends FL{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return qS((()=>("float32"!==(e=SL(e)).dtype&&(e=MF(e,"float32")),sT(oT(e,this.scale),this.offset))))}}kB.className="Rescaling",yT(kB);const{resizeBilinear:SB,cropAndResize:IB}=zR;class TB extends FL{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return qS((()=>{let l,u=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],h=[];3===e.rank?(u=!0,l=J_([e])):l=e;for(let e=0;e<l.shape[0];e++)h.push(c);const d=VS(h,[h.length,4]),p=k_(0,h.length,1,"int32"),f=IB(l,d,p,[r,s],"nearest");return MF(u?SL(mA(f)):f,o)}))}upsize(e,t,n,r){return qS((()=>MF(SB(e,[t,n]),r)))}call(e,t){return qS((()=>{const t=SL(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=IL(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}TB.className="CenterCrop",yT(TB);class NB extends FL{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=IL(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return qS((()=>{let n;if("int32"!==(e=SL(e)).dtype&&(e=MF(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new VD(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=SL(t.countWeights)}const r=ZE(e),s=eC(e),a=dC(this.numTokens,r).bufferSync().get(0),i=pC(s,0).bufferSync().get(0);if(!a||!i)throw new VD(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=SL(e);if("int32"!==s.dtype&&(s=MF(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=iC(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=iC(s,-1)),s.rank>2)throw new VD(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(l=$E(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return oT(l,r);throw new VD("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}NB.className="CategoryEncoding",yT(NB);const EB=new Set(["bilinear","nearest"]);class CB extends FL{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!EB.has(e.interpolation))throw new VD(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=IL(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return qS((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return zR.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return zR.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...EB]} are supported`)}))}}CB.className="Resizing",yT(CB);class _B{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}_B.className="RandomSeed";class AB extends FL{constructor(e){super(e),this.randomGenerator=new _B(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}AB.className="BaseRandomLayer";const RB=new Set(["bilinear","nearest"]);class $B extends AB{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new VD(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new VD(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new VD(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!RB.has(n))throw new VD(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=IL(e))[2];return[this.imgHeight,-1,t]}call(e,t){return qS((()=>{const t=SL(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=w_([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return zR.resizeBilinear(e,s);case"nearest":return zR.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...RB]} are supported`)}}))}}$B.className="RandomWidth",yT($B);var OB,DB;ev().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(OB||(OB={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(DB||(DB={}));const FB={};function LB(e){return FB[e]}function MB(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return PB(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)})).map((e=>PB(e,n,r,s)))}const l=PB(t.inputNames[o],n,r,s),u=l.dataSync();return"number"===a.type?u[0]:Wb(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function PB(e,t,n,r){const[s,a]=VB(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[UB(s,e)]));return void 0!==i?t[UB(s,i)][a]:void 0}function zB(e,t,n){return t[UB(e,n.currentContextId)]}function BB(e,t){const[n,r,s]=VB(e,t);return[UB(n,t&&t.currentContextId),r,s]}function UB(e,t){return t?`${e}-${t}`:e}function VB(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function WB(e,t,n){let r=MB("pad",e,t,n);if("explicit"===r){r=MB("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function jB(e){return e.kept?e:nT(e)}const GB=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],HB=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],qB=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],KB=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],XB=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],YB=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],QB=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],JB=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ZB=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],eU=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],tU=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],nU=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],rU=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],sU=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],aU=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],iU=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],oU=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],lU=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],uU=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class cU{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[o,l,u,c,h,d,p,f,m,g,y,b,v,w,x,k,S,I,T].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=BB(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(c).length?h.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=BB(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=BB(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:d};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=LB(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=dU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=dU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=kU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=kU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=fU(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=fU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=xU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=xU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=pU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=pU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=IU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=IU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=wU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=wU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=SU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=SU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=yU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=yU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=bU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=bU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=gU(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=gU(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=BB(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:mU(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[s,,a]=BB(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=BB(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function hU(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=ev().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function dU(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return null!=s?hU(s.s,r):n}function pU(e,t,n){const r=e[t];return r?r.b:n}function fU(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof s?s:parseInt(s,10)}function mU(e){switch("string"===typeof e&&(e=OB[e]),e){case OB.DT_FLOAT:case OB.DT_HALF:return"float32";case OB.DT_INT32:case OB.DT_INT64:case OB.DT_INT8:case OB.DT_UINT8:return"int32";case OB.DT_BOOL:return"bool";case OB.DT_DOUBLE:return"float32";case OB.DT_STRING:return"string";case OB.DT_COMPLEX64:case OB.DT_COMPLEX128:return"complex64";default:return null}}function gU(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function yU(e,t,n){const r=e[t];return r&&r.type?mU(r.type):n}function bU(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>mU(e))):n}function vU(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function wU(e,t,n){const r=e[t];return r&&r.shape?vU(r.shape):n}function xU(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function kU(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>hU(e,r))):n}function SU(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>vU(e))):n}function IU(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class TU{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return PB(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return PB(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return fU(this.node.rawAttrs,e,t);if(null!=n.s)return dU(this.node.rawAttrs,e,t);if(null!=n.b)return pU(this.node.rawAttrs,e,t);if(null!=n.shape)return wU(this.node.rawAttrs,e,t);if(null!=n.type)return yU(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return xU(this.node.rawAttrs,e,t);if(null!=n.list.s)return kU(this.node.rawAttrs,e,t);if(null!=n.list.shape)return SU(this.node.rawAttrs,e,t);if(null!=n.list.b)return IU(this.node.rawAttrs,e,t);if(null!=n.list.type)return bU(this.node.rawAttrs,e,t)}return t}}function NU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){wb(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];wb(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function EU(e){return"number"!==typeof e&&!e.some((e=>e<0))}function CU(e,t,n){let r=_U(e,n);const s=!EU(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=_U(e.shape,r)})),!EU(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function _U(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class AU{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=dT(0),XS(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),NU(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,XS(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return VS([],[0].concat(this.elementShape));const n=this.readMany(e);return NU(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),J_(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return VS([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return NU(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),eE(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,mA(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];qS((()=>{t=QN(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=QN(rE(t,i,o),this.elementShape)}return a}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}}class RU{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);NU(t,e.shape,"TensorList shape mismatch: "),XS(e)})),this.idTensor=dT(0),this.maxNumElements=r,XS(this.idTensor)}copy(){return new RU([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);NU(e,this.elementShape,"TensorList shape mismatch: ");const r=CU(this.elementShape,this.tensors,e);return qS((()=>{const e=this.tensors.map((e=>QN(e,r)));return J_(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=CU(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,NU(r.shape,e,"TensorList shape mismatch: "),QN(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(NU(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");XS(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new RU([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);NU(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=CU(this.elementShape,this.tensors,t);return QN(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);NU(this.elementShape,t.shape,"TensorList shape mismatch: "),XS(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);NU(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=CU(this.elementShape,this.tensors,n);return 0===e.length?VS([],[0].concat(r)):qS((()=>{const t=e.map((e=>QN(this.tensors[e],r)));return J_(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);NU(this.elementShape,t,"TensorList shape mismatch: ");const n=CU(this.elementShape,this.tensors,t);return 0===this.size()?VS([],[0].concat(n)):qS((()=>{const e=this.tensors.map((e=>QN(e,n)));return eE(e,0)}))}}const $U=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=MB("thenBranch",e,t,n),s=MB("elseBranch",e,t,n),a=MB("cond",e,t,n),i=MB("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=MB("body",e,t,n),s=MB("cond",e,t,n),a=MB("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=a;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[jB(MB("pred",e,t,n))];case"Switch":{const r=MB("pred",e,t,n);let s=MB("data",e,t,n);return s.kept||(s=jB(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==PB(e,t,n)));if(r){return[jB(PB(r,t,n))]}return}case"Enter":{const r=MB("frameName",e,t,n),s=MB("tensor",e,t,n);return n.enterFrame(r),[jB(s)]}case"Exit":{const r=MB("tensor",e,t,n);return n.exitFrame(),[jB(r)]}case"NextIteration":{const r=MB("tensor",e,t,n);return n.nextIteration(),[jB(r)]}case"TensorArrayV3":{const r=MB("size",e,t,n),s=MB("dtype",e,t,n),a=MB("elementShape",e,t,n),i=MB("dynamicSize",e,t,n),o=MB("clearAfterRead",e,t,n),l=MB("identicalElementShapes",e,t,n),u=MB("name",e,t,n),c=new AU(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,dT(1)]}case"TensorArrayWriteV3":{const r=MB("tensorArrayId",e,t,n),s=MB("index",e,t,n),a=MB("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=MB("tensorArrayId",e,t,n),s=MB("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=MB("tensorArrayId",e,t,n),s=MB("indices",e,t,n),a=MB("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=MB("tensorArrayId",e,t,n),s=MB("indices",e,t,n),a=MB("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=MB("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=MB("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=MB("tensorArrayId",e,t,n),s=MB("tensor",e,t,n),a=MB("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=MB("tensorArrayId",e,t,n);return[dT(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=MB("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=MB("tensorListId",e,t,n),s=MB("index",e,t,n),a=MB("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=MB("tensorListId",e,t,n),s=MB("index",e,t,n),a=MB("elementShape",e,t,n),i=MB("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=MB("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new RU([],n,e.dtype,r),i=mA(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}(MB("tensor",e,t,n),r,MB("elementShape",e,t,n),MB("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=MB("elementShape",e,t,n),s=MB("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=MB(a,e,t,n),o=function(e,t,n,r){return new RU([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=MB("tensorListId",e,t,n),s=MB("indices",e,t,n),a=MB("elementShape",e,t,n),i=MB("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=MB("tensorListId",e,t,n),s=MB("elementShape",e,t,n),a=MB("elementDType",e,t,n),i=MB("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);NU(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=mA(e);return new RU(s,t,r)}(MB("tensor",e,t,n),MB("elementShape",e,t,n),MB("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=MB("tensorListId",e,t,n),s=n.getTensorList(r.id),a=MB("dtype",e,t,n),i=MB("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=MB("tensorListId",e,t,n),s=MB("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=MB("tensorListId",e,t,n),s=MB("elementShape",e,t,n),a=MB("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=MB("tensor",e,t,n),s=MB("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=_U(e.shape.slice(1),n),i=0===r?0:e.size/r,o=qS((()=>{const n=[];e=QN(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],l=[1,t[r],i];n[r]=QN(rE(e,o,l),a)}return e.dispose(),n})),l=new RU([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,MB("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=MB("tensorListId",e,t,n);return[dT(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=MB("tensorListId",e,t,n),s=MB("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function OU(e,t,n){const[r,s]=MB("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=MB("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=MB("strides",e,t,n),h=WB(e,t,n),d=MB("dataFormat",e,t,n).toUpperCase(),p=MB("dilations",e,t,n);let[f,m]=MB("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:MB("leakyreluAlpha",e,t,n)}}function DU(e,t,n){return{boxes:MB("boxes",e,t,n),scores:MB("scores",e,t,n),maxOutputSize:MB("maxOutputSize",e,t,n),iouThreshold:MB("iouThreshold",e,t,n),scoreThreshold:MB("scoreThreshold",e,t,n),softNmsSigma:MB("softNmsSigma",e,t,n)}}class FU{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=dT(0),this.tensorMap=new Map,XS(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return dT(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),qS((()=>{const e=mA(t),r=n.length,s=e.length;wb(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];XS(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return qS((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return J_(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function LU(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:qS;const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(MB("a",e,t,n),MB("b",e,t,n))];case"AddN":return[r.addN(MB("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(MB("a",e,t,n),MB("b",e,t,n))];case"Mul":return[r.mul(MB("a",e,t,n),MB("b",e,t,n))];case"RealDiv":case"Div":return[r.div(MB("a",e,t,n),MB("b",e,t,n))];case"DivNoNan":return[r.divNoNan(MB("a",e,t,n),MB("b",e,t,n))];case"FloorDiv":return[r.floorDiv(MB("a",e,t,n),MB("b",e,t,n))];case"Sub":return[r.sub(MB("a",e,t,n),MB("b",e,t,n))];case"Minimum":return[r.minimum(MB("a",e,t,n),MB("b",e,t,n))];case"Maximum":return[r.maximum(MB("a",e,t,n),MB("b",e,t,n))];case"Pow":return[r.pow(MB("a",e,t,n),MB("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(MB("a",e,t,n),MB("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(MB("x",e,t,n))];case"Acos":return[r.acos(MB("x",e,t,n))];case"Acosh":return[r.acosh(MB("x",e,t,n))];case"Asin":return[r.asin(MB("x",e,t,n))];case"Asinh":return[r.asinh(MB("x",e,t,n))];case"Atan":return[r.atan(MB("x",e,t,n))];case"Atan2":return[r.atan2(MB("x",e,t,n),MB("y",e,t,n))];case"Atanh":return[r.atanh(MB("x",e,t,n))];case"Ceil":return[r.ceil(MB("x",e,t,n))];case"Complex":return[r.complex(MB("real",e,t,n),MB("imag",e,t,n))];case"Cos":return[r.cos(MB("x",e,t,n))];case"Cosh":return[r.cosh(MB("x",e,t,n))];case"Elu":return[r.elu(MB("x",e,t,n))];case"Erf":return[r.erf(MB("x",e,t,n))];case"Exp":return[r.exp(MB("x",e,t,n))];case"Expm1":return[r.expm1(MB("x",e,t,n))];case"Floor":return[r.floor(MB("x",e,t,n))];case"Log":return[r.log(MB("x",e,t,n))];case"Log1p":return[r.log1p(MB("x",e,t,n))];case"Imag":return[r.imag(MB("x",e,t,n))];case"Neg":return[r.neg(MB("x",e,t,n))];case"Reciprocal":return[r.reciprocal(MB("x",e,t,n))];case"Real":return[r.real(MB("x",e,t,n))];case"Relu":return[r.relu(MB("x",e,t,n))];case"Round":return[r.round(MB("x",e,t,n))];case"Selu":return[r.selu(MB("x",e,t,n))];case"Sigmoid":return[r.sigmoid(MB("x",e,t,n))];case"Sin":return[r.sin(MB("x",e,t,n))];case"Sign":return[r.sign(MB("x",e,t,n))];case"Sinh":return[r.sinh(MB("x",e,t,n))];case"Softplus":return[r.softplus(MB("x",e,t,n))];case"Sqrt":return[r.sqrt(MB("x",e,t,n))];case"Square":return[r.square(MB("x",e,t,n))];case"Tanh":return[r.tanh(MB("x",e,t,n))];case"Tan":return[r.tan(MB("x",e,t,n))];case"ClipByValue":return[r.clipByValue(MB("x",e,t,n),MB("clipValueMin",e,t,n),MB("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(MB("x",e,t,n))];case"Rsqrt":return[r.rsqrt(PB(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(MB("x",e,t,n),MB("alpha",e,t,n))];case"Prelu":return[r.prelu(MB("x",e,t,n),MB("alpha",e,t,n))];case"IsNan":return[r.isNaN(PB(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(PB(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(PB(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return $U(e,t,n);case"convolution":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Conv1D":{const s=MB("stride",e,t,n),a=MB("pad",e,t,n),i=MB("dataFormat",e,t,n).toUpperCase(),o=MB("dilation",e,t,n);return[r.conv1d(MB("x",e,t,n),MB("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=MB("strides",e,t,n),a=WB(e,t,n),i=MB("dataFormat",e,t,n).toUpperCase(),o=MB("dilations",e,t,n);return[r.conv2d(MB("x",e,t,n),MB("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=OU(e,t,n);return[r.fused.conv2d({x:MB("x",e,t,n),filter:MB("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=OU(e,t,n);return[r.fused.depthwiseConv2d({x:MB("x",e,t,n),filter:MB("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=MB("outputShape",e,t,n),a=MB("strides",e,t,n),i=WB(e,t,n);return[r.conv2dTranspose(MB("x",e,t,n),MB("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=MB("strides",e,t,n),a=WB(e,t,n),i=MB("dilations",e,t,n),o=MB("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(MB("input",e,t,n),MB("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("dataFormat",e,t,n).toUpperCase(),o=MB("dilations",e,t,n);return[r.conv3d(MB("x",e,t,n),MB("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("kernelSize",e,t,n);return[r.avgPool(MB("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("kernelSize",e,t,n);return[r.maxPool(MB("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("kernelSize",e,t,n),o=MB("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(MB("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("kernelSize",e,t,n);return[r.avgPool3d(MB("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("kernelSize",e,t,n);return[r.maxPool3d(MB("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=MB("strides",e,t,n),a=MB("pad",e,t,n),i=MB("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(MB("x",e,t,n),MB("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Fill":{const s=MB("shape",e,t,n),a=MB("dtype",e,t,n),i=MB("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=MB("start",e,t,n),a=MB("stop",e,t,n),i=MB("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=MB("logits",e,t,n),a=MB("numSamples",e,t,n),i=MB("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=MB("indices",e,t,n),a=MB("depth",e,t,n),i=MB("onValue",e,t,n),o=MB("offValue",e,t,n),l=MB("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(MB("shape",e,t,n),MB("dtype",e,t,n))];case"OnesLike":return[r.onesLike(MB("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(MB("shape",e,t,n),MB("dtype",e,t,n),MB("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(MB("shape",e,t,n),MB("minval",e,t,n),MB("maxval",e,t,n),MB("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(MB("shape",e,t,n),MB("minval",e,t,n),MB("maxval",e,t,n),MB("seed",e,t,n))];case"Range":{const s=MB("start",e,t,n),a=MB("stop",e,t,n),i=MB("step",e,t,n);return[r.range(s,a,i,MB("dtype",e,t,n))]}case"TruncatedNormal":{const s=MB("shape",e,t,n),a=MB("mean",e,t,n),i=MB("stdDev",e,t,n),o=MB("seed",e,t,n);return[r.truncatedNormal(s,a,i,MB("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(MB("shape",e,t,n),MB("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(MB("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:N;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=DU(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=DU(e,t,n),u=MB("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=DU(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,l)]}case"Where":{const r=s.cast(MB("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(MB("x",e,t,n),MB("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"LowerBound":{const s=MB("sortedSequence",e,t,n),a=MB("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=MB("x",e,t,n),a=MB("k",e,t,n),i=MB("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=MB("sortedSequence",e,t,n),a=MB("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=MB("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=MB("x",e,t,n),a=MB("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"ResizeBilinear":{const s=MB("images",e,t,n),a=MB("size",e,t,n),i=MB("alignCorners",e,t,n),o=MB("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=MB("images",e,t,n),a=MB("size",e,t,n),i=MB("alignCorners",e,t,n),o=MB("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=MB("image",e,t,n),a=MB("boxes",e,t,n),i=MB("boxInd",e,t,n),o=MB("cropSize",e,t,n),l=MB("method",e,t,n),u=MB("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=MB("images",e,t,n),a=MB("transforms",e,t,n),i=MB("outputShape",e,t,n),o=MB("fillValue",e,t,n),l=MB("interpolation",e,t,n),u=MB("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=MB("default",e,t,n);return[PB(e.name,t,n)||s];case"Placeholder":return[PB(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[jB(MB("x",e,t,n))];case"IdentityN":return MB("x",e,t,n).map((e=>jB(e)));case"Shape":return[r.tensor1d(MB("x",e,t,n).shape,"int32")];case"ShapeN":return MB("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(MB("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(MB("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=MB("x",e,t,n),i=MB("data",e,t,n),o=MB("message",e,t,n),l=MB("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Equal":return[r.equal(MB("a",e,t,n),MB("b",e,t,n))];case"NotEqual":return[r.notEqual(MB("a",e,t,n),MB("b",e,t,n))];case"Greater":return[r.greater(MB("a",e,t,n),MB("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(MB("a",e,t,n),MB("b",e,t,n))];case"Less":return[r.less(MB("a",e,t,n),MB("b",e,t,n))];case"LessEqual":return[r.lessEqual(MB("a",e,t,n),MB("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(MB("a",e,t,n),MB("b",e,t,n))];case"LogicalNot":return[r.logicalNot(MB("a",e,t,n))];case"LogicalOr":return[r.logicalOr(MB("a",e,t,n),MB("b",e,t,n))];case"Select":case"SelectV2":return[r.where(MB("condition",e,t,n),MB("a",e,t,n),MB("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(MB("a",e,t,n),MB("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(MB("a",e,t,n),MB("b",e,t,n),MB("transposeA",e,t,n),MB("transposeB",e,t,n))];case"Einsum":return[r.einsum(MB("equation",e,t,n),...MB("tensors",e,t,n))];case"Transpose":return[r.transpose(MB("x",e,t,n),MB("perm",e,t,n))];case"_FusedMatMul":const[s,a]=MB("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,l=MB("numArgs",e,t,n),u=MB("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=MB("args",e,t,n);return[r.fused.matMul({a:MB("a",e,t,n),b:MB("b",e,t,n),transposeA:MB("transposeA",e,t,n),transposeB:MB("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(MB("a",e,t,n),MB("numLower",e,t,n),MB("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(MB("x",e,t,n),MB("axis",e,t,n),MB("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(MB("x",e,t,n),MB("mean",e,t,n),MB("variance",e,t,n),MB("offset",e,t,n),MB("scale",e,t,n),MB("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(MB("x",e,t,n),MB("radius",e,t,n),MB("bias",e,t,n),MB("alpha",e,t,n),MB("beta",e,t,n))];case"Softmax":return[r.softmax(MB("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(MB("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(MB("paramsNestedSplits",e,t,n),MB("paramsDenseValues",e,t,n),MB("indices",e,t,n),MB("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(MB("starts",e,t,n),MB("limits",e,t,n),MB("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(MB("shape",e,t,n),MB("values",e,t,n),MB("defaultValue",e,t,n),MB("rowPartitionTensors",e,t,n),MB("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Max":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.max(MB("x",e,t,n),s,a)]}case"Mean":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.mean(MB("x",e,t,n),s,a)]}case"Min":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.min(MB("x",e,t,n),s,a)]}case"Sum":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.sum(MB("x",e,t,n),s,a)]}case"All":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.all(MB("x",e,t,n),s,a)]}case"Any":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.any(MB("x",e,t,n),s,a)]}case"ArgMax":{const s=MB("axis",e,t,n);return[r.argMax(MB("x",e,t,n),s)]}case"ArgMin":{const s=MB("axis",e,t,n);return[r.argMin(MB("x",e,t,n),s)]}case"Prod":{const s=MB("axis",e,t,n),a=MB("keepDims",e,t,n);return[r.prod(MB("x",e,t,n),s,a)]}case"Cumprod":{const s=MB("axis",e,t,n),a=MB("exclusive",e,t,n),i=MB("reverse",e,t,n);return[r.cumprod(MB("x",e,t,n),s,a,i)]}case"Cumsum":{const s=MB("axis",e,t,n),a=MB("exclusive",e,t,n),i=MB("reverse",e,t,n);return[r.cumsum(MB("x",e,t,n),s,a,i)]}case"Bincount":const s=MB("x",e,t,n),a=MB("weights",e,t,n),i=MB("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=MB("x",e,t,n),a=MB("weights",e,t,n),i=MB("size",e,t,n),o=MB("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"ConcatV2":case"Concat":{const s=MB("n",e,t,n),a=MB("axis",e,t,n);let i=MB("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=MB("x",e,t,n),a=MB("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=MB("axis",e,t,n),a=MB("batchDims",e,t,n),i=MB("x",e,t,n),o=MB("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=MB("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=MB("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=MB("axis",e,t,n),a=MB("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=MB("begin",e,t,n),a=MB("size",e,t,n);return[r.slice(MB("x",e,t,n),s,a)]}case"StridedSlice":{const s=MB("begin",e,t,n),a=MB("end",e,t,n),i=MB("strides",e,t,n),o=MB("beginMask",e,t,n),l=MB("endMask",e,t,n),u=MB("ellipsisMask",e,t,n),c=MB("newAxisMask",e,t,n),h=MB("shrinkAxisMask",e,t,n),d=MB("x",e,t,n);return[r.stridedSlice(d,s,a,i,o,l,u,c,h)]}case"Pack":return qS((()=>{const s=MB("axis",e,t,n),a=MB("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map((e=>{const t=Ib(e.shape,i);if(!t&&!Ib(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,s)]}));case"Unpack":{const s=MB("axis",e,t,n),a=MB("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=MB("reps",e,t,n);return[r.tile(MB("x",e,t,n),s)]}case"Split":case"SplitV":{const s=MB("axis",e,t,n),a=MB("numOrSizeSplits",e,t,n),i=MB("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=MB("indices",e,t,n),a=MB("values",e,t,n),i=MB("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=MB("x",e,t,n),a=MB("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=MB("sparseIndices",e,t,n),a=MB("outputShape",e,t,n),i=MB("sparseValues",e,t,n),o=MB("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=MB("indices",e,t,n),a=MB("values",e,t,n),i=MB("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(MB("indices",e,t,n),MB("values",e,t,n),MB("denseShape",e,t,n),MB("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(MB("inputIndices",e,t,n),MB("inputShape",e,t,n),MB("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(MB("data",e,t,n),MB("indices",e,t,n),MB("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(MB("data",e,t,n),MB("indices",e,t,n),MB("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"FFT":return[r.fft(MB("x",e,t,n))];case"IFFT":return[r.ifft(MB("x",e,t,n))];case"RFFT":return[r.rfft(MB("x",e,t,n))];case"IRFFT":return[r.irfft(MB("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(MB("input",e,t,n),MB("pattern",e,t,n),MB("rewrite",e,t,n),MB("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(MB("data",e,t,n),MB("dataSplits",e,t,n),MB("separator",e,t,n),MB("nGramWidths",e,t,n),MB("leftPad",e,t,n),MB("rightPad",e,t,n),MB("padWidth",e,t,n),MB("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(MB("input",e,t,n),MB("delimiter",e,t,n),MB("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(MB("input",e,t,n),MB("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;switch(e.op){case"Cast":return[r.cast(MB("x",e,t,n),MB("dtype",e,t,n))];case"ExpandDims":{const s=MB("axis",e,t,n);return[r.expandDims(MB("x",e,t,n),s)]}case"Squeeze":{const s=MB("axis",e,t,n);return[r.squeeze(MB("x",e,t,n),s)]}case"Reshape":return[r.reshape(MB("x",e,t,n),MB("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(MB("x",e,t,n),MB("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(MB("x",e,t,n),MB("padding",e,t,n),MB("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(MB("x",e,t,n),MB("padding",e,t,n),MB("constantValue",e,t,n))];case"SpaceToBatchND":{const s=MB("blockShape",e,t,n),a=MB("paddings",e,t,n);return[r.spaceToBatchND(MB("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=MB("blockShape",e,t,n),a=MB("crops",e,t,n);return[r.batchToSpaceND(MB("x",e,t,n),s,a)]}case"DepthToSpace":{const s=MB("blockSize",e,t,n),a=MB("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(MB("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(MB("x",e,t,n),MB("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(MB("s0",e,t,n),MB("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=MB("keyDType",e,t,n),a=MB("valueDType",e,t,n),i=new FU(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=MB("tableHandle",e,t,n,r),a=MB("keys",e,t,n),i=MB("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=MB("tableHandle",e,t,n,r),a=MB("keys",e,t,n),i=MB("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=MB("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=LB(e.op);if(a&&a.customExecutor)return a.customExecutor(new TU(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Yb(a)?a.then((e=>[].concat(e))):[].concat(a)}class MU{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function PU(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>VB(e)[0])));r=r||[];const c=new Set(r.map((e=>VB(e.name)[0]))),h=[...t];for(;h.length>0;){const e=h.pop();(jU(e)||GU(e)||HU(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),h.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function zU(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>VB(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),h={};for(const m of u){h[m.name]=h[m.name]||0;for(const e of m.children)i(e)||(h[e.name]=Number.POSITIVE_INFINITY),h[e.name]=(h[e.name]||0)+1}const d=Object.entries(h).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...d];for(;d.length>0;){const e=d.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--h[n.name]&&(p.push(n.name),d.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const a of t.children)n.has(a.name)&&!s.has(a.name)&&(s.add(a.name),r.push(a.name))}const a=e.filter((e=>s.has(e.name)));return a}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"===typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new BU(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new BU(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new BU(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new BU(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class BU extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const UU=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),VU=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),WU=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function jU(e){return UU.has(e.op)}function GU(e){return VU.has(e.op)}function HU(e){return WU.has(e.op)}class qU{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new qU(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=PU(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=zU(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>jU(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=a[o];if(t===n)continue;const r=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return XS(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[VB(e)[0]])),s=t.map((e=>VB(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=ev().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t5){this.keepIntermediateTensors=!1,console.warn(t5.message)}const u={},c={};return qS((()=>{const n=new MU(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=VB(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=LU(e,r,n,this._resourceManager);if(Yb(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>PB(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!jU(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(jU(e))continue;const t=zB(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return jU(e)||s.has(e.name)}if(!jU(e)&&null!=a)for(const o of a){if(i(o))continue;const e=zB(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ev().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(t5){this.keepIntermediateTensors=!1,console.warn(t5.message)}const a=new MU(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>PB(e,i,a))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[VB(e)[0]])),i=n.map((e=>VB(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:h,syncInputs:d}=PU(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=VB(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(a,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((e=>!jU(e)&&!PB(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&MB("isConstant",e.node,r,n)&&([c]=BB(e.node.name,n)),null==r[e.node.name]){const h=LU(e.node,r,n,this._resourceManager);c||([c]=BB(e.node.name,n));const d=n.currentContext;Yb(h)?u.push(h.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u)))):(r[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=BB(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!PB(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!PB(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=VB(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;wb(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&wb(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=VB(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=VB(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class KU{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const XU="?tfjs-format=file",YU="model.json";class QU{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,null==n&&(this.loadOptions={}),this.resourceManager=new KU}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Yb(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await aI(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new qU(cU.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=cU.Instance.transformGraph(e.modelInitializer);this.initializer=new qU(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof iS?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof iS)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&KS(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function JU(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}${YU}${XU}`}(e));const s=new QU(e,n,r);return await s.load(),s}function ZU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(rV(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=ZU(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function eV(e){return tV(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:nV)}function tV(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(rV(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=e.map((e=>e[a])),i=tV(r,t,n);s[a]=i}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function nV(e){return null===e?null:rV(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function rV(e){let t=!1;if(ev().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof iS)&&!(e instanceof Promise)&&!t)}function sV(e){return function(e,t){return ZU(e,t)}(e,aV)}function aV(e){return e instanceof iS?{value:e.clone(),recurse:!1}:rV(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class iV{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class oV extends iV{constructor(){super(oV.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function lV(e){return new dV(e)}function uV(e,t){return new SV(e,t)}oV.INITIAL_CAPACITY=32;class cV{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new vV(this,e)}filter(e){return new yV(this,e)}map(e){return new bV(this,e)}mapAsync(e){return new wV(this,e)}serialMapAsync(e){return new wV(this,e).serial()}flatmap(e){return new kV(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new gV(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:nV;return this.rowMajorBatch(e,t).map((e=>eV(e,n)))}concatenate(e,t){return new SV(new hV([this,e]),t)}take(e){return e<0||null==e?this:new mV(this,e)}skip(e){return e<0||null==e?this:new fV(this,e)}prefetch(e){return new TV(this,e)}shuffle(e,t){return new NV(this,e,t)}serial(){return new pV(this)}}class hV extends cV{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:sV(e),done:!1}}}class dV extends cV{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t5){throw t5.message=`Error thrown while iterating through a dataset: ${t5.message}`,t5}}}class pV extends cV{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class fV extends cV{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;KS(e.value)}return this.upstream.next()}}class mV extends cV{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class gV extends cV{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class yV extends cV{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;KS(e.value)}}}class bV extends cV{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=xS(e.value),n=this.transform(e.value),r=xS(n);for(const s of t)wS(s,r)||s.dispose();return{value:n,done:!1}}}class vV extends cV{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t5){if(!this.handler(t5))return{value:null,done:!0}}}}class wV extends cV{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=xS(e.value),n=await this.transform(e.value),r=xS(n);for(const s of t)wS(s,r)||s.dispose();return{value:n,done:!1}}}class xV extends cV{constructor(){super(),this.outputQueue=new oV,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class kV extends xV{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=xS(e.value),n=this.transform(e.value),r=xS(n);this.outputQueue.pushAll(n);for(const s of t)wS(s,r)||s.dispose();return!0}}class SV extends cV{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var IV;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(IV||(IV={}));class TV extends cV{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new iV(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class NV extends TV{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=p_.alea(n||Wk().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class EV{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return wb(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),CV((async()=>(await n.iterator()).columnMajorBatch(e,t,_V)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,CV((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,CV((async()=>(await t.iterator()).filter((t=>qS((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return CV((async()=>(await t.iterator()).map((t=>qS((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return CV((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return CV((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,CV((async()=>uV(lV((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,CV((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=p_.alea(t||Wk().toString());return CV((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,CV((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function CV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends EV{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function _V(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof iS||Hk(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof iS?J_(e):VS(e)}(e),recurse:!1}}return{value:null,recurse:!0}}EV.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function AV(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&wb("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const RV=bA;class $V extends fb{nextDataId(){return $V.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new pb(this,GS())}write(e,t,n){this.firstUse&&(this.firstUse=!1,ev().get("IS_NODE")&&gk("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Lb(n[0])){const s=n.map((e=>jk(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return y$(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Gk(e)));return eT(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return eT(e.shape,e.dtype,t)}makeOutput(e,t,n){return GS().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Wk();e();return{kernelMs:Wk()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){AV([e],"where");const t=this.readSync(e.dataId);return RV(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}$V.nextDataId=0;function OV(e){return(t,n,r)=>{const s=Ob(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function DV(e,t,n){return FV(e,OV(t),n)}function FV(e,t,n){return r=>{let{inputs:s,attrs:a,backend:i}=r;const{x:o}=s;AV(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=Q$(u)}else c=u;const h=n||o.dtype,d=t(c,h,a);return l.makeTensorInfo(o.shape,h,d)}}YS("cpu",(()=>new $V),1);const LV=DV(rw,(e=>e>=0?e:Math.exp(e)-1)),MV={kernelName:rw,backendName:"cpu",kernelFunc:LV};function PV(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const zV={kernelName:ww,backendName:"cpu",kernelFunc:PV};function BV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;AV([s],"leakyRelu");const i=Sb(s.shape),o=n.data.get(s.dataId).values,l=$b("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const UV={kernelName:Nw,backendName:"cpu",kernelFunc:BV};function VV(e){return(t,n,r,s,a)=>{const i=CT(t,n),o=i.length,l=Ub(i),u=$b(a,Sb(i)),c=t.length,h=n.length,d=Ub(t),p=Ub(n),f=NT(t,i),m=NT(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<u.length;++g){const t=Xb(g,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const a=Kb(n,c,d),i=t.slice(-h);m.forEach((e=>i[e]=0));const y=Kb(i,h,p);u[g]=e(r[a],s[y])}return[u,i]}}const WV=VV(((e,t)=>e<0?t*e:e));function jV(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;AV([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=WV(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const GV={kernelName:ox,backendName:"cpu",kernelFunc:jV},HV=DV(mx,(e=>Math.max(0,e))),qV={kernelName:mx,backendName:"cpu",kernelFunc:HV},KV=DV(xx,(e=>Math.min(Math.max(0,e),6))),XV={kernelName:xx,backendName:"cpu",kernelFunc:KV},YV=OV((e=>1/(1+Math.exp(-e)))),QV=DV(Dx,(e=>1/(1+Math.exp(-e)))),JV={kernelName:Dx,backendName:"cpu",kernelFunc:QV};function ZV(e,t,n,r,s){if("linear"===n)return PV({inputs:{x:t},backend:e});if("relu"===n)return HV({inputs:{x:t},backend:e});if("elu"===n)return LV({inputs:{x:t},backend:e});if("relu6"===n)return KV({inputs:{x:t},backend:e});if("prelu"===n)return jV({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return BV({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return QV({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function eW(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const tW={kernelName:Rv,backendName:"cpu",kernelFunc:eW};function nW(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return eW({inputs:{real:nW(e,t,"float32"),imag:nW(e,t,"float32")},backend:e})}const r=Gb(Sb(t),n);return e.makeTensorInfo(t,n,r)}function rW(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const sW={kernelName:px,backendName:"cpu",kernelFunc:rW};function aW(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=Vk([0],n),[s,a]=VV(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function iW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return PV({inputs:{x:s},backend:n});const e=nW(n,s.shape,s.dtype),t=iW({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=eW({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=rW({inputs:{input:s},backend:n}),t=iW({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Db(s.dtype,a)){const e=PV({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=aW(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const oW={kernelName:Cv,backendName:"cpu",kernelFunc:iW};function lW(e,t,n,r){return null==n?n=>{let{inputs:s,backend:a}=n;const{a:i,b:o}=s,l=a;AV([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h="string"===i.dtype?Q$(u):u,d="string"===i.dtype?Q$(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:s,backend:a}=e;const{a:i,b:o}=s,l=a;if("complex64"===i.dtype||"complex64"===o.dtype){const e=iW({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,a=l.data.get(r.dataId).values,u=l.data.get(s.dataId).values,c=iW({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,a,u,f,m),v=l.makeTensorInfo(b,"float32",g),w=l.makeTensorInfo(b,"float32",y),x=eW({inputs:{real:v,imag:w},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(w),x}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,s=r||i.dtype,[a,u]=t(i.shape,o.shape,e,n,s);return l.makeTensorInfo(u,s,a)}}}function uW(e){return(t,n,r,s,a,i)=>{const o=CT(t,n),l=Sb(o),u=o.length,c=Ub(o),h=$b("float32",l),d=$b("float32",l),p=NT(t,o),f=NT(n,o),m=y$(r,s),g=y$(a,i),y=t.length,b=Ub(t),v=n.length,w=Ub(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){const t=x%m.length,n=x%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[x]=r.real,d[x]=r.imag}else for(let x=0;x<h.length;x++){const t=Xb(x,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=Kb(n,y,b),s=t.slice(-v);f.forEach((e=>s[e]=0));const a=Kb(s,v,w),i=e(m[2*r],m[2*r+1],g[2*a],g[2*a+1]);h[x]=i.real,d[x]=i.imag}return[h,d,o]}}const cW=VV(((e,t)=>e+t)),hW=uW(((e,t,n,r)=>({real:e+n,imag:t+r}))),dW=lW(lv,cW,hW),pW={kernelName:lv,backendName:"cpu",kernelFunc:dW};function fW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Sb(s.shape),o=_b(a,i),l=Sb(o);wb(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const mW={kernelName:gx,backendName:"cpu",kernelFunc:fW};function gW(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;AV([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],h=o?a.shape[u-1]:a.shape[u-2],d=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Sb(f),y=Sb(m),b=CT(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,p]);wb(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,h]:[y,h,p],w=fW({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,d]:[g,d,c]}}),x=fW({inputs:{x:a},backend:n,attrs:{shape:v}}),k=i?w.shape[1]:w.shape[2],S=i?w.shape[2]:w.shape[1],I=o?x.shape[1]:x.shape[2],T=Math.max(g,y),N=n.data.get(w.dataId).values,E=n.data.get(x.dataId).values,C=Ub(w.shape),_=Ub(x.shape),[A,R,$]=i?[C[0],1,C[1]]:[C[0],C[1],1],[O,D,F]=o?[1,_[1],_[0]]:[_[1],1,_[0]],L=S*I,M=eT([T,S,I],w.dtype),P=M.values,z=n.blockSize;for(let B=0;B<T;B++){const e=B%g,t=B%y;for(let n=0;n<S;n+=z){const r=Math.min(n+z,S);for(let s=0;s<I;s+=z){const a=Math.min(s+z,I);for(let i=0;i<k;i+=z){const o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=s;n<a;n++){let r=0;for(let s=i;s<o;s++){r+=N[e*A+l*R+s*$]*E[s*O+n*D+t*F]}P[B*L+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(b,M.dtype,M.values)}const yW={kernelName:Sv,backendName:"cpu",kernelFunc:gW};const bW={kernelName:pk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=gW({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=dW({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),c&&(f=ZV(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function vW(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const wW={kernelName:av,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;AV(t,"abs");let r=new Float32Array(Sb(t.shape));return r=vW(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},xW=DV(iv,(e=>Math.acos(e))),kW={kernelName:iv,backendName:"cpu",kernelFunc:xW},SW=DV(ov,(e=>Math.acosh(e))),IW={kernelName:ov,backendName:"cpu",kernelFunc:SW};const TW={kernelName:uv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;AV(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=eT(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function NW(e,t,n,r,s){const a=t.length,i=Sb(t),o=Ub(t),l=Ub(s),u=$b(n,Sb(s));for(let c=0;c<i;++c){const t=Xb(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[Kb(n,a,l)]=e[c]}return u}function EW(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;AV(s,"transpose");const i=s.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=s.shape[a[u]];const l=NW(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const CW={kernelName:ak,backendName:"cpu",kernelFunc:EW};const _W={kernelName:cv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;AV(s,"all");const o=Ab(a,s.shape);let l=o;const u=YE(l,s.shape.length);let c=s;null!=u&&(c=EW({inputs:{x:s},backend:n,attrs:{perm:u}}),l=JE(l.length,s.shape.length)),XE("all",l,c.shape.length);const[h,d]=qE(c.shape,l),p=Sb(d),f=Gb(Sb(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=fW({inputs:{x:g},backend:n,attrs:{shape:KE(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const AW={kernelName:hv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;AV(s,"any");const o=Ab(a,s.shape);let l=o;const u=YE(l,s.shape.length);let c=s;null!=u&&(c=EW({inputs:{x:s},backend:n,attrs:{perm:u}}),l=JE(l.length,s.shape.length)),XE("any",l,c.shape.length);const[h,d]=qE(c.shape,l),p=Sb(d),f=Gb(Sb(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=fW({inputs:{x:g},backend:n,attrs:{shape:KE(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const RW={kernelName:dv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;AV(s,"argMax");let i=Ab(a,s.shape);const o=YE(i,s.shape.length);let l=s;const u=[];null!=o&&(l=EW({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=JE(i.length,l.shape.length)),i=[i[0]],XE("argMax",i,l.shape.length);const[c,h]=qE(l.shape,i),d=Gb(Sb(c),"int32"),p=Sb(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s>t&&(t=s,n=r)}d[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}};const $W={kernelName:pv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;AV(s,"argMin");let i=Ab(a,s.shape);const o=YE(i,s.shape.length);let l=s;const u=[];null!=o&&(l=EW({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=JE(i.length,l.shape.length)),i=[i[0]],XE("argMin",i,l.shape.length);const[c,h]=qE(l.shape,i),d=Gb(Sb(c),"int32"),p=Sb(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s<t&&(t=s,n=r)}d[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}},OW=DV(fv,(e=>Math.asin(e))),DW={kernelName:fv,backendName:"cpu",kernelFunc:OW},FW=DV(mv,(e=>Math.asinh(e))),LW={kernelName:mv,backendName:"cpu",kernelFunc:FW},MW=DV(gv,(e=>Math.atan(e))),PW={kernelName:gv,backendName:"cpu",kernelFunc:MW},zW=VV(((e,t)=>Math.atan2(e,t))),BW=lW(bv,zW),UW={kernelName:bv,backendName:"cpu",kernelFunc:BW},VW=DV(yv,(e=>Math.atanh(e))),WW={kernelName:yv,backendName:"cpu",kernelFunc:VW};function jW(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=eT(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let w=0;w<s.batchSize;++w){const t=w*y,n=w*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const w=y*i-d,x=Math.max(0,w),k=Math.min(s.inHeight,c+w),S=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-p,c=Math.max(0,i),d=Math.min(s.inWidth,h+i);let y=f,b=0,w=0;for(let t=x;t<k;t+=l){const s=n+t*r[1];for(let t=c;t<d;t+=u){const n=e[s+t*r[2]+m];"max"===a&&n>y?y=n:"avg"===a&&(b+=n,w++)}if(isNaN(y))break}g[S+t*v+m]="avg"===a?b/w:y}}}return m}function GW(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=eT(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=eT(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,h+n);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(r.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,x=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<v;n+=c){const o=n-h,l=m.get(g,t,n,e);l>w&&(w=l,x=s?a?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+o)}}i.set(x,g,t,o,e)}}return i}function HW(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=eT(s.outShape,n),w=v.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let T=0;T<s.batchSize;++T){const t=T*x,n=T*r[0];for(let v=0;v<s.inChannels;++v)for(let x=0;x<s.outDepth;++x){const T=x*i-m;let N=T;for(;N<0;)N+=u;const E=Math.min(s.inDepth,d+T),C=t+x*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let d=i;for(;d<0;)d+=c;const m=Math.min(s.inHeight,p+i),x=C+t*S;for(let t=0;t<s.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),g=x+t*I;let k=b,S=0,T=0;for(let t=N;t<E;t+=u){const s=n+t*r[1];for(let t=d;t<m;t+=c){const n=s+t*r[2];for(let t=o;t<p;t+=h){const s=e[n+t*r[3]+v];if("max"===a&&s>k?k=s:"avg"===a&&(S+=s,T++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[g+v]="avg"===a?S/Math.max(T,1):k}}}}return v}const qW={kernelName:vv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;AV(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;wb(qN(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=MN(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Ib(u.inShape,u.outShape))c=PV({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Ub(s.shape),r=jW(e,s.shape,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const KW={kernelName:xv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;AV(s,"avgPool3d");const c=PN(s.shape,a,i,1,o,l,u),h=HW(n.data.get(s.dataId).values,s.shape,s.dtype,Ub(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const XW={kernelName:kv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;AV([s,a],"avgPool3DGrad");const c=PN(a.shape,i,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=w-1-c.padInfo.front,I=k-1-c.padInfo.left,T=x-1-c.padInfo.top,N=eT(a.shape,"float32"),E=1/(f*m*g),C=n.bufferSync(s);for(let _=0;_<c.batchSize;++_)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-S,a=n-T,i=r-I;let o=0;for(let t=0;t<w;t+=y){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<x;t+=b){const r=(a+t)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const s=(i+t)/p;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;o+=C.get(_,n,r,s,e)}}}N.set(o*E,_,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const YW={kernelName:wv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;AV([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=MN(i.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,w=y-1-c.padInfo.top,x=eT(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,I=eT(s.shape,"float32",S);for(let T=0;T<c.batchSize;++T)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-w,s=n-v;let a=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(s+t)/d;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;a+=I.get(T,n,r,e)}}x.set(a*k,T,t,n,e)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const QW={kernelName:mw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;wb(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),wb(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),wb(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),AV([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=d.length,v=h.length;let w=0,x=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[w++]+(c[I]-h[x++])*p[k++]/Math.sqrt(d[S++]+u),w>=g&&(w=0),x>=v&&(x=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function JW(e,t,n,r,s){const a=vN(r,t,n),i=Sb(n),o=Ub(r);if(a){const n=wN(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=eT(r,s,"string"===s?Q$(e):e),u=eT(n,s);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===s?J$(u.values):u.values}function ZW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;AV(s,"slice");const[o,l]=xN(s,a,i);oN(s,o,l);const u=JW(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const ej={kernelName:Ax,backendName:"cpu",kernelFunc:ZW};const tj={kernelName:Iv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;AV([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),l=r$(s.shape,a,o),u=s$(l.length,a.length),c=a$(s.shape,a,o),h=i$(i,a.length),d=o$(c,i,a.length),p=fW({inputs:{x:s},backend:n,attrs:{shape:l}}),f=EW({inputs:{x:p},backend:n,attrs:{perm:u}}),m=fW({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ZW({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function nj(e,t,n,r,s){const a=Sb(r),i=Gb(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=a>0?t[o]:1)}return i}function rj(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e.shape[0],a=e.shape[1],i=eT([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const sj={kernelName:Tv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=nj(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},aj=VV(((e,t)=>e&t)),ij=lW(Nv,aj),oj={kernelName:Nv,backendName:"cpu",kernelFunc:ij};const lj={kernelName:Ev,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=CT(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},uj=OV((e=>Math.ceil(e))),cj=FV(_v,uj),hj={kernelName:_v,backendName:"cpu",kernelFunc:cj},dj=DV(Av,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),pj={kernelName:Av,backendName:"cpu",kernelFunc:dj},fj={kernelName:$v,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Sb(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function mj(e,t,n,r){const s=Ob(n,Sb(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Sb(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?Q$(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}function gj(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const yj={kernelName:kw,backendName:"cpu",kernelFunc:gj};function bj(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Ab(s,t[0].shape)[0];qR(t.map((e=>e.shape)),a);let i=KR(t.map((e=>e.shape)),a);if(0===Sb(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Sb(e.shape)>0));if(1===o.length)return PV({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>rW({inputs:{input:e},backend:n}))),t=o.map((e=>gj({inputs:{input:e},backend:n}))),r=bj({inputs:e,backend:n,attrs:{axis:a}}),s=bj({inputs:t,backend:n,attrs:{axis:a}}),i=eW({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map((e=>{const t=Sb(e.shape.slice(a));return fW({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=KR(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],h=mj(u,i,t[0].dtype,c),d=KR(o.map((e=>e.shape)),a),p=n.makeTensorInfo(d,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const vj={kernelName:Ov,backendName:"cpu",kernelFunc:bj};function wj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;AV([s,a],"conv2d");const h=XN(l),d=zN(s.shape,a.shape,i,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new nS(d.outShape,s.dtype),x=Ub(s.shape),k=Ub(a.shape),S=x[0],I=v?x[1]:x[2],T=v?x[2]:1,N=v?1:x[1],E=w.strides[0],C=v?w.strides[1]:w.strides[2],_=v?w.strides[2]:1,A=v?1:w.strides[1],R=n.data.get(s.dataId).values,$=n.data.get(a.dataId).values,O=w.values;for(let D=0;D<d.batchSize;++D){const e=D*S,t=D*E;for(let n=0;n<d.outHeight;++n){const r=t+n*C,s=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const a=t*k[0],i=e+n*I;for(let e=0;e<d.outWidth;++e){const t=r+e*_,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const s=i+r*T;let o=a+e*k[1];for(let e=0;e<d.inChannels;++e){const n=R[s+e*N];for(let e=0;e<d.outChannels;++e)O[t+e*A]+=n*$[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,O)}const xj={kernelName:Dv,backendName:"cpu",kernelFunc:wj};const kj={kernelName:Fv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;AV([s,a],"conv2dBackpropFilter");const h=XN(l),d=zN(s.shape,c,i,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new nS(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,x=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new nS(s.shape,s.dtype,x),I=new nS(a.shape,a.dtype,k);for(let T=0;T<m;++T){const e=Math.max(0,Math.ceil((w-T)/p)),t=Math.min(d.outHeight,(d.inHeight+w-T)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),s=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let a=0;a<d.inChannels;++a)for(let i=0;i<d.outChannels;++i){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){const e=T+u*p-w;for(let t=r;t<s;++t){const r=n+t*f-v;o+=y?S.get(l,e,r,a)*I.get(l,u,t,i):S.get(l,a,e,r)*I.get(l,i,u,t)}}b.set(o,T,n,a,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const Sj={kernelName:Lv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;AV([s,a],"conv2dBackpropInput");const h=Ub(a.shape),d=Ub(s.shape);let p=XN(u);const f=zN(i,a.shape,o,1,l,c,!1,p),m=new nS(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[v,w,x]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:T,inHeight:N,inWidth:E,outChannels:C,outHeight:_,outWidth:A,strideHeight:R,strideWidth:$}=f;p=f.dataFormat;const O=S-1-f.padInfo.top,D=I-1-f.padInfo.left,F="channelsLast"===p,L=m.strides[0],M=F?m.strides[1]:m.strides[2],P=F?m.strides[2]:1,z=F?1:m.strides[1],B=d[0],U=F?d[1]:d[2],V=F?d[2]:1,W=F?1:d[1];for(let j=0;j<k;++j)for(let e=0;e<T;++e)for(let t=0;t<N;++t){const n=t-O,r=Math.max(0,Math.ceil(n/R)),s=Math.min(_,(S+n)/R);for(let a=0;a<E;++a){const i=a-D,o=Math.max(0,Math.ceil(i/$)),l=Math.min(A,(I+i)/$);let u=0;for(let t=r;t<s;++t){const r=t*R-n;for(let n=o;n<l;++n){const s=B*j+U*t+V*n,a=v*(S-1-r)+w*(I-1-(n*$-i))+x*e;for(let e=0;e<C;++e){u+=y[s+W*e]*b[a+e]}}}g[L*j+M*t+P*a+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const Ij={kernelName:Mv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;AV([s,a],"conv3d");const u=BN(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,w=new nS(u.outShape,s.dtype),x=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=w.values,I=Ub(s.shape),T=Ub(a.shape);for(let N=0;N<u.batchSize;++N){const e=N*I[0],t=N*w.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*w.strides[1],s=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=u.inDepth)continue;const a=t*T[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*w.strides[2],n=e*u.strideHeight-v;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*T[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const a=s+e*T[2],i=o+t*u.inChannels;let l=a;for(let e=0;e<u.inChannels;++e){const t=x[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const Tj={kernelName:Pv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;AV([s,a],"conv3dBackpropFilterV2");const u=Ub(s.shape),c=Ub(a.shape),h=BN(s.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new nS(h.filterShape,"float32"),v=b.values,[w,x,k,S]=b.strides,I=n.data.get(a.dataId).values,[T,N,E,C]=c,_=n.data.get(s.dataId).values,[A,R,$,O]=u,D=h.padInfo.front,F=h.padInfo.left,L=h.padInfo.top;for(let M=0;M<m;++M){const e=Math.max(0,Math.ceil((D-M)/d)),t=Math.min(h.outDepth,(h.inDepth+D-M)/d),n=M*w;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((L-r)/p)),a=Math.min(h.outHeight,(h.inHeight+L-r)/p),i=r*x+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(h.outWidth,(h.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<h.inChannels;++i){const c=i*S+u;for(let u=0;u<h.outChannels;++u){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*A,g=c*T;for(let c=e;c<t;++c){const e=(M+c*d-D)*R+h,t=c*N+g;for(let c=s;c<a;++c){const s=(r+c*p-L)*$+e,a=c*E+t;for(let e=o;e<l;++e){const t=e*C+a;m+=_[(n+e*f-F)*O+s+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const Nj={kernelName:zv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;AV([s],"conv3dBackpropInputV2");const u=Ub(s.shape),c=Ub(a.shape),h=BN(l,a.shape,o,1,i),d=new nS(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(s.dataId).values,[v,w,x,k]=u,S=n.data.get(a.dataId).values,[I,T,N,E]=c,{batchSize:C,filterDepth:_,filterHeight:A,filterWidth:R,inChannels:$,inDepth:O,inHeight:D,inWidth:F,outChannels:L,outDepth:M,outHeight:P,outWidth:z,strideDepth:B,strideHeight:U,strideWidth:V}=h,W=_-1-h.padInfo.front,j=A-1-h.padInfo.top,G=R-1-h.padInfo.left;for(let H=0;H<C;++H)for(let e=0;e<$;++e)for(let t=0;t<O;++t){const n=t-W,r=Math.max(0,Math.ceil(n/B)),s=Math.min(M,(_+n)/B);for(let a=0;a<D;++a){const i=a-j,o=Math.max(0,Math.ceil(i/U)),l=Math.min(P,(A+i)/U);for(let u=0;u<F;++u){const c=u-G,h=Math.max(0,Math.ceil(c/V)),d=Math.min(z,(R+c)/V);let C=0;for(let t=r;t<s;++t){const r=t*B-n;for(let n=o;n<l;++n){const s=n*U-i;for(let a=h;a<d;++a){const i=v*H+w*t+x*n+k*a,o=I*(_-1-r)+T*(A-1-s)+N*(R-1-(a*V-c))+E*e;for(let e=0;e<L;++e){C+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*a+y*u+e]=C}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},Ej=DV(Bv,(e=>Math.cos(e))),Cj={kernelName:Bv,backendName:"cpu",kernelFunc:Ej},_j=DV(Uv,(e=>Math.cosh(e))),Aj={kernelName:Uv,backendName:"cpu",kernelFunc:_j};const Rj={kernelName:jv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,f=a.shape[0],[m,g]=o,y=eT([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,x=Ub(s.shape),k=Ub(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],s=b[e+3],a=v[S];if(a>=c)continue;const i=m>1?(r-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(h-1)+c*i:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(l<0||l>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const h=Math.floor(l),f=Math.ceil(l),m=l-h;for(let n=0;n<p;n++){let s=n+h*x[2]+t*x[1]+a*x[0];const o=w[s];s=n+f*x[2]+t*x[1]+a*x[0];const l=w[s];s=n+h*x[2]+r*x[1]+a*x[0];const u=w[s];s=n+f*x[2]+r*x[1]+a*x[0];const d=o+(l-o)*m,p=u+(w[s]-u)*m;s=n+e*k[2]+c*k[1]+S*k[0],y.values[s]=d+(p-d)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(r<0||r>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*x[2]+l*x[1]+a*x[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=w[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const $j={kernelName:Vv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;AV(s,"cumprod");const l=YE([a],s.shape.length);let u=s;null!=l&&(u=EW({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=JE(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=mS(u.dtype,"int32"),d=jb(Sb(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?1:p[t];else{const n=m(y,e-1);d[t]=i?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=EW({inputs:{x:g},backend:n,attrs:{perm:QE(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const Oj={kernelName:Wv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;AV(s,"cumsum");const l=YE([a],s.shape.length);let u=s;null!=l&&(u=EW({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=JE(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=mS(u.dtype,"int32"),d=Gb(Sb(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?0:p[t];else{const n=m(y,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=EW({inputs:{x:g},backend:n,attrs:{perm:QE(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const Dj={kernelName:Gv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=nj(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=rj(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};const Fj={kernelName:Hv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;wb("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*a,d=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<h;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const r=Math.floor(e/a),s=(n*a+e%a)*p;for(let e=0;e<p;++e){const n=e+s+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function Lj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;AV([s,a],"depthwiseConv2DNative");const c=Ub(s.shape),h=Ub(a.shape);let d=l;null==d&&(d=[1,1]),wb(qN(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));const p=zN(s.shape,a.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,w=b.top,x=p.outChannels/p.inChannels,k=new nS(p.outShape,s.dtype),S=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,T=k.values;for(let N=0;N<p.batchSize;++N){const e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],s=n*p.strideHeight-w;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const a=t*h[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const s=a+e*h[1],o=i+r*p.inChannels;let l=t,u=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<x;++e)T[l+e]+=t*I[u+e];l+=x,u+=x}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const Mj={kernelName:qv,backendName:"cpu",kernelFunc:Lj};const Pj={kernelName:Kv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;AV([s,a],"depthwiseConv2dNativeBackpropFilter");const h=zN(s.shape,c,i,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new nS(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(s.dataId).values,x=new nS(s.shape,s.dtype,w),k=n.data.get(a.dataId).values,S=new nS(a.shape,a.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((b-I)/d)),t=Math.min(h.outHeight,(h.inHeight+b-I)/d);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),s=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let a=0;a<h.outChannels;++a){const i=Math.trunc(a/v),o=a%v;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*d-b;for(let t=r;t<s;++t){const r=n+t*p-y;l+=x.get(u,e,r,i)*S.get(u,o,t,a)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const zj={kernelName:Xv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;AV([s,a],"depthwiseConv2DNativeBackpropInput");const h=Ub(s.shape),d=Ub(a.shape),p=zN(c,a.shape,i,o,l,u,!0),f=new nS(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(s.dataId).values,[w,x,k]=h,S=n.data.get(a.dataId).values,[I,T,N]=d,{batchSize:E,filterHeight:C,filterWidth:_,inChannels:A,inHeight:R,inWidth:$,outChannels:O,outHeight:D,outWidth:F,strideHeight:L,strideWidth:M}=p,P=C-1-p.padInfo.top,z=_-1-p.padInfo.left,B=O/A;for(let U=0;U<E;++U)for(let e=0;e<A;++e)for(let t=0;t<R;++t){const n=t-P,r=Math.max(0,Math.ceil(n/L)),s=Math.min(D,(C+n)/L);for(let a=0;a<$;++a){const i=a-z,o=Math.max(0,Math.ceil(i/M)),l=Math.min(F,(_+i)/M);let u=0;for(let t=r;t<s;++t){const r=t*L-n;for(let n=o;n<l;++n){const s=w*U+x*t+k*n,a=I*(C-1-r)+T*(_-1-(n*M-i))+N*e;for(let t=0;t<B;++t){u+=v[s+(e*B+t)]*S[a+t]}}}m[g*U+y*t+b*a+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const Bj={kernelName:Yv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Sb(r.shape),a=n.data.get(r.dataId).values,i=eT([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},Uj={kernelName:Qv,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(s.dataId).values,h=s.shape.length,d=u.data.get(a.dataId).values,p=a.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:w,strideHeight:x,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:T,dilationWidth:N,outShape:E}=LN(s.shape,a.shape,i,o,"NHWC",l),C=Sb(E),_=E.length,A=Ob(s.dtype,C);for(let R=0;R<f;++R)for(let e=0;e<b;++e){const t=e*x-w.top;for(let n=0;n<v;++n){const r=n*k-w.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*T;if(n>=0&&n<m)for(let t=0;t<I;++t){const l=r+t*N;if(l>=0&&l<g){const r=Kb([R,n,l,i],h,Ub(s.shape)),u=Kb([e,t,i],p,Ub(a.shape)),f=c[r]+d[u];f>o&&(o=f)}}}A[Kb([R,e,n,i],_,Ub(E))]=o}}}return{dataId:u.write(Vk(A,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}},Vj={kernelName:Zv,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,h=Wb(s.shape,c.data.get(s.dataId).values),d=Wb(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:T,outShape:N}=LN(s.shape,a.shape,o,l,"NHWC",u);wb(i.rank===N.length,(()=>`Error in ${Zv}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const E=Wb(N,c.data.get(i.dataId).values),C=Hb(a.shape,a.dtype);for(let _=0;_<p;++_)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<b;++n){const r=n*x-v.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*T;if(l>=0&&l<m){const r=h[_][n][l][s]+d[e][t][s];r>a&&(a=r,i=e,o=t)}}}C[i][o][s]+=E[_][e][n][s]}}}return{dataId:c.write(Vk(C,s.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Wj={kernelName:Jv,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,h=Wb(s.shape,c.data.get(s.dataId).values),d=Wb(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:T,outShape:N}=LN(s.shape,a.shape,o,l,"NHWC",u);wb(i.rank===N.length,(()=>`Error in ${Jv}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const E=Wb(N,c.data.get(i.dataId).values),C=Hb(s.shape,s.dtype);for(let _=0;_<p;++_)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<b;++n){const r=n*x-v.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*T;if(l>=0&&l<m){const r=h[_][n][l][s]+d[e][t][s];r>a&&(a=r,i=n,o=l)}}}C[_][i][o][s]+=E[_][e][n][s]}}}return{dataId:c.write(Vk(C,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const jj={kernelName:ew,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=a.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===s.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}a.width=p,a.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),s}},Gj=VV(((e,t)=>e*t)),Hj=uW(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),qj=lW(Yw,Gj,Hj),Kj={kernelName:Yw,backendName:"cpu",kernelFunc:qj};function Xj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;AV(s,"sum"),o="bool"===s.dtype?iW({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):PV({inputs:{x:s},backend:n});const l=o.shape.length,u=Ab(a,o.shape),c=YE(u,l);let h=u,d=o;null!=c&&(d=EW({inputs:{x:o},backend:n,attrs:{perm:c}}),h=JE(h.length,l)),XE("sum",h,d.shape.length);const[p,f]=qE(d.shape,h);let m=nW(n,p,mS(d.dtype,"int32"));const g=Sb(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=fW({inputs:{x:m},backend:n,attrs:{shape:KE(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const Yj={kernelName:Mx,backendName:"cpu",kernelFunc:Xj};const Qj={kernelName:nw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=_$(s,a.length);R$(i.length,l,a);const{path:u,steps:c}=$$(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=A$(p,l[e]);let s;O$(t)?s=a[e]:(s=EW({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Ib(s.shape,i)||(s=fW({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=qj({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=Xj({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const Jj={kernelName:sw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;AV([r,s],"eluGrad");const a=new Float32Array(Sb(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];a[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(s.shape,"float32",a)}},Zj=VV(((e,t)=>e===t?1:0)),eG=lW(iw,Zj,null,"bool"),tG={kernelName:iw,backendName:"cpu",kernelFunc:eG},nG=h$,rG=d$,sG=p$,aG=f$,iG=m$,oG=g$,lG=DV(aw,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+nG*n);return t*(1-((((oG*r+iG)*r+aG)*r+sG)*r+rG)*r*Math.exp(-n*n))})),uG={kernelName:aw,backendName:"cpu",kernelFunc:lG},cG=OV((e=>Math.exp(e))),hG=FV(ow,cG,"float32"),dG={kernelName:ow,backendName:"cpu",kernelFunc:hG};function pG(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(wb(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),fW({inputs:{x:s},backend:n,attrs:{shape:o}})}const fG={kernelName:lw,backendName:"cpu",kernelFunc:pG},mG=OV((e=>Math.expm1(e))),gG=FV(uw,mG),yG={kernelName:uw,backendName:"cpu",kernelFunc:gG},bG=VV(((e,t)=>e/t)),vG=lW(tw,bG),wG={kernelName:tw,backendName:"cpu",kernelFunc:vG},xG=VV(((e,t)=>e-t)),kG=uW(((e,t,n,r)=>({real:e-n,imag:t-r}))),SG=lW(Zx,xG,kG),IG={kernelName:Zx,backendName:"cpu",kernelFunc:SG};function TG(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Sb(u),h=$b("float32",c),d=$b("float32",c);for(let g=0;g<s;g++){const e=ZW({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=ZW({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=eW({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=NG(s,t,n),c=y$(i,u);for(let t=0;t<a;t++){const e=x$(c,t);h[g*a+t]=e.real,d[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=eW({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function NG(e,t,n){const r=Sb(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0===((o=r)&o-1)){const s=EG(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",Uk(r,"float32")),i=PV({inputs:{x:a},backend:n}),l=wG.kernelFunc({inputs:{a:e,b:a},backend:n}),u=wG.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return s}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=I$(s*r,t,n),l=x$(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),k$(r,a,i,s)}return r}(y$(a,i),r,t);return b$(e)}var o}function EG(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=y$(e,t),i=n/2,o=v$(a),l=o.real,u=o.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=eW({inputs:{real:h,imag:d},backend:s}),f=w$(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),v=s.makeTensorInfo(y,"float32",g),w=eW({inputs:{real:b,imag:v},backend:s}),x=EG(l,u,i,r,s),k=x.real,S=x.imag,I=[k.length],T=s.makeTensorInfo(I,"float32",k),N=s.makeTensorInfo(I,"float32",S),E=eW({inputs:{real:T,imag:N},backend:s}),C=EG(m,g,i,r,s),_=C.real,A=C.imag,R=[_.length],$=s.makeTensorInfo(R,"float32",_),O=s.makeTensorInfo(R,"float32",A),D=eW({inputs:{real:$,imag:O},backend:s}),F=S$(n,r),L=[F.real.length],M=s.makeTensorInfo(L,"float32",F.real),P=s.makeTensorInfo(L,"float32",F.imag),z=eW({inputs:{real:M,imag:P},backend:s}),B=qj({inputs:{a:z,b:D},backend:s}),U=dW({inputs:{a:E,b:B},backend:s}),V=SG({inputs:{a:E,b:B},backend:s}),W=rW({inputs:{input:U},backend:s}),j=rW({inputs:{input:V},backend:s}),G=gj({inputs:{input:U},backend:s}),H=gj({inputs:{input:V},backend:s}),q=bj({inputs:[W,j],backend:s,attrs:{axis:0}}),K=bj({inputs:[G,H],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const CG={kernelName:cw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Sb(r.shape),a=r.shape[r.shape.length-1],i=fW({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=TG(i,!1,n),l=fW({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function _G(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Pb(s),o=Ob(i,Sb(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const AG={kernelName:hw,backendName:"cpu",kernelFunc:_G};const RG={kernelName:dw,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,a=r,i=$b(s.dtype,Sb(s.shape)),[o,l,u,c]=s.shape,h=a.data.get(s.dataId).values;for(let d=0;d<o;d++){const e=d*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let s=0;s<c;s++){const a=Math.round(u-t-1),o=e+n+r+s;let l=h[o];if(a>=0&&a<u){l=h[e+n+a*c+s]}i[o]=l}}}}return{dataId:a.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},$G=OV((e=>Math.floor(e))),OG=FV(pw,$G),DG={kernelName:pw,backendName:"cpu",kernelFunc:OG},FG=VV(((e,t)=>Math.floor(e/t))),LG=lW(fw,FG,null,"int32"),MG={kernelName:fw,backendName:"cpu",kernelFunc:LG};const PG={kernelName:fk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=wj({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=fW({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=dW({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=dW({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=fW({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=ZV(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=ZV(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const zG={kernelName:mk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=Lj({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=dW({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=ZV(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function BG(e,t,n,r,s,a,i,o,l){const u=eT([r,a],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[c*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=l/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)u.values[c*a+e]=t.get(...t.indexToLoc(r*a+e))}return u}const UG={kernelName:yw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Sb(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,h]=l$(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const d=BG(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,a);return n.makeTensorInfo(l,r.dtype,d.values)}};function VG(e,t,n){const r=eT(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),a=n[0],i=n[2],o=t.locToIndex([a,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}const WG={kernelName:gw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;AV([s,a],"gatherV2");const l=Ab(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let v=0;v<u.length;++v){const e=u[v];wb(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const d=Sb(a.shape),p=Y$(s,a,l,h),f=fW({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=fW({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=VG(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},jG=VV(((e,t)=>e>t?1:0)),GG=lW(bw,jG,null,"bool"),HG={kernelName:bw,backendName:"cpu",kernelFunc:GG},qG=VV(((e,t)=>e>=t?1:0)),KG=lW(vw,qG,null,"bool"),XG={kernelName:vw,backendName:"cpu",kernelFunc:KG};const YG={kernelName:xw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Sb(r.shape),a=r.shape[r.shape.length-1],i=fW({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=TG(i,!0,n),l=fW({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},QG=DV(Sw,(e=>Number.isFinite(e)?1:0),"bool"),JG={kernelName:Sw,backendName:"cpu",kernelFunc:QG},ZG=DV(Iw,(e=>Math.abs(e)===1/0?1:0),"bool"),eH={kernelName:Iw,backendName:"cpu",kernelFunc:ZG},tH=DV(Tw,(e=>Number.isNaN(e)?1:0),"bool"),nH={kernelName:Tw,backendName:"cpu",kernelFunc:tH},rH=VV(((e,t)=>e<t?1:0)),sH=lW(Ew,rH,null,"bool"),aH={kernelName:Ew,backendName:"cpu",kernelFunc:sH},iH=VV(((e,t)=>e<=t?1:0)),oH=lW(Cw,iH,null,"bool"),lH={kernelName:Cw,backendName:"cpu",kernelFunc:oH};function uH(e,t,n){const r=(t-e)/(n-1),s=Gb(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}const cH={kernelName:_w,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=uH(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},hH=OV((e=>Math.log(e))),dH=FV(Aw,hH),pH={kernelName:Aw,backendName:"cpu",kernelFunc:dH},fH=DV(Rw,(e=>Math.log1p(e))),mH={kernelName:Rw,backendName:"cpu",kernelFunc:fH},gH=VV(((e,t)=>e&&t)),yH=lW($w,gH,null,"bool"),bH={kernelName:$w,backendName:"cpu",kernelFunc:yH},vH=DV(Ow,(e=>e?0:1),"bool"),wH={kernelName:Ow,backendName:"cpu",kernelFunc:vH},xH=VV(((e,t)=>e||t)),kH=lW(Dw,xH,null,"bool"),SH={kernelName:Dw,backendName:"cpu",kernelFunc:kH};const IH={kernelName:Fw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;AV(s,"LRN");const u=s.shape[3],c=u-1,h=n.data.get(s.dataId).values,d=Sb(s.shape),p=new Float32Array(d);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}};const TH={kernelName:Lw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;AV(i,"LRNGrad");const h=Sb(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=u*r+l;for(let s=t;s<n;s++){let e=-2*u*c*f[s]*m[b]/r;b===s&&(e+=Math.pow(r,-c)),e*=p[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function NH(e,t,n,r){const s=$b(r,Sb(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}function EH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Ab(a,l);let h=c;const d=YE(h,u);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=NW(p,l,s.dtype,d,e),h=JE(h.length,u),l=e}AV(s,"max"),XE("max",h,u);const[f,m]=qE(l,h),g=NH(p,Sb(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=KE(f,c)}return{dataId:y,shape:b,dtype:s.dtype}}const CH={kernelName:Mw,backendName:"cpu",kernelFunc:EH},_H=VV(((e,t)=>Math.max(e,t))),AH=lW(Pw,_H),RH={kernelName:Pw,backendName:"cpu",kernelFunc:AH};const $H={kernelName:zw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;AV(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;wb(qN(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=MN(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Ib(u.inShape,u.outShape))c=PV({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Ub(s.shape),r=jW(e,s.shape,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const OH={kernelName:Uw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;AV(s,"maxPool3d");const c=PN(s.shape,a,i,1,o,l,u),h=HW(n.data.get(s.dataId).values,s.shape,s.dtype,Ub(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const DH={kernelName:Vw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;AV([s,a],"maxPool3DGrad");const c=PN(a.shape,i,o,1,l,u),h=function(e,t){const n=eT(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-d;let v=b;for(;v<0;)v+=i;const w=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=o;const x=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,T=-1;for(let t=v;t<w;t+=i){const n=t-b;for(let r=d;r<x;r+=o){const s=r-u;for(let a=k;a<S;a+=l){const i=a-p,o=e.get(m,t,r,a,g);o>=I&&(I=o,T=n*c*h+s*c+i)}}}n.set(T,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,x=b-1-c.padInfo.front,k=w-1-c.padInfo.left,S=v-1-c.padInfo.top,I=eT(a.shape,"float32"),T=n.bufferSync(s);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-x,a=n-S,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const s=(a+r)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<w;a+=y){const l=(i+a)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*w-1-h.get(N,n,s,l,e)===t*v*w+r*w+a?1:0;if(0===u)continue;o+=T.get(N,n,s,l,e)*u}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const FH={kernelName:Bw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;AV([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=MN(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=eT(d.outShape,o.dtype,GW(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,k=v-1-d.padInfo.top,S=eT(o.shape,"float32"),I=n.data.get(s.dataId).values,T=eT(s.shape,"float32",I);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const r=t-k,s=n-x;let a=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<w;r+=b){const i=(s+r)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=v*w-1-f.get(N,n,i,e)===t*w+r?1:0;if(0===o)continue;a+=T.get(N,n,i,e)*o}}S.set(a,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const LH={kernelName:Ww,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;AV(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,h=MN(s.shape,a,i,[1,1],o),[d,p]=function(e,t,n,r,s){const a=jW(e,0,n,Ub(t),s,"max"),i=GW(e,t,n,s,!0,r);return[a.values,i.values]}(c,s.shape,s.dtype,l,h),f=u.write(d,h.outShape,s.dtype),m=u.write(p,h.outShape,s.dtype);return[{dataId:f,shape:h.outShape,dtype:s.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const MH={kernelName:jw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Ab(a,s.shape),l=Sb(qE(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=iW({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=vG({inputs:{a:h,b:c},backend:n});u.push(d);const p=Xj({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const PH={kernelName:Gw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;AV(s,"min");const o=Ab(a,s.shape);let l=o;const u=YE(l,s.shape.length);let c=s;null!=u&&(c=EW({inputs:{x:s},backend:n,attrs:{perm:u}}),l=JE(l.length,s.shape.length)),XE("min",l,c.shape.length);const[h,d]=qE(c.shape,l),p=Sb(d),f=Gb(Sb(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=fW({inputs:{x:g},backend:n,attrs:{shape:KE(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},zH=VV(((e,t)=>Math.min(e,t))),BH=lW(Hw,zH),UH={kernelName:Hw,backendName:"cpu",kernelFunc:BH};const VH={kernelName:qw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;AV(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=Ub(s.shape),f=Sb(o),m=o.length,g=Ub(o),y=$b(s.dtype,f);for(let b=0;b<f;b++){let e=Xb(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=Kb(e,d,p);y[b]=h[t]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},WH=VV(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),jH=lW(Kw,WH),GH={kernelName:Kw,backendName:"cpu",kernelFunc:jH};function HH(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Ab([o],s.shape),u=EH({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=KE(u.shape,l),h=fW({inputs:{x:u},backend:n,attrs:{shape:c}}),d=SG({inputs:{a:s,b:h},backend:n}),p=hG({inputs:{x:d},backend:n}),f=Xj({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=fW({inputs:{x:f},backend:n,attrs:{shape:c}}),g=vG({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const qH={kernelName:Bx,backendName:"cpu",kernelFunc:HH};const KH={kernelName:Xw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;AV(s,"multinomial");const l=o?s:HH({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,a],p=Gb(Sb(d),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=p_.alea(i.toString()),r=f*a;for(let s=0;s<a;++s){const e=n();p[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function XH(e,t,n){const r=Uk(-1,n);return Gj([],t,r,e,n)}const YH={kernelName:Qw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;AV(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=XH(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},QH=ZA;const JH={kernelName:Zw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;AV(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=QH(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},ZH=eR;const eq={kernelName:ex,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;AV(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=ZH(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},tq=tR;const nq={kernelName:tx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;AV(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=tq(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},rq=VV(((e,t)=>e!==t?1:0)),sq=lW(Jw,rq,null,"bool"),aq={kernelName:Jw,backendName:"cpu",kernelFunc:sq};const iq={kernelName:rx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;AV(s,"oneHot");const u=Sb(s.shape),c=new Float32Array(u*i);c.fill(l);const h=n.data.get(s.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function oq(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=rW({inputs:{input:r},backend:n}),t=oq({inputs:{x:e},backend:n}),s=gj({inputs:{input:r},backend:n}),a=oq({inputs:{x:s},backend:n}),i=eW({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return _G({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const lq={kernelName:uk,backendName:"cpu",kernelFunc:oq};const uq={kernelName:nx,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=rW({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=gj({inputs:{input:s},backend:r}),i=oq({inputs:{x:a},backend:r}),o=eW({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return _G({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function cq(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return pG({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{xb(a,e.shape,"All tensors passed to stack must have matching shapes"),wb(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=bj({inputs:t.map((e=>{const t=pG({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const hq={kernelName:sx,backendName:"cpu",kernelFunc:cq};const dq={kernelName:ax,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;AV(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=n.data.get(s.dataId).values,c=Sb(s.shape),h=s.shape.length,d=Ub(s.shape),p=Sb(o),f=o.length,m=Ub(o),g=$b(s.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){g[Kb(Xb(y,h,d).map(((e,t)=>e+l[t])),f,m)]=u[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},pq=VV(((e,t)=>Math.pow(e,t))),fq=lW(ix,pq),mq={kernelName:ix,backendName:"cpu",kernelFunc:fq};function gq(e,t,n,r){const[s,a]=qE(e,r),i=mS(t,"int32"),o=Gb(Sb(s),i),l=Sb(a);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:s,outDtype:i}}const yq={kernelName:lx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;AV(s,"prod");const o=s.shape.length,l=Ab(a,s.shape),u=YE(l,o);let c=l,h=s;const d=[];null!=u&&(h=EW({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(h),c=JE(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=gq(h.shape,h.dtype,p,c);let y=m;return i&&(y=KE(m,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function bq(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const s=n[e],a=e+t.length-1;if(a>=0){const e=o[a],t=e[e.length-1]-s[r];for(let n=r;n<i;++n)o[a].push(s[n+1]+t)}r=s[r],i=s[i]}i!==r&&(s.push([r,i]),a+=i-r)}return{outSplits:o,valueSlices:s,numValues:a}}function vq(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function wq(e,t,n,r,s){const a=t.slice();a[0]=s;const i=Ob(n,Sb(a)),o=e.length;return function(e,t,n,r,s,a){const i=vq(t,2)[1],o=vq(a,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)s[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}function xq(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=Xb(r,t.length,Ub(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:h}=bq(a,i,e,l),d=function(e){const t=[];for(let n=0;n<e.length;++n){const r=Ob("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=wq(n,r,s,c,h);return[d,p[0],p[1]]}const kq={kernelName:ux,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.data.get(e.dataId).values)),u=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=xq(l,u,c,a.shape,a.dtype,h,i.shape),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},Sq=2147483647;function Iq(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===s.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===c.length?1:c[0],d=Ob("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const t=o?e[0]:e[m],n=l?r[0]:r[m],s=u?a[0]:a[m];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>Sq)throw new Error(`Requires ((limit - start) / delta) <= ${Sq}`);d[m+1]=d[m]+i}const p=Ob(n,d[h]);let f=0;for(let m=0;m<h;++m){const t=d[m+1]-d[m];let n=o?e[0]:e[m];const r=u?a[0]:a[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[d,p]}const Tq={kernelName:cx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Iq(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var Nq=XR;class Eq{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=QR(u),this.raggedRank=JR(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Nq.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Nq.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Nq.VALUE_ROWIDS:return Eq.getMaxWidthValueRowID(t);case Nq.ROW_SPLITS:return Eq.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Nq[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return _q(e,n)}calculateOutputSize(e){const t=this.valuesShape;ZR(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=YR(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let i=0;i<r;++i,a+=t)s.push(a);for(let i=r;i<e;++i)s.push(-1);return wb(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Nq.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case Nq.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${Nq[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Nq.FIRST_DIM_SIZE:return e[0];case Nq.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Nq.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Nq[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let a=n.length-2;a>=0;--a)n[a]=n[a+1]*t[a+1];const r=_q(t,!1),s=Ob(this.valuesDType,Sb(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){a=this.calculateOutputIndex(e-1,a,n[e],t[e])}this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=Sb(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;qS((()=>{const t=QN(u,e),n=fE(t,i);u=n.dataSync()}))}let c=0,h=0,d=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==d){if(h<d){const e=s.subarray(c*o);Cq(a.subarray(h*o),e,(d-h)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)a.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;){Cq(a.slice(d*o),u,o),++d}e<0?(c=p+1,h=d):(c=p,h=d,d=h+1)}else++d}}}function Cq(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function _q(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function Aq(e,t,n,r,s,a,i,o,l,u){return new Eq(e,t,n,r,s,a,i,o,l,u).compute()}const Rq={kernelName:hx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=Aq(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,m)}};function $q(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Gb(0,r);const s=Gb(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+n;return s}const Oq={kernelName:dx,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=$q(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},Dq=DV(fx,(e=>1/e)),Fq={kernelName:fx,backendName:"cpu",kernelFunc:Dq};const Lq={kernelName:vx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;AV(s,"resizeBilinear");const l=Ub(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Sb([h,u,c,f])),y=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let v=0;const w=y[0]/b[0],x=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<u;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(d-1,Math.ceil(t)),a=k*l[0]+n*l[1],o=k*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),s=t-n,u=Math.min(p-1,Math.ceil(t)),c=a+n*l[2],h=o+n*l[2],d=a+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=t+(m[d+e]-t)*s,i=a+(n+(m[y+e]-n)*s-a)*r;g[v++]=i}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}};const Mq={kernelName:wx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;AV([a,s],"resizeBilinearGrad");const o=Ub(s.shape),[l,u,c,h]=s.shape,[,d,p]=a.shape,f=new Float32Array(l*u*c*h),m=[i&&d>1?u-1:u,i&&p>1?c-1:c],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(a.dataId).values;let w=0;for(let x=0;x<l;x++){const e=x*o[0];for(let t=0;t<d;t++){const n=t*y,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=e+r*o[1],i=e+s*o[1],l=n-r,d=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],x=d*u,k=d*s,S=l*u,I=l*s;for(let e=0;e<h;e++){const t=v[w++];f[p+e]+=t*x,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}};const Pq={kernelName:yx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;AV(s,"resizeNearestNeighbor");const l=Ub(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*u*c*f),y=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],v=y[0]/b[0],w=y[1]/b[1];let x=0;for(let k=0;k<h;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?v*(t+.5):v*t;let r=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=e+r*l[1];for(let e=0;e<c;e++){const t=i?w*(e+.5):w*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[x++]=t}}}}return n.makeTensorInfo([h,u,c,f],s.dtype,g)}};const zq={kernelName:bx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;AV([a,s],"resizeNearestNeighborGrad");const o=Ub(s.shape),l=Ub(a.shape),[u,c,h,d]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*h*d),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],w=y[1]/b[1],x=1/v,k=1/w,S=2*Math.ceil(x)+2,I=2*Math.ceil(k)+2;for(let T=0;T<u;T++){const e=T*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*x),s=Math.floor(r-S/2);for(let a=0;a<h;a++){const r=n+a*o[2],u=Math.floor(a*k),y=Math.floor(u-I/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<S;r++){const u=r+s;if(u<0||u>=p)continue;const d=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const r=d+t*l[2],s=t*w;a===Math.min(h-1,i?Math.round(s):Math.floor(s))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const Bq={kernelName:kx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;AV(s,"reverse");const i=s.shape.length,o=Ab(a,s.shape);if(0===i)return PV({inputs:{x:s},backend:n});const l=new nS(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=s.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},Uq={kernelName:dk,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,l=r,u=$b(s.dtype,Sb(s.shape)),[c,h,d,p]=s.shape,[f,m]=n$(o,h,d),g=Math.sin(a),y=Math.cos(a),b=l.data.get(s.dataId).values;for(let v=0;v<c;v++){const e=v*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let r=0;r<d;r++){const s=r*p;for(let a=0;a<p;a++){const o=[c,t,r,a],l=o[2],v=o[1];let w=(l-f)*y-(v-m)*g,x=(l-f)*g+(v-m)*y;w=Math.round(w+f),x=Math.round(x+m);let k=i;if("number"!==typeof i&&(k=3===a?255:i[a]),w>=0&&w<d&&x>=0&&x<h){k=b[e+x*(d*p)+w*p+a]}u[e+n+s+a]=k}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Vq=DV(Sx,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),Wq={kernelName:Sx,backendName:"cpu",kernelFunc:Vq},jq=OV((e=>1/Math.sqrt(e))),Gq=FV(Ix,jq),Hq={kernelName:Ix,backendName:"cpu",kernelFunc:Gq};function qq(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],h=e.values,d=t.values;if(0===r)return eT(n,t.dtype);const p=l instanceof nS?l:eT(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[a*s+n]+=d[f*s+n]:p.values[a*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const Kq={kernelName:Tx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=uA(0,s,i),d=qq(n.bufferSync(s),n.bufferSync(a),i,h,u,l,o,c,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function Xq(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function Yq(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const Qq={kernelName:Ex,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=Ob("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*s;for(let e=0;e<s;++e)i[l+e]="left"===a?Xq(n,t[e+l]):Yq(n,t[e+l])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}};const Jq={kernelName:Cx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;AV([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=mS(s.dtype,a.dtype),h=Gb(Sb(s.shape),c);let d=0;const p=0===i||i>1||1===s.shape.length?1:Sb(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?h[d++]=l[f]:h[d++]=u[f];return n.makeTensorInfo(s.shape,c,h)}},Zq=u$,eK=c$,tK=DV(_x,(e=>e>=0?eK*e:Zq*(Math.exp(e)-1))),nK={kernelName:_x,backendName:"cpu",kernelFunc:tK},rK=DV(Ox,(e=>e<0?-1:e>0?1:0)),sK={kernelName:Ox,backendName:"cpu",kernelFunc:rK},aK=DV(Rx,(e=>Math.sin(e))),iK={kernelName:Rx,backendName:"cpu",kernelFunc:aK},oK=DV($x,(e=>Math.sinh(e))),lK={kernelName:$x,backendName:"cpu",kernelFunc:oK},uK=Math.log(1.1920928955078125e-7)+2,cK=DV(Fx,(e=>{const t=e>-uK,n=e<uK,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),hK={kernelName:Fx,backendName:"cpu",kernelFunc:cK};const dK={kernelName:Px,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;AV([s],"spaceToBatchND");const o=Sb(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);const u=dq.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=r$(u.shape,a,o,!1),h=s$(c.length,a.length,!1),d=a$(u.shape,a,o,!1),p=fW({inputs:{x:u},backend:n,attrs:{shape:c}}),f=EW({inputs:{x:p},backend:n,attrs:{perm:h}}),m=fW({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function pK(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(L$(o));return[Ob(n,0),[0,h],Ob(s,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(M$(g,t));if(t>=l)throw new Error(P$(g,t,l));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,u,c]}{const t=f[l-1],a=Ob(n,t*h),d=Ob(s,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=p[t],i=(0===t?0:f[t-1])+s;p[t]++;for(let r=0;r<h;++r)a[i*h+r]=e[n*h+r];d[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;d[t]=i}}return[a,[t,h],d,u,c]}}const fK={kernelName:Ux,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,m]=pK(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function mK(e,t,n,r,s){const a=Sb(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=s[m];if(-1===e){if(-1!==c)throw new Error(z$(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(B$(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error(V$(r,l));l[c]=e}if(Sb(l)!==a)throw new Error(W$(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=Ob(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const gK={kernelName:Vx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,h]=mK(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}};function yK(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=Ob(n,h.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&d.fill(i),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(H$(g,c));g>m&&d.fill(i,m*u,g*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(q$(n,r[n],l[0]));for(let n=0;n<u;n++)d[g*u+n]+=e[t*u+n]}if(a)for(let e=0;e<u;e++)d[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&d.fill(i,m*u,c*u),[d,h]}const bK={kernelName:Wx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=yK(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const vK={kernelName:jx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=yK(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const wK={kernelName:Gx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=uA(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":m=qq(f,n.bufferSync(a),o,d,c,u,l,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=qq(f,n.bufferSync(a),o,d,c,u,l,h,n.data.get(i.dataId).values[0],p);break;case"int32":m=qq(f,n.bufferSync(a),o,d,c,u,l,h,n.data.get(i.dataId).values[0],p);break;case"string":m=qq(f,n.bufferSync(a),o,d,c,u,l,h,Gk(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const xK={kernelName:zx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Ab(i,s.shape)[0],l=F$(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=ZW({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},kK=OV((e=>Math.sqrt(e))),SK=DV(Lx,(e=>Math.sqrt(e))),IK={kernelName:Lx,backendName:"cpu",kernelFunc:SK},TK={kernelName:qx,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,s=n;AV(r,"square");const a=s.data.get(r.dataId).values,i=new Float32Array(a.length);for(let o=0;o<a.length;++o){const e=a[o];i[o]=e*e}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},NK=VV(((e,t)=>{const n=e-t;return n*n})),EK=lW(Hx,NK),CK={kernelName:Hx,backendName:"cpu",kernelFunc:EK},_K=OV(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),AK=FV(Kx,_K),RK={kernelName:Kx,backendName:"cpu",kernelFunc:AK},$K=DV(ck,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),OK={kernelName:ck,backendName:"cpu",kernelFunc:$K};function DK(e,t,n,r){const s=eT(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}const FK={kernelName:Xx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;AV(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:w}=kN(s.shape,a,i,o,l,u,c,h,d);let x;if(m)x=fW({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){wb(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=uN(b,v,w),t=ZW({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});x=fW({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=DK(p,n.bufferSync(s),w,b);x=n.makeTensorInfo(f,e.dtype,e.values)}return x}};class LK{constructor(e,t,n,r,s,a){this.separator=jk(e),this.nGramWidths=t,this.leftPad=jk(n),this.rightPad=jk(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),h=t+(l>0?0:i-o);let d=0;d+=l*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=u*this.rightPad.length;d+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[h+t]),m(this.separator);if(c>0){m(e[h+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=Ob("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach((s=>{const a=t[o+1]-t[o],l=this.getNumNGrams(a,s);this.createNGrams(e,n,i,r,l,s),r+=l})),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;const a=s+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,a)}}return[i,a]}}function MK(e,t,n,r,s,a,i,o){return new LK(n,r,s,a,i,o).compute(e,t)}const PK={kernelName:Yx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=MK(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function zK(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function BK(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let d=0;d<r;++d){const r=s.length;zK(e[d],t,n,s);const l=s.length-r;o[d]=l,a+=l,i=Math.max(i,l)}const l=Ob("int32",2*a),u=new Array(a),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<o[d];++e)l[2*h]=d,l[2*h+1]=e,u[h]=s[h],++h;return[l,u,c]}const UK={kernelName:Qx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=BK(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function VK(e,t){const n=Ob("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Bk(e[r]).modulo(t).getLowBitsUnsigned();return n}const WK={kernelName:Jx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=VK(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},jK=DV(ek,(e=>Math.tan(e))),GK={kernelName:ek,backendName:"cpu",kernelFunc:jK},HK=DV(tk,(e=>Math.tanh(e)));const qK={kernelName:Nx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=uA(0,s,r.shape),h=n.bufferSync(s),d=n.bufferSync(a),p=n.bufferSync(r),f=qq(h,d,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function KK(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=eT(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}const XK={kernelName:nk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;AV(s,"tile");const i=KK(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},YK=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function QK(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);QK(e,t,Math.max(n,Math.floor(t-a*o/s+l)),Math.min(r,Math.floor(t+(s-a)*o/s+l)))}const s=e[t];let a=n,i=r;for(vb(e,n,t),YK(e[r],s)>0&&vb(e,n,r);a<i;){for(vb(e,a,i),a++,i--;YK(e[a],s)<0;)a+=1;for(;YK(e[i],s)>0;)i-=1}0===YK(e[n],s)?vb(e,n,i):(i+=1,vb(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function JK(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=$b(n,i*r),u=$b("int32",i*r);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o);let a=new Array(n.length);n.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(QK(a,r),a=a.slice(0,r)),s&&a.sort(YK);const i=h*r,c=l.subarray(i,i+r),d=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=a[e].value,d[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[eT(c,n,l),eT(c,"int32",u)]}const ZK={kernelName:rk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;AV(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=JK(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const eX={kernelName:sk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],y=Ub(s.shape),b=y[0],v=y[1],w=y[2],x=Ub(g),k=x[0],S=x[1],I=x[2],T=$b(s.dtype,Sb(g));T.fill(l);const N=r.data.get(s.dataId).values,E=r.data.get(a.dataId).values;for(let C=0;C<c;++C){const e=1===a.shape[0]?E:E.subarray(8*C,8*C+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let s;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const u=(e[0]*n+e[1]*t+e[2])/a,c=(e[3]*n+e[4]*t+e[5])/a,p=tX(u,d,o),f=tX(c,h,o);switch(i){case"nearest":s=rX(N,h,d,b,v,w,C,f,p,r,l);break;case"bilinear":s=sX(N,h,d,b,v,w,C,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}T[C*k+t*S+n*I+r]=s}return r.makeTensorInfo(g,s.dtype,T)}return{dataId:r.write(T,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function tX(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return yb(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return yb(0,n,t-1)}(e,t);case"nearest":return function(e,t){return yb(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function nX(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function rX(e,t,n,r,s,a,i,o,l,u,c){return nX(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function sX(e,t,n,r,s,a,i,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*nX(e,t,n,r,s,a,i,h,d,u,c)+(l-d)*nX(e,t,n,r,s,a,i,h,f,u,c))+(o-h)*((f-l)*nX(e,t,n,r,s,a,i,p,d,u,c)+(l-d)*nX(e,t,n,r,s,a,i,p,f,u,c))}function aX(e,t,n,r){const s=Ab(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new nS(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const h=a.slice();h[1]=i.size;const d=new nS(h,r);u.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const iX={kernelName:ik,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;AV(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=aX(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const oX={kernelName:ok,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[a]=p;const e=ZW({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[p]=fW({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}};const lX={kernelName:lk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;AV(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let d=0;d<u;++d){const e=pG({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,l.push(e)}for(let d=0;d<i;++d){const e=Uk(d,"int32"),t=n.makeTensorInfo([],"int32",e),r=eG({inputs:{a:t,b:c},backend:n}),a=iW({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=qj({inputs:{a:a,b:s},backend:n}),u=Xj({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(a),l.push(i),l.push(u)}const h=cq({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},uX=[bW,wW,kW,IW,pW,TW,_W,AW,RW,$W,DW,LW,PW,UW,WW,qW,KW,XW,YW,yW,QW,tj,sj,oj,lj,oW,hj,pj,tW,fj,vj,xj,kj,Sj,Ij,Tj,Nj,Cj,Aj,Rj,$j,Oj,Dj,Fj,Mj,Pj,zj,Bj,Uj,Vj,Wj,jj,Qj,MV,Jj,tG,uG,dG,fG,yG,CG,AG,RG,DG,MG,PG,zG,UG,WG,HG,XG,zV,YG,yj,JG,eH,nH,UV,aH,lH,cH,pH,mH,bH,wH,SH,IH,TH,CH,RH,$H,OH,DH,FH,LH,MH,PH,UH,VH,GH,KH,Kj,YH,JH,eq,nq,aq,iq,uq,hq,dq,mq,GV,yq,kq,Tq,Rq,Oq,sW,wG,Fq,qV,XV,mW,Lq,Mq,Pq,zq,Bq,Uq,Wq,Hq,Kq,Qq,Jq,nK,JV,sK,iK,lK,ej,qH,hK,dK,fK,gK,bK,vK,wK,xK,IK,TK,CK,RK,OK,FK,PK,UK,WK,IG,Yj,GK,{kernelName:tk,backendName:"cpu",kernelFunc:HK},qK,XK,ZK,eX,CW,iX,oX,lX,lq];for(const n of uX)Sk(n);const cX={},hX={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function dX(e,t){if(!(e in cX)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(ev().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete cX[e]}),!1),ev().getBool("SOFTWARE_WEBGL_ENABLED")&&(hX.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",hX)||n.getContext("experimental-webgl",hX);return n.getContext("webgl2",hX)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;cX[e]=n}const n=cX[e];return null==n||n.isContextLost()?(delete cX[e],dX(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),cX[e])}var pX,fX,mX;function gX(e,t){return[t,e]}function yX(e){const t=Sb(e);return Nb(Math.ceil(t/4))}function bX(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function vX(e,t){const n=e;let r,s,a,i,o,l,u,c,h,d;return 2===ev().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function wX(e,t){const n=t();return ev().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(pX||(pX={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(fX||(fX={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(mX||(mX={}));function xX(e){return!!(ev().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function kX(e,t){return RX(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const SX=/ERROR: [0-9]+:([0-9]+):/g;function IX(e,t){const n=SX.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>Eb((t+1).toString(),a)+e));let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Eb(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function TX(e,t){if(wX(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function NX(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(wX(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),wX(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),wX(e,(()=>e.enableVertexAttribArray(o))),!0)}function EX(e,t,n,r){wX(e,(()=>function(e,t,n){$X(e,n),wX(e,(()=>e.activeTexture(e.TEXTURE0+n))),wX(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),wX(e,(()=>e.uniform1i(n,r)))}function CX(e,t,n){wX(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),wX(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function _X(e,t){wX(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),wX(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function AX(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function RX(e,t,n){const r=wX(e,(()=>t()));if(null==r)throw new Error(n);return r}function $X(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function OX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Sb(e.slice(0,e.length-t))}function DX(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function FX(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[OX(e),...DX(e)]),t}function LX(e){return e%2===0}function MX(e,t){if(Ib(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(LX(n)&&LX(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&LX(e[0])&&LX(t[0])}let PX,zX;function BX(e,t){return null!=e.getExtension(t)}function UX(e){try{if(null!=dX(e))return!0}catch(t5){return console.log("Error when getting WebGL context: ",t5),!1}return!1}function VX(e){if(0===e)return!1;const t=dX(e);if(1!==e){if(BX(t,"EXT_color_buffer_float"))return WX(t);const e="EXT_color_buffer_half_float";if(BX(t,e)){const n=t.getExtension(e);return function(e,t){const n=vX(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!BX(t,"OES_texture_float"))return!1;if(!BX(t,"WEBGL_color_buffer_float"))return!1;return WX(t)}function WX(e){const t=vX(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function jX(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&wb("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const GX=ev();function HX(){let e,t,n,r,s,a,i,o,l,u;return 2===ev().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=ev().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function qX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=Ub(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${t}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function KX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=Ub(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / outShapeStrides[${s}]`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function XX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}(e.map(((e,t)=>t)),t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${r[s]}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`)).join("")}function YX(e){const t=Ub(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}GX.registerFlag("HAS_WEBGL",(()=>GX.getNumber("WEBGL_VERSION")>0)),GX.registerFlag("WEBGL_VERSION",(()=>UX(2)?2:UX(1)?1:0)),GX.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),GX.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===GX.get("WEBGL_VERSION"))),GX.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),GX.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),GX.registerFlag("WEBGL_PACK",(()=>GX.getBool("HAS_WEBGL"))),GX.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_CLIP",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_REDUCE",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_LAZILY_UNPACK",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_CONV_IM2COL",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>GX.getBool("WEBGL_PACK"))),GX.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==PX){const t=dX(e);PX=t.getParameter(t.MAX_TEXTURE_SIZE)}return PX}(GX.getNumber("WEBGL_VERSION")))),GX.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==zX){const t=dX(e);zX=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,zX)}(GX.getNumber("WEBGL_VERSION")))),GX.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=GX.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=dX(e);return t=BX(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:BX(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),GX.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>GX.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!AS())),GX.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=dX(e);if(1===e){if(!BX(t,"OES_texture_float"))return!1}else if(!BX(t,"EXT_color_buffer_float"))return!1;return WX(t)}(GX.getNumber("WEBGL_VERSION")))),GX.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!GX.getBool("WEBGL_FORCE_F16_TEXTURES")&&GX.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),GX.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>VX(GX.getNumber("WEBGL_VERSION")))),GX.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=GX.getNumber("WEBGL_VERSION"))&&null!=dX(e).fenceSync;var e})),GX.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>GX.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),GX.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),GX.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>AS()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),GX.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),GX.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),GX.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),GX.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),GX.registerFlag("WEBGL_EXP_CONV",(()=>!1)),GX.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>GX.getBool("IS_TEST"))),GX.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),GX.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),GX.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),GX.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const QX="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:JX}=i;function ZX(e,t,n){const r=[];if(e.forEach((e=>{const t=Sb(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=cY(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,s="";s+=n?tY(e,r):eY(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=JX(e.shapeInfo.logicalShape,t.logicalShape),l=uY(i),u=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+u]} = 0;`)).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Sb(e.shapeInfo.logicalShape),m=Sb(t.logicalShape),g=1===m;if(1!==a||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Ib(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=uY(l),c=JX(e.shapeInfo.logicalShape,t.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", ");return`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=HX(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,h=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${nY}\n    ${rY}\n    ${sY}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return iY();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ib(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return iY();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(Ib(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${KX(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=qX(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${KX(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=qX(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=qX(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=qX(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=aY);return[h,l,c,s,u,a,n.userCode].join("\n")}function eY(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=oY(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${lY(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=oY(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===a)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&Ib(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Rb(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${eY(hY(e,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${dY(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${lY(e)}\n      }\n    `;const u=a[0],c=a[1],h=oY(r);if(1===c)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Rb(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${eY(hY(e,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${dY(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${lY(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;if(d===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=oY(r);if(t)return`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=Rb(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${eY(hY(e,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${dY(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${lY(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=oY(r);if(t)return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=Rb(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${eY(hY(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${dY(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${lY(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=oY(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Rb(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${eY(hY(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${dY(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${lY(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=oY(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function tY(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=HX();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=HX();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=HX();if(null!=a&&Ib(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${tY(hY(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${dY(a,r)});\n        }\n      `}const o=HX();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${h}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=HX();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(a[i-1]/2);let d=h*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,d*=a[i-m-1],f=`b${m} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const nY="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",rY="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sY="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",aY="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function iY(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function oY(e){return`offset${e}`}function lY(e){const t=e.name,n=Sb(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function uY(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function cY(e,t,n){const{newShape:r,keptDims:s}=Rb(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,l=!e&&a>1&&!Ib(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function hY(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function dY(e,t){return t.map((t=>e[t])).join(", ")}function pY(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=ZX(s,i,t),l=function(e,t){const n=RX(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(wX(e,(()=>e.shaderSource(n,t))),wX(e,(()=>e.compileShader(n))),ev().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw IX(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return ev().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},fY(e,t,u)))}function fY(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===ev().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of t.variableNames){const s={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,`${h}Shape`,c),s.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),r.push(s)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const h of t.customUniforms)s.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function mY(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!Ib(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!Ib(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function gY(e){return ev().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class yY{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=pX.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=HX();this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?KX(["r","c","d"],e):qX(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class bY{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=pX.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=HX();this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?KX(["r","c","d"],e):qX(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class vY{constructor(e){this.variableNames=["A"],this.outTexUsage=fX.DOWNLOAD;const t=HX();this.outputShape=e,this.userCode=`\n      ${QX}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class wY{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fX.DOWNLOAD;const t=HX();this.outputShape=e,this.userCode=`\n      ${QX}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const xY={R:0,G:1,B:2,A:3};class kY{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=HX();this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){const e=n[i];a+=`\n          if(offset == ${i}) {\n            result = values[${xY[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":YX(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class SY{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=HX();this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let t=0;t<=1;t++){const s=2*a+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${a};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":YX(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function IY(e){const t=HX();return function(e,t){const n=RX(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(wX(e,(()=>e.shaderSource(n,t))),wX(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function TY(e){return function(e,t){const n=RX(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wX(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wX(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function NY(e){return function(e,t){const n=RX(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wX(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),wX(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function EY(e,t,n,r,s,a){!function(e,t){const n=ev().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return RX(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return wX(e,(()=>e.bindTexture(o,i))),wX(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),wX(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),wX(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),wX(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===ev().getNumber("WEBGL_VERSION")?wX(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))):wX(e,(()=>e.texStorage2D(o,1,r,t,n))),wX(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function CY(e){return e.internalFormatFloat}function _Y(e){return e.internalFormatHalfFloat}function AY(e){return e.downloadTextureFormat}function RY(e){return e.internalFormatPackedFloat}function $Y(e){return e.internalFormatPackedHalfFloat}function OY(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=bX(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class DY{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ev().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){cX[e]=t}(t,e)):this.gl=dX(t),e=this.gl,2===ev().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>wX(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>wX(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>wX(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>wX(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wX(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>wX(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>wX(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>wX(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===ev().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=kX(this.gl,e),BX(this.gl,t))this.textureHalfFloatExtension=kX(this.gl,t);else if(ev().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),BX(this.gl,r))this.colorBufferHalfFloatExtension=kX(this.gl,r);else if(ev().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",BX(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!BX(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=TY(this.gl),this.indexBuffer=NY(this.gl),this.framebuffer=function(e){return RX(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=vX(this.gl,this.textureHalfFloatExtension)}get debug(){return ev().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;wX(e,(()=>e.finish())),wX(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wX(e,(()=>e.deleteFramebuffer(this.framebuffer))),wX(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),wX(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),wX(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=gX(t,n);return EY(e,s,a,CY(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=gX(t,n);return EY(e,s,a,_Y(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=gX(t,n);return EY(e,s,a,AY(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){wX(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===ev().getNumber("WEBGL_VERSION")?wX(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):wX(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===ev().getNumber("WEBGL_VERSION")?wX(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):wX(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),wX(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,l;wX(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),2===ev().getNumber("WEBGL_VERSION")?wX(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):wX(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),wX(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=bX(t,n);return EY(e,s,a,$Y(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=bX(t,n);return EY(e,s,a,RY(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(_X(this.gl,this.framebuffer),this.outputTexture=null),wX(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=gX(t,n),i=new Uint8Array(t*n*4);return wX(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return OY(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();wX(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return wX(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),wX(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),wX(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(ev().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return wX(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=IY(t));const n=function(e){return RX(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);wX(t,(()=>t.attachShader(n,this.vertexShader))),wX(t,(()=>t.attachShader(n,e))),function(e,t){if(wX(e,(()=>e.linkProgram(t))),!ev().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&TX(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;wX(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){wX(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),NX(e,t,"clipSpacePos",n,3,20,0)&&NX(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(wX(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&TX(this.gl,this.program),wX(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return RX(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),wX(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),EX(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=bX(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&TX(this.gl,this.program),AX(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wX(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wX(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=kX(this.gl,2===ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Cb((()=>this.disposed||this.isQueryAvailable(e,ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in ev().platform&&(n=ev().platform.setTimeoutCustom.bind(ev().platform)),Cb((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),CX(this.gl,e,this.framebuffer),this.debug&&AX(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(CX(this.gl,this.outputTexture,this.framebuffer),this.debug&&AX(this.gl)):_X(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;CX(r,e,this.framebuffer),this.debug&&AX(r),this.outputTexture=e,wX(r,(()=>r.viewport(0,0,t,n))),wX(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),wX(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:FY,XI:LY,Nk:MY,f6:PY,ct:zY,YG:BY,hH:UY,z3:VY,sG:WY,uM:jY,vS:GY,qB:HY,GG:qY,rq:KY,lg:XY,WR:YY,cu:QY,GE:JY,px:ZY,jC:eQ,He:tQ,hE:nQ,BF:rQ,Dk:sQ,cl:aQ,_B:iQ,ub:oQ,_f:lQ,Ku:uQ,qy:cQ,Zy:hQ,bu:dQ,zv:pQ,dH:fQ,HS:mQ,yH:gQ,l3:yQ,z9:bQ,x6:vQ,_m:wQ,eW:xQ,GK:kQ,SP:SQ,yr:IQ,dl:TQ,Dw:NQ,xT:EQ,_X:CQ,wz:_Q}=E;function AQ(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function RQ(e,t){return 1===t?[e]:AQ(e,t)}class $Q{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=gY(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=RQ("rc",this.rank),t=uY(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class OQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${a}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${a>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?XX(["r","c","d"],"inputShape"):qX(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":YX(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class DQ{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=LQ(t,n),s=MQ(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=FQ(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===mX.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===mX.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===mX.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===mX.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===mX.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=LQ(n,r),a=MQ(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=FQ(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=ev().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function FQ(e,t,n,r,s){const a=function(e,t){switch(e){case mX.PACKED_2X2_FLOAT32:return RY(t);case mX.PACKED_2X2_FLOAT16:return $Y(t);case mX.UNPACKED_FLOAT32:return CY(t);case mX.UNPACKED_FLOAT16:return _Y(t);case mX.PACKED_4X1_UNSIGNED_BYTE:return AY(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=bX(e[0],e[1]);i=t*n}else{const[t,n]=gX(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function LQ(e,t){if(e===fX.UPLOAD)return mX.PACKED_2X2_FLOAT32;if(e===fX.RENDER||null==e)return function(e){return ev().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?mX.PACKED_2X2_FLOAT32:mX.UNPACKED_FLOAT32:e?mX.PACKED_2X2_FLOAT16:mX.UNPACKED_FLOAT16}(t);if(e===fX.DOWNLOAD||e===fX.PIXELS)return mX.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function MQ(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class PQ{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const zQ="if (isnan(x)) return x;",BQ="return abs(x);";const UQ=zQ+"\n  return (x < 0.0) ? 0.0 : x;\n",VQ=zQ+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",WQ="return x;";class jQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class GQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length);const t=e.length,n=RQ("rc",t),r=uY(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const HQ=bA,qQ={};const KQ=ev().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class XQ extends fb{nextDataId(){return XQ.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ev().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof DY)t=e;else{const n=dX(ev().getNumber("WEBGL_VERSION"),e);t=new DY(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=dX(ev().getNumber("WEBGL_VERSION"));t=new DY(e),this.binaryCache=((n=ev().getNumber("WEBGL_VERSION"))in qQ||(qQ[n]={}),qQ[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new DQ(this.gpgpu),this.numMBBeforeWarning=null==ev().global.screen?1024:ev().global.screen.height*ev().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new pb(this,GS())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=FX(t),u=new kY(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((ev().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ev().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:fX.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,s){if(ev().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:fX.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new jQ(i,WQ):new PQ(i,WQ);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=Wk()),"complex64"===r){c=y$(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Wk()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new jQ(r,WQ):new PQ(r,WQ);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(ev().getBool("DEBUG")&&!ev().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ev().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&ev().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...yX(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=y$(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Sb(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;wX(e,(()=>e.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&GS().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new jQ(s,WQ):new PQ(s,WQ);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=GS().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Gk(e)));return eT(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return eT(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!xX(n)){if(ev().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Sb(t);if(ev().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...yX(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=ev().getBool("WEBGL_PACK")&&!0===r,i=a?FX(t):t,o=a?new wY(i):new vY(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=qk(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=qk(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Wk(),endMs:null}}endTimer(e){return ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Wk(),e)}async getQueryTime(e){if(ev().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:KQ;return ev().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Sb(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){gk("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return HQ(e.shape,t)}packedUnaryOp(e,t,n){const r=new jQ(e.shape,t),s=this.compileAndRun(r,[e],n);return GS().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=fQ(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(ev().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,BQ,e.dtype);const t=new PQ(e.shape,BQ),n=this.compileAndRun(t,[e]);return GS().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Lb(n[0])){const s=n.map((e=>jk(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return GS().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new GQ(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new $Q(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[OX(e.shape),...DX(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[OX(t),...DX(t)],a=new OQ(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(null!=t){wb(Sb(s)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=FX(s);let o;o=r?new bY(i):new yY(i);const l=[null!=t?t:yX(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===pX.DENSE){const t=null!=a?a:yX(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Sb(i.shape))return o.values=$b(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Sb(t.shape)<=ev().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!MX(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=cY(e.packedInputs,t.shape,a);let u="",c="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=Ub(o);h=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=t.shape.length,p=2===o.length&&Ib(t.shape,a),f=1===Sb(t.shape),m=NT(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&Ib(a,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${d}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${h}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${ev().getNumber("WEBGL_VERSION")}`,a}(e,u,c),d=this.getAndSaveBinary(h,(()=>pY(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),ev().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(mY(t.inShapeInfos,n),mY([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===ev().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:s,offset:a,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=cY(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(Sb(r.shape)<2)e.gl.uniform1f(s,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=r.texData.slice&&null!=a&&e.gl.uniform1i(a,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,s,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=Ub(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],a=s[l];if("float"===n.type)e.gl.uniform1fv(r,a);else if("vec2"===n.type)e.gl.uniform2fv(r,a);else if("vec3"===n.type)e.gl.uniform3fv(r,a);else if("vec4"===n.type)e.gl.uniform4fv(r,a);else if("int"===n.type)e.gl.uniform1iv(r,a);else if("ivec2"===n.type)e.gl.uniform2iv(r,a);else if("ivec3"===n.type)e.gl.uniform3iv(r,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,a)}}e.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=ev().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Wk();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!ev().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!ev().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=qS((()=>{if(!ev().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ev().getBool("DEBUG");ev().set("DEBUG",!1);const t=this.abs(dT(1e-8)).dataSync()[0];if(ev().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=Wk());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=ev().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ev().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&ev().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?bb(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Rb(e);e=t.newShape}let s=Sb(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=OX(e);let n=2,r=2;e.length&&([n,r]=DX(e)),s=t*(n/2)*(r/2),a=Nb(s).map((e=>2*e))}else a=Nb(s);return a}(n,o),t.texShape=c),null!=s){const e=FX(n);let a,i=c[1],h=c[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([i,h]=bX(c[0],c[1])),a=o?new SY(e,d):new kY(e,d);const p=d?[h,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?fX.PIXELS:fX.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const g=[[h,i]],y=!0,b=this.runWebGLProgram(a,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,ev().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=Wk()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Fb(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await HR(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw IX(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=fY(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=GS().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,s,a,i);return GS().makeTensorFromDataId(l,t,n,o)}}XQ.nextDataId=0;RS()&&YS("webgl",(()=>new XQ),2);const YQ="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class QQ{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=CT(t,n),this.enableShapeUniforms=gY(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const JQ="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class ZQ{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=CT(t,n);const s=this.outputShape.length;this.enableShapeUniforms=gY(s);let a="";if(r)if(0===s||1===Sb(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${uY(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=RQ("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function eJ(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const tJ={kernelName:ww,backendName:"webgl",kernelFunc:eJ};function nJ(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=eJ({inputs:{x:r},backend:n}),l=eJ({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const rJ={kernelName:Rv,backendName:"webgl",kernelFunc:nJ},sJ="return (a < 0.) ? b * a : a;",aJ="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const iJ={kernelName:Nw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",Uk(a,"float32")),o=ev().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ZQ(aJ,s.shape,i.shape):new QQ(sJ,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},oJ="return (a < 0.) ? b * a : a;",lJ="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const uJ={kernelName:ox,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=ev().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ZQ(lJ,r.shape,s.shape):new QQ(oJ,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},cJ="if (isnan(x)) return x;";function hJ(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:s}=e;return e=>{let{inputs:a,backend:i}=e;const{x:o}=a,l=i,u=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=ev().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new jQ(o.shape,n):new PQ(o.shape,t),l.runWebGLProgram(c,[o],u)}}function dJ(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:s=!1,cpuKernelImpl:a,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,h=l;if(s&&"complex64"===u.dtype){const e=h.texData.get(u.dataId),n=h.texData.get(c.dataId),[r,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new QQ(t,u.shape,c.shape);return h.runWebGLProgram(i,[s,a],mS(n.dtype,r.dtype))})),a=nJ({inputs:{real:r,imag:s},backend:h});return h.disposeIntermediateTensorInfo(r),h.disposeIntermediateTensorInfo(s),a}const d=i||mS(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||h.shouldExecuteOnCPU([u,c]))&&null!=a){const e=h.texData.get(u.dataId).values,t=h.texData.get(c.dataId).values,n="string"===u.dtype?Q$(e):e,r="string"===u.dtype?Q$(t):t,[s,i]=a(u.shape,c.shape,n,r,d),o=h.makeTensorInfo(i,d);return h.texData.get(o.dataId).values=s,o}let p;return p=ev().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new ZQ(n,u.shape,c.shape,r):new QQ(t,u.shape,c.shape),h.runWebGLProgram(p,[u,c],d)}}function pJ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":UQ;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":VQ;if("prelu"===e)return t?lJ:oJ;if("leakyrelu"===e)return t?aJ:sJ;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class fJ{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=gY(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const mJ="return areal * breal - aimag * bimag;",gJ="return areal * bimag + aimag * breal;";class yJ{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=CT(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const bJ="return a * b;";function vJ(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=mS(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new yJ(mJ,r.shape,s.shape),i=new yJ(gJ,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=nJ({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=rQ(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=ev().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ZQ(bJ,r.shape,s.shape):new QQ(bJ,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const wJ={kernelName:Yw,backendName:"webgl",kernelFunc:vJ};function xJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Sb(s.shape),l=_b(a,o),u=Sb(l);wb(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||MX(s.shape,l)||null!==c.texture&&MX(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[OX(e.shape),...DX(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[OX(t),...DX(t)],i=new OQ(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,l,i)}const kJ={kernelName:gx,backendName:"webgl",kernelFunc:xJ};class SJ{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Tb(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class IJ{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function TJ(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=t$(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,h;c="mean"===n?0===i?new SJ({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new SJ({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new IJ({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}class NJ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const r=uY(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class EJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=uY(this.rank),s=AQ("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function CJ(e,t,n){const r=ev().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EJ(e.shape,t):new NJ(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function _J(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=Ab(s,e.shape);let o=i;const l=YE(o,a),u=null!=l;let c=e;u&&(c=CJ(e,l,r),o=JE(o.length,a)),XE("sum",o,a);const[h,d]=qE(c.shape,o);let p=h;n&&(p=KE(h,i));const f=Sb(d),m=xJ({inputs:{x:c},attrs:{shape:[Sb(e.shape)/f,f]},backend:r}),g=TJ(m,gS(e.dtype),"sum",r),y=xJ({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(s,a,i,n)}const AJ={kernelName:Mx,backendName:"webgl",kernelFunc:_J};function RJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=CQ(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);i.texData.get(u.dataId).values=t}else u=CJ(s,a,i);return u}const $J={kernelName:ak,backendName:"webgl",kernelFunc:RJ};function OJ(e){let{a:t,b:n,transposeA:r,transposeB:s,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,h=n.shape.length,d=r?t.shape[c-2]:t.shape[c-1],p=s?n.shape[h-1]:n.shape[h-2],f=r?t.shape[c-1]:t.shape[c-2],m=s?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=Sb(g),v=Sb(y),w=CT(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);wb(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${s} must match.`));const x=r?[b,d,f]:[b,f,d],k=s?[v,m,p]:[v,p,m],S=xJ({inputs:{x:t},backend:a,attrs:{shape:x}}),I=xJ({inputs:{x:n},backend:a,attrs:{shape:k}}),T=[S,I],N=Math.max(b,v),E=r?S.shape[1]:S.shape[2],C=null!=i,_=null!=o,A="leakyrelu"===u,R=null!=u?pJ(u,!0):null;let $;if((1===f||1===m)&&E>1e3&&!1===(C||_||A||null!=R)){let e=S,t=I;r&&(e=RJ({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),T.push(e)),s&&(t=RJ({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),T.push(t));const n=1===m;let i=e;1!==m&&(i=xJ({inputs:{x:e},backend:a,attrs:{shape:[N,E,1]}}),T.push(i));const o=1===m?2:1;let l=t;n&&(l=xJ({inputs:{x:t},backend:a,attrs:{shape:[N,1,E]}}),T.push(l));const u=vJ({inputs:{a:i,b:l},backend:a});$=_J({inputs:{x:u},backend:a,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{const e=mS(t.dtype,n.dtype),u=new fJ(x,k,[N,f,m],r,s,C,R,_,A),c=[S,I];if(null!=i&&c.push(i),_&&c.push(o),A){const e=a.makeTensorInfo([],"float32",Uk(l,"float32"));c.push(e),T.push(e)}$=a.runWebGLProgram(u,c,e)}const O=xJ({inputs:{x:$},backend:a,attrs:{shape:w}});T.push($);for(const D of T)a.disposeIntermediateTensorInfo(D);return O}const DJ={kernelName:pk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return OJ({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},FJ="return abs(x);";const LJ={kernelName:av,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=fQ(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=ev().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jQ(r.shape,FJ):new PQ(r.shape,FJ),n.runWebGLProgram(s,[r],r.dtype)}},MJ=hJ({opSnippet:zQ+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),PJ={kernelName:iv,backendName:"webgl",kernelFunc:MJ},zJ=hJ({opSnippet:zQ+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),BJ={kernelName:ov,backendName:"webgl",kernelFunc:zJ},UJ="return a + b;",VJ=dJ({opSnippet:UJ,packedOpSnippet:UJ,supportsComplex:!0,cpuKernelImpl:FY}),WJ={kernelName:lv,backendName:"webgl",kernelFunc:VJ};class jJ{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class GJ{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const HJ={kernelName:uv,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return eJ({inputs:{x:s[0]},backend:r});if(s.length>ev().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>mS(e,t))),i=s.map((e=>e.shape)),o=ev().getBool("WEBGL_PACK")?new GJ(s[0].shape,i):new jJ(s[0].shape,i);return r.runWebGLProgram(o,s,a)}};const qJ={kernelName:cv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ab(a,s.shape);let u=l;const c=YE(u,o);let h=s;null!=c&&(h=RJ({inputs:{x:s},backend:n,attrs:{perm:c}}),u=JE(u.length,o)),XE("all",u,o);const[d,p]=qE(h.shape,u),f=xJ({inputs:{x:h},backend:n,attrs:{shape:[-1,Sb(p)]}}),m=TJ(f,f.dtype,"all",n);let g;if(i){g=xJ({inputs:{x:m},backend:n,attrs:{shape:KE(d,l)}})}else g=xJ({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};const KJ={kernelName:hv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ab(a,s.shape);let u=l;const c=YE(u,o);let h=s;null!=c&&(h=RJ({inputs:{x:s},backend:n,attrs:{perm:c}}),u=JE(u.length,o)),XE("any",u,o);const[d,p]=qE(h.shape,u),f=xJ({inputs:{x:h},backend:n,attrs:{shape:[-1,Sb(p)]}}),m=TJ(f,f.dtype,"any",n);let g;if(i){g=xJ({inputs:{x:m},backend:n,attrs:{shape:KE(d,l)}})}else g=xJ({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class XJ{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class YJ{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,wb(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=uY(o),u=RQ("coords",o);let c,h;if(1===a){h=o+1;const e=uY(h);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),m=RQ("sourceLocR",h-1).concat("inIdx.r"),g=RQ("sourceLocG",h-1).concat("inIdx.g"),y=RQ("sourceLocB",h-1).concat("inIdx.b"),b=RQ("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,x=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function QJ(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=t$(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new XJ(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=QJ(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function JJ(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=null!=r?r.shape:t.shape,a=t$(s[s.length-1]),i=new YJ(s,a,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=JJ(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function ZJ(e,t,n,r){const s=[n];if(XE("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ev().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=qE(i.shape,s),u=Sb(l),c=xJ({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const h=QJ(e,c,r);n.push(h);const d=xJ({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return JJ(e,t,r)}const eZ={kernelName:dv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Ab(a,s.shape);const o=YE(i,s.shape.length);let l=s;const u=[];null!=o&&(l=RJ({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=JE(i.length,l.shape.length)),XE("argMax",[i[0]],l.shape.length);const c=ZJ(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const tZ={kernelName:pv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Ab(a,s.shape);const o=YE(i,s.shape.length);let l=s;const u=[];null!=o&&(l=RJ({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=JE(i.length,l.shape.length)),XE("argMin",[i[0]],l.shape.length);const c=ZJ(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},nZ=hJ({opSnippet:zQ+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),rZ={kernelName:fv,backendName:"webgl",kernelFunc:nZ},sZ=hJ({opSnippet:zQ+"return log(x + sqrt(x * x + 1.0));"}),aZ={kernelName:mv,backendName:"webgl",kernelFunc:sZ},iZ=hJ({opSnippet:zQ+"\n  return atan(x);\n"}),oZ={kernelName:gv,backendName:"webgl",kernelFunc:iZ},lZ=dJ({opSnippet:YQ+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+JQ+"\n  return result;\n"}),uZ={kernelName:bv,backendName:"webgl",kernelFunc:lZ},cZ=hJ({opSnippet:zQ+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),hZ={kernelName:yv,backendName:"webgl",kernelFunc:cZ};class dZ{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(a/4),w=a%4,x=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${x}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${x}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class pZ{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");const x=4*Math.floor(a/4),k=a%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}}const fZ={kernelName:vv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;jX(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;wb(qN(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=MN(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Ib(u.inShape,u.outShape))return eJ({inputs:{x:s},backend:n});const c=new dZ(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}};const mZ={kernelName:xv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=PN(s.shape,a,i,[1,1,1],o,l,u),h=new pZ(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class gZ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yZ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const bZ={kernelName:kv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=PN(i.shape,o,l,[1,1,1],u,c),d=new yZ(h);return n.runWebGLProgram(d,[s],i.dtype)}};const vZ={kernelName:wv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;jX([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=MN(i.shape,o,l,1,u),h=new gZ(c);return n.runWebGLProgram(h,[s],i.dtype)}};const wZ={kernelName:Sv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return OJ({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class xZ{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],CT(e,t),CT(e,n);let i="0.0";null!=r&&(CT(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(CT(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class kZ{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],CT(e,t),CT(e,n);let i="vec4(0.0)";null!=r&&(CT(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(CT(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const SZ={kernelName:mw,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,mean:a,variance:i,offset:o,scale:l}=t;wb(a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),wb(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),wb(null==l||a.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[s,a,i];let h=null;null!=o&&(h=o.shape,c.push(o));let d=null;null!=l&&(d=l.shape,c.push(l));const p=ev().getBool("WEBGL_PACK_NORMALIZATION")?new kZ(s.shape,a.shape,i.shape,h,d,u):new xZ(s.shape,a.shape,i.shape,h,d,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class IZ{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=uY(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return TZ.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${TZ[t]} = start[${t}] + coords.${TZ[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const TZ=["x","y","z","w","u","v"];class NZ{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=uY(this.rank),n=RQ("coords",this.rank),r=RQ("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function EZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=xN(s,a,i);if(oN(s,o,l),0===Sb(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=mQ(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=vN(s.shape,o,l);if(u||!c){const e=ev().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NZ(l):new IZ(l),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=wN(t,Ub(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const CZ={kernelName:Ax,backendName:"webgl",kernelFunc:EZ},_Z={kernelName:Iv,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;wb(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=r$(s.shape,a,o),u=s$(l.length,a.length),c=a$(s.shape,a,o),h=i$(i,a.length),d=o$(c,i,a.length),p=[],f=xJ({inputs:{x:s},backend:n,attrs:{shape:l}}),m=RJ({inputs:{x:f},backend:n,attrs:{perm:u}}),g=xJ({inputs:{x:m},backend:n,attrs:{shape:c}}),y=EZ({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const AZ={kernelName:Tv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=LY(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}};const RZ={kernelName:Nv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ev().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ev().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=PY(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new ZQ("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new QQ("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}};const $Z={kernelName:Ev,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=CT(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},OZ=dJ({opSnippet:"return float(a != b);",cpuKernelImpl:aQ,dtype:"bool"}),DZ={kernelName:Jw,backendName:"webgl",kernelFunc:OZ};function FZ(e){const{inputs:t,backend:n}=e,{input:r}=t;return eJ({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const LZ={kernelName:px,backendName:"webgl",kernelFunc:FZ};const MZ={kernelName:Cv,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return eJ({inputs:{x:a},backend:r});const t=UC(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=nJ({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=FZ({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Db(a.dtype,i)){const e=eJ({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=zY(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new PQ(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",$b("bool",1)),t=OZ({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},PZ="return ceil(x);",zZ=hJ({opSnippet:PZ,packedOpSnippet:PZ,cpuKernelImpl:BY}),BZ={kernelName:_v,backendName:"webgl",kernelFunc:zZ};class UZ{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class VZ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const WZ={kernelName:Av,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=ev().getBool("WEBGL_PACK_CLIP")?new VZ(s.shape):new UZ(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class jZ{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function GZ(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const HZ={kernelName:$v,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new jZ(r.shape),i=[GZ(r,s.complexTensorInfos.real),GZ(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class qZ{constructor(e){this.outputShape=[],this.outputShape=KR(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const e=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${e}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class KZ{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=KR(e,t);const n=this.outputShape,r=n.length,s=uY(r),a=RQ("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];h+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${XZ(i,l,e)}),\n            vec2(${XZ(u,l,e)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${XZ(i,l,p)}),\n          vec2(${XZ(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function XZ(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function YZ(e){const{inputs:t,backend:n}=e,{input:r}=t;return eJ({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const QZ={kernelName:kw,backendName:"webgl",kernelFunc:YZ};function JZ(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>FZ({inputs:{input:e},backend:n}))),s=e.map((e=>YZ({inputs:{input:e},backend:n}))),a=JZ(r,t,n),i=JZ(s,t,n),o=nJ({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=Sb(e.shape.slice(t));return xJ({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=KR(s.map((e=>e.shape)),1),o=1===s[0].shape[0],l=UY(a,i,r,o),u=KR(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const a=e.filter((e=>Sb(e.shape)>0)),i=ev().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new PQ(e[0].shape,WQ):new jQ(e[0].shape,WQ);return n.runWebGLProgram(t,e,r)}const o=ev().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let s=0;s<a.length;s+=o){const r=a.slice(s,s+o);e.push(JZ(r,t,n))}const r=JZ(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new KZ(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=KR(e.map((e=>e.shape)),t),s=e.map((e=>xJ({inputs:{x:e},attrs:{shape:[-1,Sb(e.shape.slice(t))]},backend:n})));return{tensors2D:s,outShape:r}}(a,t,n),c=new qZ(l.map((e=>e.shape))),h=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=xJ({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function ZZ(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Ab(s,t[0].shape)[0];qR(t.map((e=>e.shape)),a);const i=KR(t.map((e=>e.shape)),a);if(0===Sb(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Sb(e.shape)>0));return 1===o.length?eJ({inputs:{x:o[0]},backend:n}):JZ(o,a,n)}const e0={kernelName:Ov,backendName:"webgl",kernelFunc:ZZ};class t0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",w="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${w}\n        setOutput(result);\n      }\n    `}}class n0{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class r0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=gY(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(h+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(a%2===1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,h+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=a%2===0?bb(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):h+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(a%2===1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(h+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(h+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(h+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class s0{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=gY(this.outputShape.length);const{dataFormat:n}=t,r=HX(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function a0(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function i0(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=s.texData.get(t.dataId),h=r.inChannels,d=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=a0(i.shape,f);null!=e&&(i=xJ({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if(null!=a){const e=a0(a.shape,f);null!=e&&(a=xJ({inputs:{x:a},backend:s,attrs:{shape:e}}),y.push(a))}if(!((1===d||1===p)&&h>1e3)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&Ib(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),h={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},d=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,wb(MX(c.shape,h.shape),(()=>`packed reshape ${c.shape} to ${h.shape} isn't free`));const p=xJ({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=OJ({a:h,b:p,backend:s,transposeA:false,transposeB:m,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),b=s.texData.get(f.dataId);wb(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=d,b.shape=r.outShape,g=eJ({inputs:{x:f},backend:s}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,u=xJ({inputs:{x:t},backend:s,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=xJ({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=OJ({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:s,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=xJ({inputs:{x:h},backend:s,attrs:{shape:r.outShape}}),y.push(u),y.push(c),y.push(h)}for(const b of y)s.disposeIntermediateTensorInfo(b);return g}function o0(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*h,y=p*d,b=[r.batchSize,g,y],v=[];if(null!=i){const e=a0(i.shape,m);null!=e&&(i=xJ({inputs:{x:i},backend:s,attrs:{shape:e}}),v.push(i))}if(null!=a){const e=a0(a.shape,m);null!=e&&(a=xJ({inputs:{x:a},backend:s,attrs:{shape:e}}),v.push(a))}const w=xJ({inputs:{x:n},backend:s,attrs:{shape:[1,g,Sb(n.shape)/g]}});v.push(w);const x=new s0(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=s.runWebGLProgram(x,[t],"float32",k),I=xJ({inputs:{x:S},backend:s,attrs:{shape:b}});v.push(S),v.push(I);const T=null!=a,N=null!=i,E="leakyrelu"===l,C=l?pJ(l,!0):null,_=new fJ(m?I.shape:w.shape,m?w.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,T,C,N,E),A=m?[I,w]:[w,I];if(a&&A.push(a),N&&A.push(i),E){const e=s.makeTensorInfo([],"float32",Uk(o,"float32"));A.push(e),v.push(e)}const R=s.runWebGLProgram(_,A,"float32"),$=xJ({inputs:{x:R},backend:s,attrs:{shape:r.outShape}});v.push(R);for(const O of v)s.disposeIntermediateTensorInfo(O);return $}const l0={kernelName:Dv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=XN(l),d=zN(s.shape,a.shape,i,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&ev().getBool("WEBGL_EXP_CONV")){const e=new r0(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(ev().getBool("WEBGL_CONV_IM2COL"))p=o0({x:s,filter:a,convInfo:d,backend:n});else{const e=new t0(d);p=n.runWebGLProgram(e,[s,a],"float32")}else p=i0({x:s,filter:a,convInfo:d,backend:n});const f=xJ({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class u0{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class c0{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class h0{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class d0{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const p0={kernelName:Fv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=XN(l),d=zN(s.shape,c,i,1,o,u,!1,h),p=new u0(d);return n.runWebGLProgram(p,[s,a],"float32")}};class f0{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=gY(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const m0={kernelName:Lv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=XN(u),d=zN(i,a.shape,o,1,l,c,!1,h);if(ev().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new f0(d);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new c0(d);return n.runWebGLProgram(e,[s,a],"float32")}}};const g0={kernelName:Mv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=BN(s.shape,a.shape,i,l,o),c=new n0(u);return n.runWebGLProgram(c,[s,a],"float32")}};const y0={kernelName:Pv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=BN(s.shape,l,i,1,o),c=new h0(u);return n.runWebGLProgram(c,[s,a],"float32")}};const b0={kernelName:zv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=BN(l,a.shape,o,1,i),c=new d0(u);return n.runWebGLProgram(c,[s,a],"float32")}},v0=hJ({opSnippet:cJ+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${JQ}\n  return result;\n`}),w0={kernelName:Bv,backendName:"webgl",kernelFunc:v0},x0=hJ({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),k0={kernelName:Uv,backendName:"webgl",kernelFunc:x0};class S0{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const I0={kernelName:jv,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new S0(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var T0;!function(e){e.Prod="*",e.Sum="+"}(T0||(T0={}));class N0{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===T0.Prod?"1.0":"0.0",i=n?a:`getX(${E0(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${uY(s)} coords = getOutputCoords();\n        int end = ${C0(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${C0(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${E0(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function E0(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function C0(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function _0(e,t,n,r,s,a){const i=t.shape.length,o=YE([r],i);let l=t;null!=o&&(l=RJ({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=JE(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=eJ({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const t=new N0(e,l.shape,!1,a),r=[[d]],s=h;h=n.runWebGLProgram(t,[h],h.dtype,r),n.disposeIntermediateTensorInfo(s)}if(s){const t=new N0(e,l.shape,s,a),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=RJ({inputs:{x:h},backend:n,attrs:{perm:QE(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const A0={kernelName:Vv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return _0(T0.Prod,s,n,a,i,o)}};const R0={kernelName:Wv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return _0(T0.Sum,s,n,a,i,o)}};const $0={kernelName:Gv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=LY(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=MY(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class O0{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const D0={kernelName:Hv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),h=new O0("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(h,[s],s.dtype)}};class F0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=gY(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class L0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=gY(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)d+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)d+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?bb(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const M0={kernelName:qv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),wb(qN(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=zN(s.shape,a.shape,i,c,o,u,!0);let d;d=ev().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new L0(h):new F0(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",p)}};class P0{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class z0{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const B0={kernelName:Kv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=zN(s.shape,c,i,o,l,u,!0),d=new P0(h);return n.runWebGLProgram(d,[s,a],"float32")}};const U0={kernelName:Xv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=zN(c,a.shape,i,o,l,u,!0),d=new z0(h);return n.runWebGLProgram(d,[s,a],"float32")}};class V0{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const W0={kernelName:Yv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Sb(r.shape),i=xJ({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new V0(a),l=n.runWebGLProgram(o,[i],i.dtype),u=xJ({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class j0{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const G0={kernelName:Qv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=LN(s.shape,a.shape,i,o,"NHWC",l);let c;const h=new j0(u);c=n.runWebGLProgram(h,[s,a],"float32");const d=xJ({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}};const H0={kernelName:nw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=_$(s,a.length);R$(i.length,l,a);const{path:u,steps:c}=$$(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=A$(p,l[e]);let s;O$(t)?s=a[e]:(s=RJ({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Ib(s.shape,i)||(s=xJ({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=vJ({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=_J({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},q0=hJ({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),K0={kernelName:rw,backendName:"webgl",kernelFunc:q0},X0={kernelName:sw,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=ev().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ZQ("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new QQ("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},Y0=dJ({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:VY}),Q0={kernelName:iw,backendName:"webgl",kernelFunc:Y0},J0=hJ({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${h$};\n  float a1 = ${d$};\n  float a2 = ${p$};\n  float a3 = ${f$};\n  float a4 = ${m$};\n  float a5 = ${g$};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Z0={kernelName:aw,backendName:"webgl",kernelFunc:J0},e1=hJ({opSnippet:cJ+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:WY,dtype:"float32"}),t1={kernelName:ow,backendName:"webgl",kernelFunc:e1};function n1(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(wb(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),xJ({inputs:{x:a},backend:r,attrs:{shape:o}})}const r1={kernelName:lw,backendName:"webgl",kernelFunc:n1},s1="return exp(x) - 1.0;",a1=hJ({opSnippet:s1,packedOpSnippet:s1,cpuKernelImpl:jY}),i1={kernelName:uw,backendName:"webgl",kernelFunc:a1};class o1{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function l1(e,t,n){const r=n.texData.get(e.dataId),s=Sb(e.shape),a=e.shape[e.shape.length-1],i=xJ({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new o1("real",o,t),u=new o1("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=nJ({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=xJ({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const u1={kernelName:cw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return l1(r,!1,n)}};class c1{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function h1(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Pb(s),"string"===a){const e=Ob(a,Sb(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new c1(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const d1={kernelName:hw,backendName:"webgl",kernelFunc:h1};class p1{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const f1={kernelName:dw,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,s=n,a=new p1(r.shape);return s.runWebGLProgram(a,[r],r.dtype)}},m1="return floor(x);",g1=hJ({opSnippet:m1,packedOpSnippet:m1,cpuKernelImpl:GY}),y1={kernelName:pw,backendName:"webgl",kernelFunc:g1},b1=dJ({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),v1={kernelName:fw,backendName:"webgl",kernelFunc:b1};class w1{constructor(e){this.variableNames=["A"];const t=HX(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class x1{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=HX(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const k1={kernelName:hk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,a];if(o||i){const e=ev().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=S1&&e===I1||(I1=e,S1=document.createElement("canvas").getContext("2d",{willReadFrequently:I1})),S1.canvas.width=l,S1.canvas.height=u,S1.drawImage(s,0,0,l,u),s=S1.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=fX.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=ev().getBool("WEBGL_PACK")?new x1(h):new w1(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let S1,I1=ev().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const T1={kernelName:fk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=XN(c),g=zN(s.shape,a.shape,l,h,u,d,!1,m);let y;const b=[],v=null!=i,w=null!=o,x="leakyrelu"===p,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=xJ({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),w&&e.push(t(o,c)),x){const t=n.makeTensorInfo([],"float32",Uk(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&ev().getBool("WEBGL_EXP_CONV")){const e=p?pJ(p,!0):null,t=new r0(g,v,e,w,x),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",r)}else if(ev().getBool("WEBGL_CONV_IM2COL"))y=o0({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?pJ(p,!1):null,t=new t0(g,v,e,w,x),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=i0({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=xJ({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const N1={kernelName:mk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),wb(qN(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=zN(s.shape,a.shape,l,m,u,h,!0),y=ev().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?pJ(d,y):null,v=[s,a],w=null!=i,x=null!=o,k="leakyrelu"===d;if(w&&v.push(i),x&&v.push(o),k){const e=n.makeTensorInfo([],"float32",Uk(p,"float32"));v.push(e),f.push(e)}let S;S=y?new L0(g,w,b,x,k):new F0(g,w,b,x,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),T}};class E1{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=uY(n.length);let a="\n    int index;";for(let i=0;i<this.sliceDim;i++)a+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const C1={kernelName:yw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Sb(r.shape),[l,u,c,h]=l$(r,s),d=xJ({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=xJ({inputs:{x:r},backend:n,attrs:{shape:[Sb(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=HY(e,t,r.dtype,u,i,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new E1(i,h,[u,c],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=xJ({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class _1{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=uY(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function A1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Ab(i,s.shape)[0];if(ev().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[l];for(let n=0;n<e.length;++n){const r=e[n];wb(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=Y$(s,a,l,o),c=Sb(a.shape),h=[],d=xJ({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=xJ({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),r=qY(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new _1(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=xJ({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const R1={kernelName:gw,backendName:"webgl",kernelFunc:A1},$1=dJ({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:KY,dtype:"bool"}),O1={kernelName:bw,backendName:"webgl",kernelFunc:$1},D1=dJ({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:XY}),F1={kernelName:vw,backendName:"webgl",kernelFunc:D1};const L1={kernelName:xw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return l1(r,!0,n)}},M1=hJ({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),P1={kernelName:Sw,backendName:"webgl",kernelFunc:M1},z1=hJ({opSnippet:"return float(isinf(x));",dtype:"bool"}),B1={kernelName:Iw,backendName:"webgl",kernelFunc:z1},U1=hJ({opSnippet:"return float(isnan(x));",dtype:"bool"}),V1={kernelName:Tw,backendName:"webgl",kernelFunc:U1},W1=dJ({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:YY,dtype:"bool"}),j1={kernelName:Ew,backendName:"webgl",kernelFunc:W1},G1=dJ({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:QY,dtype:"bool"}),H1={kernelName:Cw,backendName:"webgl",kernelFunc:G1};const q1={kernelName:_w,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=JY(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},K1=hJ({opSnippet:cJ+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:ZY}),X1={kernelName:Aw,backendName:"webgl",kernelFunc:K1},Y1=hJ({opSnippet:cJ+"\n  return log(1.0 + x);\n"}),Q1={kernelName:Rw,backendName:"webgl",kernelFunc:Y1},J1=dJ({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Z1={kernelName:$w,backendName:"webgl",kernelFunc:J1},e2=hJ({opSnippet:"return float(!(x >= 1.0));"}),t2={kernelName:Ow,backendName:"webgl",kernelFunc:e2},n2=dJ({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),r2={kernelName:Dw,backendName:"webgl",kernelFunc:n2};class s2{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class a2{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const i2={kernelName:Fw,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=ev().getBool("WEBGL_PACK_NORMALIZATION")?new a2(s.shape,a,i,o,l):new s2(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class o2{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const l2={kernelName:Lw,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new o2(s.shape,o,l,u,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)}};function u2(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Ab(a,s.shape);let u=l;const c=YE(u,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=CQ(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype);n.texData.get(p.dataId).values=r}else p=CJ(s,c,n);u=JE(u.length,o)}XE("max",u,o);const[f,m]=qE(p.shape,u);let g,y=f;if(i&&(y=KE(f,l)),d){const e=n.texData.get(p.dataId).values,t=eQ(e,Sb(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=Sb(t),a=xJ({inputs:{x:e},attrs:{shape:[Sb(e.shape)/s,s]},backend:r}),i=TJ(a,e.dtype,"max",r),o=xJ({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const c2={kernelName:Mw,backendName:"webgl",kernelFunc:u2},h2=dJ({opSnippet:YQ+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+JQ+"\n  return result;\n",cpuKernelImpl:tQ}),d2={kernelName:Pw,backendName:"webgl",kernelFunc:h2};const p2={kernelName:zw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;jX(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;wb(qN(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=MN(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Ib(u.inShape,u.outShape))return eJ({inputs:{x:s},backend:n});const c=new dZ(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}};const f2={kernelName:Uw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=PN(s.shape,a,i,[1,1,1],o,u,l),h=new pZ(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class m2{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class g2{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const y2={kernelName:Vw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=PN(i.shape,o,l,[1,1,1],u,c),d=new pZ(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new g2(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const b2={kernelName:Bw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;jX([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=MN(o.shape,l,u,1,c,h),p=new dZ(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new m2(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const v2={kernelName:Ww,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;wb(4===s.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));const c=[1,1];wb(qN(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=MN(s.shape,a,i,c,o),[d,p]=function(e,t,n,r){let s=new dZ(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new dZ(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(s,l,h,u);return[d,p]}};const w2={kernelName:jw,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{keepDims:a,axis:i}=n,o=r,l=s.shape.length,u=Ab(i,s.shape);let c=u;const h=YE(c,l),d=null!=h,p=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(d){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=s.shape[h[r]];const n=CQ(e,s.shape,s.dtype,h,t);m=o.makeTensorInfo(t,s.dtype);o.texData.get(m.dataId).values=n}else m=CJ(s,h,o);f.push(m),c=JE(c.length,l)}XE("sum",c,l);const[g,y]=qE(m.shape,c);let b=g;a&&(b=KE(g,u));const v=function(e,t,n,r){const s=Sb(t),a=xJ({inputs:{x:e},attrs:{shape:[Sb(e.shape)/s,s]},backend:r}),i=TJ(a,"float32","mean",r),o=xJ({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const w of f)o.disposeIntermediateTensorInfo(w);return v}};const x2={kernelName:Gw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ab(a,s.shape);let u=l;const c=YE(u,o);let h=s;null!=c&&(h=RJ({inputs:{x:s},backend:n,attrs:{perm:c}}),u=JE(u.length,s.shape.length)),XE("min",u,o);const[d,p]=qE(h.shape,u),f=xJ({inputs:{x:h},backend:n,attrs:{shape:[-1,Sb(p)]}}),m=TJ(f,f.dtype,"min",n);let g;if(i){g=xJ({inputs:{x:m},backend:n,attrs:{shape:KE(d,l)}})}else g=xJ({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},k2=dJ({opSnippet:YQ+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+JQ+"\n  return result;\n",cpuKernelImpl:nQ}),S2={kernelName:Hw,backendName:"webgl",kernelFunc:k2};class I2{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=uY(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class T2{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=uY(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=RQ("rc",r),l=RQ("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const N2={kernelName:qw,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s}=t,{paddings:a,mode:i}=r,o=ev().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new T2(s.shape,a,i):new I2(s.shape,a,i);return n.runWebGLProgram(o,[s],s.dtype)}},E2=dJ({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+JQ+"\n  return result;\n"}),C2={kernelName:Kw,backendName:"webgl",kernelFunc:E2};class _2{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const A2=dJ({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),R2={kernelName:tw,backendName:"webgl",kernelFunc:A2},$2="return a - b;",O2=dJ({opSnippet:$2,packedOpSnippet:$2,supportsComplex:!0,cpuKernelImpl:TQ}),D2={kernelName:Zx,backendName:"webgl",kernelFunc:O2};function F2(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Ab([a],s.shape),o=u2({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=KE(o.shape,i),u=xJ({inputs:{x:o},backend:n,attrs:{shape:l}}),c=O2({inputs:{a:s,b:u},backend:n}),h=e1({inputs:{x:c},backend:n}),d=_J({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=xJ({inputs:{x:d},backend:n,attrs:{shape:l}}),f=A2({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const L2={kernelName:Bx,backendName:"webgl",kernelFunc:F2};const M2={kernelName:Xw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:F2({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new _2(u,c,a),d=[[i]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},P2=zQ+"\n  return -x;\n";const z2={kernelName:Qw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=sQ(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=ev().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jQ(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new PQ(r.shape,P2),n.runWebGLProgram(s,[r],r.dtype)}},B2=ZA;const U2={kernelName:Zw,backendName:"webgl",kernelFunc:function(e){gk("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=B2(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},V2=eR;const W2={kernelName:ex,backendName:"webgl",kernelFunc:function(e){gk("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=V2(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},j2=tR;const G2={kernelName:tx,backendName:"webgl",kernelFunc:function(e){gk("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=j2(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class H2{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const q2={kernelName:rx,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Sb(s.shape),c=new H2(u,i,o,l),h=xJ({inputs:{x:s},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],a);n.disposeIntermediateTensorInfo(h);const p=xJ({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function K2(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=FZ({inputs:{input:r},backend:n}),t=K2({inputs:{x:e},backend:n}),s=YZ({inputs:{input:r},backend:n}),a=K2({inputs:{x:s},backend:n}),i=nJ({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return h1({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const X2={kernelName:uk,backendName:"webgl",kernelFunc:K2};const Y2={kernelName:nx,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=FZ({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=YZ({inputs:{input:s},backend:r}),i=K2({inputs:{x:a},backend:r}),o=nJ({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return h1({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const Q2={kernelName:sx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return n1({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{xb(a,e.shape,"All tensors passed to stack must have matching shapes"),wb(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=ZZ({inputs:t.map((e=>{const t=n1({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class J2{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=uY(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Z2{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=uY(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=RQ("rc",r),l=RQ("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const e3=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===Sb(s.shape)){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return h1({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=ev().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Z2(s.shape,a,i):new J2(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},t3={kernelName:ax,backendName:"webgl",kernelFunc:e3},n3=dJ({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+JQ+"\n  return result;\n"}),r3={kernelName:ix,backendName:"webgl",kernelFunc:n3};const s3={kernelName:lx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Ab(a,s.shape);let c=u;const h=YE(c,o);let d,p=s;if(null!=h&&(p=RJ({inputs:{x:s},backend:n,attrs:{perm:h}}),c=JE(c.length,o),l.push(p)),XE("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=iQ(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=qE(p.shape,c),r=Sb(t),a=xJ({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=TJ(a,gS(s.dtype),"prod",n);d=xJ({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(d);const e=KE(d.shape,u);d=xJ({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const a3={kernelName:ux,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.readSync(e.dataId))),u=s.map((e=>e.shape)),c=n.readSync(a.dataId),h=n.readSync(i.dataId),[d,p,f]=oQ(l,u,c,a.shape,a.dtype,h,i.shape,o),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}};const i3={kernelName:cx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=lQ(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const o3={kernelName:hx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId),d=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=uQ(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,m)}},l3=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=cQ(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},u3={kernelName:dx,backendName:"webgl",kernelFunc:l3},c3=hJ({opSnippet:"return 1.0 / x;"}),h3={kernelName:fx,backendName:"webgl",kernelFunc:c3},d3=hJ({opSnippet:zQ+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),p3={kernelName:mx,backendName:"webgl",kernelFunc:d3},f3=hJ({opSnippet:zQ+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),m3={kernelName:xx,backendName:"webgl",kernelFunc:f3};class g3{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class y3{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const b3={kernelName:vx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=ev().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new y3(s.shape,l,u,a,i):new g3(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class v3{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const w3={kernelName:wx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new v3(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class x3{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class k3{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const S3={kernelName:yx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=ev().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new k3(s.shape,l,u,a,i):new x3(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class I3{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const T3={kernelName:bx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new I3(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class N3{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=uY(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class E3{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=RQ("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=uY(n);function o(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const C3={kernelName:kx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Ab(a,s.shape);if(0===i)return eJ({inputs:{x:s},backend:n});const l=ev().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new E3(s.shape,o):new N3(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class _3{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const A3={kernelName:dk,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,l=r,u=new _3(s.shape,i),[c,h]=n$(o,s.shape[1],s.shape[2]),d=[[c,h,Math.sin(a),Math.cos(a)]];return l.runWebGLProgram(u,[s],s.dtype,d)}},R3=hJ({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),$3={kernelName:Sx,backendName:"webgl",kernelFunc:R3},O3=hJ({opSnippet:"return inversesqrt(x);",cpuKernelImpl:hQ}),D3={kernelName:Ix,backendName:"webgl",kernelFunc:O3};class F3{constructor(e,t,n,r,s,a){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=uY(s.length),l=uY(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class L3{constructor(e,t,n,r,s,a){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const o=uY(s.length),l=uY(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${d};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const M3={kernelName:Tx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=uA(0,s,i),d=[h/u,u];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=xJ({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=xJ({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=ev().getBool("WEBGL_PACK")?new L3(l,o,p.shape.length,f.shape.length,c,d):new F3(l,o,p.shape.length,f.shape.length,c,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=xJ({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class P3{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===ev().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const z3={kernelName:Ex,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new P3(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class B3{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=uY(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const U3={kernelName:Cx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new B3(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],mS(s.dtype,a.dtype))}},V3=hJ({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${u$};\n  float scale = ${c$};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),W3={kernelName:_x,backendName:"webgl",kernelFunc:V3},j3=hJ({opSnippet:cJ+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:pQ}),G3={kernelName:Dx,backendName:"webgl",kernelFunc:j3},H3=hJ({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),q3={kernelName:Ox,backendName:"webgl",kernelFunc:H3},K3=hJ({opSnippet:cJ+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${JQ}\n  return result;\n`}),X3={kernelName:Rx,backendName:"webgl",kernelFunc:K3},Y3=hJ({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Q3={kernelName:$x,backendName:"webgl",kernelFunc:Y3},J3=hJ({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Z3={kernelName:Fx,backendName:"webgl",kernelFunc:J3},e4={kernelName:Px,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;wb(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=e3({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=r$(c.shape,a,o,!1),d=s$(h.length,a.length,!1),p=a$(c.shape,a,o,!1),f=xJ({inputs:{x:c},backend:n,attrs:{shape:h}}),m=RJ({inputs:{x:f},backend:n,attrs:{perm:d}}),g=xJ({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const t4={kernelName:Ux,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=gQ(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const n4={kernelName:Vx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,h]=yQ(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}};const r4={kernelName:Wx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=bQ(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const s4={kernelName:jx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=bQ(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const a4={kernelName:Gx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=uA(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=Gk(n.readSync(i.dataId)[0]),f=dQ(e,t,o,d,c,u,l,h,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new F3(u,l,s.shape.length,a.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=xJ({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const i4={kernelName:zx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Ab(i,s.shape)[0],l=F$(s,a,o),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map((e=>{const t=[...h];t[o]=e;const r=EZ({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},o4="return sqrt(x);",l4=hJ({opSnippet:o4,packedOpSnippet:o4,cpuKernelImpl:vQ}),u4={kernelName:Lx,backendName:"webgl",kernelFunc:l4},c4={kernelName:qx,backendName:"webgl",kernelFunc:hJ({opSnippet:"return x * x;"})},h4="return (a - b) * (a - b);",d4=dJ({opSnippet:h4,packedOpSnippet:h4}),p4={kernelName:Hx,backendName:"webgl",kernelFunc:d4};const f4={kernelName:Kx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=Q$(n.readSync(s.dataId)),i=wQ(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}};const m4={kernelName:ck,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,a=zQ+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new PQ(s.shape,a);return r.runWebGLProgram(i,[s],s.dtype)}};class g4{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=uY(n.length),a=uY(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const y4={kernelName:Xx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:w}=kN(s.shape,a,i,o,l,u,c,h,d);let x;if(m)x=xJ({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){wb(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=uN(b,v,w),t=EZ({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});x=xJ({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=eT(s.shape,s.dtype,e),r=xQ(p,t,w,b);x=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new g4(b,w,p);x=n.runWebGLProgram(e,[s],s.dtype)}}const k=xJ({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),k}};const b4={kernelName:Yx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=kQ(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const v4={kernelName:Qx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=SQ(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const w4={kernelName:Jx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=IQ(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},x4=hJ({opSnippet:"return tan(x);"}),k4={kernelName:ek,backendName:"webgl",kernelFunc:x4},S4=hJ({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),I4={kernelName:tk,backendName:"webgl",kernelFunc:S4};const T4={kernelName:Nx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=uA(0,a,s.shape),d=[h/u,u];if(0===h)return n.makeTensorInfo(s.shape,a.dtype);const p=xJ({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=xJ({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=xJ({inputs:{x:s},backend:n,attrs:{shape:d}}),g=new F3(l,o,p.shape.length,f.shape.length,c,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=xJ({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class N4{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const r=uY(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function E4(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>Gk(e))):e,r=eT(s.shape,s.dtype,t),i=NQ(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new N4(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const C4={kernelName:nk,backendName:"webgl",kernelFunc:E4};class _4{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class A4{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function R4(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function $4(e){let t=1;for(;t<e;)t*=2;return t}const O4={kernelName:rk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=ev().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ev().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const e=n.readSync(s.dataId),[t,r]=EQ(e,u,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,h1({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=Sb(u)/c,m=xJ({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&R4(n,p);const g=$4(a),y=$4(c);let b=null;const v=()=>null===b?[m,m]:[m,b],w=(e,t,r)=>{const s=v(),a=new _4(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(a,s,"int32",i),R4(n,o)};for(let T=1;T<g;T*=2){const e=2*T;for(let t=T;t>=1;t/=2)w(e,t,[f,y])}for(let T=y;T>g;T/=2){const e=v(),t=new A4([f,T/2]),r=[[c],[null===b?1:0],[g]],s=b;b=n.runWebGLProgram(t,e,"int32",r),R4(n,s);const a=g/2,i=2*a;for(let n=a;n>=1;n/=2)w(i,n,b.shape)}let x=b;b=EZ({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),R4(n,x);let k=A1({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});R4(n,m);const S=u.slice(0,-1);S.push(a),x=b,b=xJ({inputs:{x:b},attrs:{shape:S},backend:n}),R4(n,x);const I=k;return k=xJ({inputs:{x:k},attrs:{shape:S},backend:n}),R4(n,I),[k,b]}};class D4{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const F4={kernelName:sk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=new D4(h,d,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}};const L4={kernelName:ik,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;jX(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=_Q(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const M4={kernelName:ok,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[a]=m;const e=EZ({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=xJ({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class P4{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const z4={kernelName:lk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=YE([u],o);let h=s;null!=c&&(h=RJ({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=JE(1,o)[0]);const d=X$(h.shape,u,i),p=Sb([h.shape[u]]),f=xJ({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=gS(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=K$(o,a),c=new P4({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,r],s);if(l.push(h),h.shape[1]===a)return h;const d=l3({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=E4({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});l.push(d),l.push(p);return g(h,t,p,s,a)},y=xJ({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:d}});let b=y;if(null!=c){l.push(y);const e=QE(c);b=RJ({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},B4=[DJ,LJ,PJ,BJ,WJ,HJ,qJ,KJ,eZ,tZ,rZ,aZ,oZ,uZ,hZ,fZ,mZ,bZ,vZ,wZ,SZ,_Z,AZ,RZ,$Z,MZ,BZ,WZ,rJ,HZ,e0,l0,p0,m0,g0,y0,b0,w0,k0,I0,A0,R0,$0,D0,M0,B0,U0,W0,G0,H0,K0,X0,Q0,Z0,t1,r1,i1,u1,d1,f1,y1,v1,k1,T1,N1,C1,R1,O1,F1,tJ,L1,QZ,P1,B1,V1,iJ,j1,H1,q1,X1,Q1,Z1,t2,r2,i2,l2,c2,d2,p2,f2,y2,b2,v2,w2,x2,S2,N2,C2,M2,wJ,z2,U2,W2,G2,DZ,q2,Y2,Q2,t3,r3,uJ,s3,a3,i3,o3,u3,LZ,R2,h3,p3,m3,kJ,b3,w3,S3,T3,C3,A3,$3,D3,M3,z3,U3,W3,G3,q3,X3,Q3,CZ,L2,Z3,e4,t4,n4,r4,s4,a4,i4,u4,c4,p4,f4,m4,y4,b4,v4,w4,D2,AJ,k4,I4,T4,C4,O4,F4,$J,L4,M4,z4,X2];for(const n of B4)Sk(n);const U4={container:{padding:"20px",backgroundColor:"#F5F5F5",borderRadius:"8px",boxShadow:"0 2px 10px rgba(0, 0, 0, 0.1)",margin:"20px"},titleContainer:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"20px"},title:{marginBottom:"20px"},betaBadge:{backgroundColor:"#FF4081",color:"white",padding:"4px 8px",borderRadius:"4px",fontSize:"14px",fontWeight:"bold",textTransform:"uppercase",letterSpacing:"1px",boxShadow:"0 2px 4px rgba(255, 64, 129, 0.2)"},videoContainer:{width:"100%",maxWidth:"640px",height:"480px",margin:"20px auto",backgroundColor:"#000",borderRadius:"8px",overflow:"hidden",position:"relative"},video:{width:"100%",height:"100%",objectFit:"cover",transform:"scaleX(-1)",backgroundColor:"#000"},placeholder:{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",color:"#fff",fontSize:"20px",textAlign:"center",zIndex:1},prediction:{fontSize:"24px",fontWeight:"bold",textAlign:"center"},loading:{textAlign:"center",padding:"20px",fontSize:"18px"},error:{color:"red",textAlign:"center",padding:"20px",fontSize:"18px"},confidence:{fontSize:"18px",marginTop:"10px",color:"#666"},controls:{display:"flex",gap:"10px",justifyContent:"center",marginTop:"20px"},controlButton:{padding:"10px 20px",fontSize:"16px",backgroundColor:"#4CAF50",color:"white",border:"none",borderRadius:"4px",cursor:"pointer"},canvas:{display:"none"},timer:{fontSize:"16px",marginTop:"8px",color:"#666",fontWeight:"normal"},bufferInfo:{fontSize:"14px",marginTop:"8px",color:"#666",fontStyle:"italic"},predictionInfo:{fontSize:"16px",fontWeight:"normal",marginTop:"10px",padding:"10px",backgroundColor:"rgba(0,0,0,0.05)",borderRadius:"4px"},stabilityIndicator:{fontSize:"14px",color:"#666",marginTop:"5px",fontStyle:"italic"},predictionContainer:{width:"100%",maxWidth:"640px",margin:"20px auto",minHeight:"200px",backgroundColor:"#fff",borderRadius:"8px",padding:"20px",boxShadow:"0 2px 10px rgba(0, 0, 0, 0.1)"},predictionBox:{display:"flex",flexDirection:"column",gap:"15px"},predictionHeader:{fontSize:"18px",fontWeight:"bold",padding:"10px 0",borderBottom:"1px solid #eee"},predictionInfo:{display:"grid",gridTemplateColumns:"repeat(2, 1fr)",gap:"15px",fontSize:"16px","& > div":{padding:"8px",backgroundColor:"#f5f5f5",borderRadius:"4px"}},disclaimerOverlay:{position:"fixed",top:0,left:0,right:0,bottom:0,backgroundColor:"rgba(0, 0, 0, 0.7)",display:"flex",justifyContent:"center",alignItems:"center",zIndex:1e3},disclaimerModal:{backgroundColor:"white",borderRadius:"8px",padding:"24px",maxWidth:"500px",width:"90%",maxHeight:"90vh",overflow:"auto",boxShadow:"0 4px 20px rgba(0, 0, 0, 0.2)"},disclaimerTitle:{fontSize:"24px",marginBottom:"16px",color:"#333"},disclaimerText:{fontSize:"16px",lineHeight:"1.5",marginBottom:"16px",color:"#666"},disclaimerList:{marginBottom:"24px",paddingLeft:"24px",color:"#666","& li":{marginBottom:"8px"}},disclaimerButton:{backgroundColor:"#2196F3",color:"white",border:"none",borderRadius:"4px",padding:"12px 24px",fontSize:"16px",cursor:"pointer",transition:"background-color 0.2s","&:hover":{backgroundColor:"#1976D2"}}},V4=()=>{const e=(0,_.useRef)(null),t=(0,_.useRef)(null),[n,r]=(0,_.useState)(null),[s,a]=(0,_.useState)(""),[i,o]=(0,_.useState)(0),[l,u]=(0,_.useState)(!0),[c,h]=(0,_.useState)(null),[d,p]=(0,_.useState)(!1),[f,m]=(0,_.useState)(""),[g,y]=(0,_.useState)({letter:"",startTime:null}),b=(0,_.useRef)(null),v=(0,_.useRef)(null),[w,x]=(0,_.useState)(!1),[k,S]=(0,_.useState)(""),[I,T]=((0,_.useRef)(null),(0,_.useState)(4)),[N,E]=(0,_.useState)([]),[C,A]=(0,_.useState)(!1),R=(0,_.useRef)(null),[$,O]=(0,_.useState)(!0),D=224;(0,_.useEffect)((()=>(document.body.style.overflow=$?"hidden":"unset",()=>{document.body.style.overflow="unset"})),[$]);const F=async()=>{try{const t=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:"user"}});e.current&&(e.current.srcObject=t,e.current.onloadedmetadata=()=>{e.current.play().then((()=>{console.log("Video playback started"),p(!0)})).catch((e=>{console.error("Error playing video:",e),h("Failed to start video playback")}))},v.current=t)}catch(n5){console.error("Error accessing camera:",n5),h("Error accessing camera: "+n5.message)}},L=()=>{if(v.current){v.current.getTracks().forEach((e=>{e.stop(),v.current.removeTrack(e)})),v.current=null}e.current&&(e.current.srcObject=null,e.current.load()),p(!1),x(!1),b.current&&(cancelAnimationFrame(b.current),b.current=null)},M=()=>{if(N.length>0){const e=N.reduce(((e,t)=>{let{letter:n,confidence:r}=t;return e[n]||(e[n]=[]),e[n].push(r),e}),{}),t=Object.entries(e).map((e=>{let[t,n]=e;const r=n.reduce(((e,t)=>e+t),0)/n.length;return{letter:t,score:r*(n.length/N.length)*n.length}}));t.sort(((e,t)=>t.score-e.score));const n=t[0];n&&n.score>.3&&S((e=>e.slice(-1)!==n.letter?e+n.letter:e))}E([]),A(!1),k.length>0&&(m((e=>e+(e?" ":"")+k)),S(""))};(0,_.useEffect)((()=>{let e;return C&&(e=setInterval((()=>{T((e=>e<=1?4:e-1))}),1e3)),()=>{e&&clearInterval(e),R.current&&clearTimeout(R.current)}}),[C]);const P=()=>{const r=async()=>{var s;if(4===(null===(s=e.current)||void 0===s?void 0:s.readyState)){const r=e.current.videoWidth,s=e.current.videoHeight;t.current.width=D,t.current.height=D;t.current.getContext("2d").drawImage(e.current,0,0,r,s,0,0,D,D);try{let e=sN(t.current).div(255).expandDims(0);const r=n.predict(e),s=r.dataSync(),i=Math.max(...s),l=s.indexOf(i);a(String.fromCharCode(65+l)),o(i),((e,t)=>{t>.7&&(E((n=>[...n,{letter:e,confidence:t}])),C||(A(!0),T(4),R.current=setTimeout((()=>{M()}),4e3)))})(String.fromCharCode(65+l),i),e.dispose(),r.dispose()}catch(n5){console.error("Prediction error:",n5)}}b.current=requestAnimationFrame(r)};r()};(0,_.useEffect)((()=>{(async()=>{try{u(!0);const e=`${"/Translator"}/models/model_asl/model.json`;console.log("Attempting to load model from:",e);const t=await fetch(e);if(console.log("Model response status:",t.status),console.log("Model response headers:",Object.fromEntries(t.headers)),!t.ok)throw new Error(`HTTP error! status: ${t.status}`);const n=await t.text();console.log("First 100 characters of response:",n.substring(0,100));const s=JSON.parse(n);console.log("Model metadata loaded:",{format:s.format,generatedBy:s.generatedBy});const a=await JU(e,{onProgress:e=>{console.log(`Loading model: ${(100*e).toFixed(1)}%`)}});r(a),u(!1),console.log("Model loaded successfully");try{await F(),console.log("Camera initialized successfully")}catch(n5){console.error("Failed to initialize camera:",n5),h("Failed to initialize camera: "+n5.message)}}catch(n5){console.error("Detailed loading error:",n5),h(`Failed to load ASL model: ${n5.message}\n${n5.stack}`),u(!1)}})()}),[]),(0,_.useEffect)((()=>()=>{L(),n&&n.dispose(),GS().reset()}),[]),(0,_.useEffect)((()=>()=>{R.current&&clearTimeout(R.current)}),[]);return(0,mm.jsxs)("div",{style:U4.container,children:[(0,mm.jsxs)("div",{style:U4.titleContainer,children:[(0,mm.jsx)("h1",{style:U4.title,children:"GlobeTalk Sign Language"}),(0,mm.jsx)("span",{style:U4.betaBadge,children:"BETA"})]}),$&&(0,mm.jsx)("div",{style:U4.disclaimerOverlay,children:(0,mm.jsxs)("div",{style:U4.disclaimerModal,children:[(0,mm.jsx)("h3",{style:U4.disclaimerTitle,children:"Beta Feature Disclaimer"}),(0,mm.jsx)("p",{style:U4.disclaimerText,children:"This Sign Language Detection feature is currently in beta testing. The model is still being improved and may not generate the most accurate results. Please be aware that:"}),(0,mm.jsxs)("ul",{style:U4.disclaimerList,children:[(0,mm.jsx)("li",{children:"Translations may not be 100% accurate"}),(0,mm.jsx)("li",{children:"The model works best in good lighting conditions"}),(0,mm.jsx)("li",{children:"Some signs may not be recognized correctly"}),(0,mm.jsx)("li",{children:"Performance may vary across different devices"})]}),(0,mm.jsx)("button",{onClick:()=>O(!1),style:U4.disclaimerButton,children:"I Understand"})]})}),l&&(0,mm.jsx)("div",{style:U4.loading,children:"Loading model..."}),c&&(0,mm.jsx)("div",{style:U4.error,children:c}),(0,mm.jsxs)("div",{style:U4.videoContainer,children:[(0,mm.jsx)("video",{ref:e,style:U4.video,autoPlay:!0,playsInline:!0,muted:!0}),!d&&(0,mm.jsx)("div",{style:U4.placeholder,children:"Waiting for camera..."}),(0,mm.jsx)("canvas",{ref:t,style:U4.canvas})]}),(0,mm.jsxs)("div",{style:U4.controls,children:[(0,mm.jsx)("button",{onClick:d?L:F,style:{...U4.controlButton,backgroundColor:"#2196F3"},children:d?"Stop Stream":"Start Stream"}),d&&(0,mm.jsx)("button",{onClick:()=>{w?(x(!1),b.current&&cancelAnimationFrame(b.current)):(x(!0),P())},style:{...U4.controlButton,backgroundColor:w?"#ff4444":"#4CAF50"},children:w?"Stop Detection":"Start Detection"}),w&&(0,mm.jsx)("button",{onClick:()=>{m((e=>e+(e?" ":""))),S(""),E([]),A(!1),R.current&&clearTimeout(R.current)},style:{...U4.controlButton,backgroundColor:"#FFA500"},children:"Add Space"})]}),w&&(0,mm.jsx)("div",{style:U4.predictionContainer,children:(0,mm.jsxs)("div",{style:U4.predictionBox,children:[(0,mm.jsxs)("div",{style:U4.predictionHeader,children:["Current Word: ",k]}),(0,mm.jsxs)("div",{style:U4.predictionInfo,children:[(0,mm.jsxs)("div",{children:["Detected Letter: ",s||"-"]}),(0,mm.jsxs)("div",{children:["Confidence: ",i?`${(100*i).toFixed(1)}%`:"0%"]}),(0,mm.jsxs)("div",{children:["Collection Status: ",C?"Collecting":"Waiting"]}),(0,mm.jsxs)("div",{children:["Samples: ",N.length]}),(0,mm.jsxs)("div",{children:["Time: ",I,"s"]}),(0,mm.jsxs)("div",{children:["Stability: ",(N.length>0?new Set(N.map((e=>e.letter))).size/N.length:0).toFixed(2)]})]})]})}),f&&(0,mm.jsxs)("div",{style:U4.detectedText,children:[(0,mm.jsx)("h3",{children:"Detected Text:"}),(0,mm.jsx)("p",{children:f})]})]})},W4=(0,fm.A)((0,mm.jsx)("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39"}),"Public"),j4=(0,fm.A)((0,mm.jsx)("path",{d:"m12.87 15.07-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2zm-2.62 7 1.62-4.33L19.12 17z"}),"TranslateOutlined"),G4=(0,fm.A)([(0,mm.jsx)("path",{d:"M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3"},"0"),(0,mm.jsx)("path",{d:"M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92z"},"1")],"MicOutlined"),H4=(0,fm.A)((0,mm.jsx)("path",{d:"M19 5v14H5V5zm0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-4.86 8.86-3 3.87L9 13.14 6 17h12z"}),"ImageOutlined"),q4=(0,fm.A)((0,mm.jsx)("path",{d:"M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9m-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8z"}),"HistoryOutlined"),K4=(0,fm.A)((0,mm.jsx)("path",{d:"m17 7-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4z"}),"Logout"),X4={navbar:{backgroundColor:pm.colors.surface,boxShadow:pm.shadows.sm,position:"sticky",top:0,zIndex:100,borderBottom:`1px solid ${pm.colors.border}`},content:{maxWidth:"1200px",margin:"0 auto",padding:`${pm.spacing.md} ${pm.spacing.xl}`,display:"flex",justifyContent:"space-between",alignItems:"center"},logo:{fontSize:pm.typography.sizes.xl,fontWeight:"700",color:pm.colors.primary,textDecoration:"none",letterSpacing:"-0.025em",display:"flex",alignItems:"center",gap:pm.spacing.xs},logoIcon:{fontSize:"24px",color:pm.colors.primary},logoText:{background:`linear-gradient(135deg, ${pm.colors.primary}, #2563eb)`,WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent"},rightSection:{display:"flex",alignItems:"center",gap:pm.spacing.xl},links:{display:"flex",gap:pm.spacing.lg},link:{display:"flex",alignItems:"center",gap:pm.spacing.sm,color:pm.colors.text.secondary,textDecoration:"none",padding:`${pm.spacing.sm} ${pm.spacing.md}`,borderRadius:pm.borderRadius.md,transition:"all 0.2s cubic-bezier(0.4, 0, 0.2, 1)",fontSize:pm.typography.sizes.sm,position:"relative",backgroundColor:"transparent","&:hover":{transform:"translateY(-2px)",backgroundColor:`${pm.colors.primary}15`,color:pm.colors.primary,boxShadow:"0 4px 8px rgba(59, 130, 246, 0.15)"},"&:active":{transform:"translateY(0)"}},activeLink:{backgroundColor:`${pm.colors.primary}20`,color:pm.colors.primary,transform:"translateY(-2px)",boxShadow:"0 4px 8px rgba(59, 130, 246, 0.15)","&:hover":{backgroundColor:`${pm.colors.primary}25`}},linkText:{marginLeft:pm.spacing.xs,display:"flex",alignItems:"center"},logoutButton:{display:"flex",alignItems:"center",gap:pm.spacing.sm,padding:`${pm.spacing.sm} ${pm.spacing.md}`,backgroundColor:"transparent",color:pm.colors.text.secondary,border:`1px solid ${pm.colors.border}`,borderRadius:pm.borderRadius.md,cursor:"pointer",transition:"all 0.2s ease",fontSize:pm.typography.sizes.sm,"&:hover":{backgroundColor:"#fee2e2",borderColor:"#ef4444",color:"#ef4444"}},logoutIcon:{fontSize:"20px"},betaBadge:{backgroundColor:"#FF4081",color:"white",padding:"2px 6px",borderRadius:"4px",fontSize:"10px",fontWeight:"bold",marginLeft:"6px",textTransform:"uppercase",letterSpacing:"0.5px",display:"inline-block",lineHeight:"1.2",verticalAlign:"middle",boxShadow:"0 2px 4px rgba(255, 64, 129, 0.2)"}},Y4=e=>{let{onLogout:t,isGuest:n}=e;const r=Te(),s=e=>{let{to:t,icon:n,label:s,isBeta:a}=e;return(0,mm.jsxs)(Ze,{to:t,style:{...X4.link,...(i=t,r.pathname===i&&X4.activeLink)},children:[n,(0,mm.jsxs)("span",{style:X4.linkText,children:[s,a&&(0,mm.jsx)("span",{style:X4.betaBadge,children:"BETA"})]})]});var i};return(0,mm.jsx)("nav",{style:X4.navbar,children:(0,mm.jsxs)("div",{style:X4.content,children:[(0,mm.jsxs)(Ze,{to:"/",style:X4.logo,children:[(0,mm.jsx)(W4,{style:X4.logoIcon}),(0,mm.jsx)("span",{style:X4.logoText,children:"GlobeTalk"})]}),(0,mm.jsxs)("div",{style:X4.rightSection,children:[(0,mm.jsxs)("div",{style:X4.links,children:[(0,mm.jsx)(s,{to:"/translate",icon:(0,mm.jsx)(j4,{}),label:"Text"}),(0,mm.jsx)(s,{to:"/voice-translation",icon:(0,mm.jsx)(G4,{}),label:"Voice"}),(0,mm.jsx)(s,{to:"/image-translation",icon:(0,mm.jsx)(H4,{}),label:"Image"}),(0,mm.jsx)(s,{to:"/sign-language",icon:(0,mm.jsx)(eb,{}),label:"Sign",isBeta:!0}),(0,mm.jsx)(s,{to:"/history",icon:(0,mm.jsx)(q4,{}),label:"History"})]}),(0,mm.jsxs)("button",{onClick:t,style:X4.logoutButton,children:[(0,mm.jsx)(K4,{style:X4.logoutIcon}),(0,mm.jsx)("span",{children:n?"Exit Guest Mode":"Logout"})]})]})]})})},Q4=(0,fm.A)((0,mm.jsx)("path",{d:"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"}),"Person");const J4={container:{minHeight:"100vh",display:"flex",alignItems:"center",justifyContent:"center",padding:pm.spacing.xl,backgroundColor:pm.colors.background,animation:"fadeIn 0.5s ease forwards"},card:{width:"100%",maxWidth:"400px",backgroundColor:pm.colors.surface,borderRadius:pm.borderRadius.lg,boxShadow:pm.shadows.lg,padding:pm.spacing.xxl,animation:"slideUp 0.5s ease forwards"},title:{fontSize:pm.typography.sizes["2xl"],fontWeight:"600",color:pm.colors.text.primary,textAlign:"center",marginBottom:pm.spacing.sm},subtitle:{fontSize:pm.typography.sizes.base,color:pm.colors.text.secondary,textAlign:"center",marginBottom:pm.spacing.xl},form:{display:"flex",flexDirection:"column",gap:pm.spacing.lg},inputGroup:{position:"relative",animation:"slideRight 0.5s ease forwards",animationDelay:"calc(var(--index) * 100ms)"},inputIcon:{position:"absolute",left:pm.spacing.md,top:"50%",transform:"translateY(-50%)",color:pm.colors.text.secondary,fontSize:"20px"},input:{width:"85%",padding:`${pm.spacing.md} ${pm.spacing.md} ${pm.spacing.md} ${pm.spacing.xxl}`,fontSize:pm.typography.sizes.base,border:`1px solid ${pm.colors.border}`,borderRadius:pm.borderRadius.md,outline:"none",transition:"all 0.2s ease","&:focus":{borderColor:pm.colors.primary,boxShadow:`0 0 0 2px ${pm.colors.primary}20`}},button:{width:"100%",padding:pm.spacing.md,backgroundColor:pm.colors.primary,color:pm.colors.surface,border:"none",borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.base,fontWeight:"500",cursor:"pointer",transition:"all 0.2s ease",animation:"slideUp 0.5s ease forwards",animationDelay:"0.2s","&:hover":{backgroundColor:pm.colors.primary+"dd",transform:"translateY(-1px)"}},guestButton:{width:"100%",padding:pm.spacing.md,backgroundColor:pm.colors.surface,color:pm.colors.text.primary,border:`1px solid ${pm.colors.border}`,borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.base,fontWeight:"500",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:pm.spacing.sm,transition:"all 0.2s ease",animation:"slideUp 0.5s ease forwards",animationDelay:"0.3s","&:hover":{backgroundColor:pm.colors.surfaceHover,borderColor:pm.colors.primary,transform:"translateY(-1px)"}},divider:{margin:`${pm.spacing.xl} 0`,position:"relative",textAlign:"center","&::before":{content:'""',position:"absolute",top:"50%",left:0,right:0,height:"1px",backgroundColor:pm.colors.border}},dividerText:{backgroundColor:pm.colors.surface,padding:`0 ${pm.spacing.md}`,color:pm.colors.text.secondary,position:"relative"},buttonIcon:{fontSize:"20px"},error:{display:"flex",alignItems:"center",gap:pm.spacing.sm,padding:pm.spacing.md,backgroundColor:`${pm.colors.error}10`,color:pm.colors.error,borderRadius:pm.borderRadius.md,fontSize:pm.typography.sizes.sm,animation:"shake 0.5s ease forwards"},errorIcon:{fontSize:"20px"},loginPrompt:{display:"flex",justifyContent:"center",alignItems:"center",gap:pm.spacing.sm,marginTop:pm.spacing.md,animation:"fadeIn 0.5s ease forwards",animationDelay:"0.4s"},textButton:{background:"none",border:"none",color:pm.colors.primary,cursor:"pointer",fontSize:pm.typography.sizes.base,padding:0,transition:"color 0.2s ease","&:hover":{color:pm.colors.primary+"dd",textDecoration:"underline"}}},Z4=function(e){let{onSignup:t,onToggleForm:n}=e;const[r,s]=(0,_.useState)(""),[a,i]=(0,_.useState)(""),[o,l]=(0,_.useState)("");return(0,mm.jsx)("div",{style:J4.container,children:(0,mm.jsxs)("div",{style:J4.card,children:[(0,mm.jsx)("h1",{style:J4.title,children:"Create Account"}),(0,mm.jsx)("p",{style:J4.subtitle,children:"Sign up to start using Universal Translator"}),(0,mm.jsxs)("form",{onSubmit:async e=>{e.preventDefault(),l("");try{const e=await async function(e,t,n){if(zn(e.app))return Promise.reject(hr(e));const r=gs(e),s=Ns(r,{returnSecureToken:!0,email:t,password:n,clientType:"CLIENT_TYPE_WEB"},"signUpPassword",Ks,"EMAIL_PASSWORD_PROVIDER"),a=await s.catch((t=>{throw"auth/password-does-not-meet-requirements"===t.code&&ra(e),t})),i=await Xs._fromIdTokenResponse(r,"signIn",a);return await r._updateCurrentUser(i.user),i}(dm,r,a);t(e.user)}catch(n5){l(n5.message)}},style:J4.form,children:[(0,mm.jsxs)("div",{style:J4.inputGroup,children:[(0,mm.jsx)(gm,{style:J4.inputIcon}),(0,mm.jsx)("input",{type:"email",placeholder:"Email",value:r,onChange:e=>s(e.target.value),required:!0,style:J4.input})]}),(0,mm.jsxs)("div",{style:J4.inputGroup,children:[(0,mm.jsx)(ym,{style:J4.inputIcon}),(0,mm.jsx)("input",{type:"password",placeholder:"Password",value:a,onChange:e=>i(e.target.value),required:!0,style:J4.input})]}),o&&(0,mm.jsxs)("div",{style:J4.error,children:[(0,mm.jsx)(bm,{style:J4.errorIcon}),o]}),(0,mm.jsx)("button",{type:"submit",style:J4.button,children:"Create Account"}),(0,mm.jsxs)("div",{style:J4.loginPrompt,children:[(0,mm.jsx)("span",{children:"Already have an account? "}),(0,mm.jsx)("button",{onClick:()=>n("login"),style:J4.textButton,children:"Sign in"})]})]}),(0,mm.jsx)("div",{style:J4.divider,children:(0,mm.jsx)("span",{style:J4.dividerText,children:"or"})}),(0,mm.jsxs)("button",{onClick:async()=>{l("");try{const e=await async function(e){var t;if(zn(e.app))return Promise.reject(hr(e));const n=gs(e);if(await n._initializationPromise,null===(t=n.currentUser)||void 0===t?void 0:t.isAnonymous)return new Xs({user:n.currentUser,providerId:null,operationType:"signIn"});const r=await Ks(n,{returnSecureToken:!0}),s=await Xs._fromIdTokenResponse(n,"signIn",r,!0);return await n._updateCurrentUser(s.user),s}(dm);t(e.user)}catch(n5){l(n5.message)}},style:J4.guestButton,children:[(0,mm.jsx)(Q4,{style:J4.buttonIcon}),"Continue as Guest"]})]})})};const e5=function(){const[e,t]=(0,_.useState)(null),[n,r]=(0,_.useState)("login");(0,_.useEffect)((()=>{const e=dm.onAuthStateChanged((e=>{t(e)}));return()=>e()}),[]);const s=e=>{r(e)};return(0,mm.jsx)(Ye,{basename:"/Translator",children:(0,mm.jsx)("div",{className:"App",children:e?(0,mm.jsxs)(mm.Fragment,{children:[(0,mm.jsx)(Y4,{onLogout:()=>{dm.signOut()},isGuest:e.isAnonymous}),(0,mm.jsxs)(je,{children:[(0,mm.jsx)(Ve,{path:"/",element:(0,mm.jsx)(nb,{})}),(0,mm.jsx)(Ve,{path:"/translate",element:(0,mm.jsx)(Gy,{user:e})}),(0,mm.jsx)(Ve,{path:"/history",element:(0,mm.jsx)(Zy,{user:e})}),(0,mm.jsx)(Ve,{path:"/voice-translation",element:(0,mm.jsx)(ob,{user:e})}),(0,mm.jsx)(Ve,{path:"/image-translation",element:(0,mm.jsx)(db,{user:e})}),(0,mm.jsx)(Ve,{path:"/sign-language",element:(0,mm.jsx)(V4,{})}),(0,mm.jsx)(Ve,{path:"*",element:(0,mm.jsx)(Ue,{to:"/"})})]})]}):"login"===n?(0,mm.jsx)(wm,{onLogin:t,onToggleForm:s}):(0,mm.jsx)(Z4,{onSignup:t,onToggleForm:s})})})};R.createRoot(document.getElementById("root")).render((0,mm.jsx)(_.StrictMode,{children:(0,mm.jsx)(e5,{})}))})()})();
//# sourceMappingURL=main.42fe3020.js.map